<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>14.1. Basic Concepts</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="129-chapter_14._overloaded_operations_and_conversions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="131-14.2._input_and_output_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3549336" class="calibre29"><span class="bold">14.1. Basic Concepts</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Overloaded operators are functions with special names: the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator</span></tt></code> followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type, a parameter list, and a body.</p><div class="calibre15">&#160;</div>
<p class="calibre25">An overloaded operator function has the same number of parameters as the operator has operands. A unary operator has one parameter; a binary operator has two. In a binary operator, the left-hand operand is passed to the first parameter and the right-hand operand to the second. Except for the overloaded function-call operator, <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator()</span></tt></code>, an overloaded operator may not have default arguments (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">If an operator function is a member function, the first (left-hand) operand is bound to the implicit <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">257</a>). Because the first operand is implicitly bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code>, a member operator function has one less (explicit) parameter than the operator has operands.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When an overloaded operator is a member function, <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> is bound to the left-hand operand. Member operator functions have one less (explicit) parameter than the number of operands.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">An operator function must either be a member of a class or have at least one parameter of class type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: cannot redefine the built-in operator for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int operator+(int, int);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This restriction means that we cannot change the meaning of an operator when applied to operands of built-in type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can overload most, but not all, of the operators. <a href="130-14.1._basic_concepts.html#filepos3552958">Table 14.1</a> shows whether or not an operator may be overloaded. We&#8217;ll cover overloading <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> in &#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">19.1.1</a> (p. <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">820</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3552958"/>Table 14.1. Operators</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00099.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">We can overload only existing operators and cannot invent new operator symbols. For example, we cannot define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator**</span></tt></code> to provide exponentiation.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Four symbols (<code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>) serve as both unary and binary operators. Either or both of these operators can be overloaded. The number of parameters determines which operator is being defined.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3553930"/>An overloaded operator has the same precedence and associativity (&#167; <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>) as the corresponding built-in operator. Regardless of the operand types</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">x == y + z;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">is always equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">x == (y + z)</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Calling an Overloaded Operator Function Directly</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, we &#8220;call&#8221; an overloaded operator function indirectly by using the operator on arguments of the appropriate type. However, we can also call an overloaded operator function directly in the same way that we call an ordinary function. We name the function and pass an appropriate number of arguments of the appropriate type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">equivalent calls to a nonmember operator function</span></span></span><br class="calibre6"/>data1 + data2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">normal expression</span></span></span><br class="calibre6"/>operator+(data1, data2); // <span><span class="calibre45"><span class="calibre16">equivalent function call</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These calls are equivalent: Both call the nonmember function <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+</span></tt></code>, passing <code class="calibre23"><tt class="calibre23"><span class="calibre24">data1</span></tt></code> as the first argument and <code class="calibre23"><tt class="calibre23"><span class="calibre24">data2</span></tt></code> as the second.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We call a member operator function explicitly in the same way that we call any other member function. We name an object (or pointer) on which to run the function and use the dot (or arrow) operator to fetch the function we wish to call:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">data1 += data2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">expression-based ''call''</span></span></span><br class="calibre6"/>data1.operator+=(data2);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent call to a member operator function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each of these statements calls the member function <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+=</span></tt></code>, binding <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> to the address of <code class="calibre23"><tt class="calibre23"><span class="calibre24">data1</span></tt></code> and passing <code class="calibre23"><tt class="calibre23"><span class="calibre24">data2</span></tt></code> as an argument.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Some Operators Shouldn&#8217;t Be Overloaded</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Recall that a few operators guarantee the order in which operands are evaluated. Because using an overloaded operator is really a function call, these guarantees do not apply to overloaded operators. In particular, the operand-evaluation guarantees of the logical <small class="calibre48">AND</small>, logical <small class="calibre48">OR</small> (&#167; <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">4.3</a>, p. <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">141</a>), and comma (&#167; <a href="048-4.10._comma_operator.html#filepos1151213">4.10</a>, p. <a href="048-4.10._comma_operator.html#filepos1151213">157</a>) <a id="filepos3558096"/>operators are not preserved. Moreover, overloaded versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code> operators do not preserve short-circuit evaluation properties of the built-in operators. Both operands are always evaluated.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the overloaded versions of these operators do not preserve order of evaluation and/or short-circuit evaluation, it is usually a bad idea to overload them. Users are likely to be surprised when the evaluation guarantees they are accustomed to are not honored for code that happens to use an overloaded version of one of these operators.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Another reason not to overload comma, which also applies to the address-of operator, is that unlike most operators, the language defines what the comma and address-of operators mean when applied to objects of class type. Because these operators have built-in meaning, they ordinarily should not be overloaded. Users of the class will be surprised if these operators behave differently from their normal meanings.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily, the comma, address-of, logical <small class="calibre48">AND</small>, and logical <small class="calibre48">OR</small> operators should <em class="calibre16">not</em> be overloaded.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Use Definitions That Are Consistent with the Built-in Meaning</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When you design a class, you should always think first about what operations the class will provide. Only after you know what operations are needed should you think about whether to define each operation as an ordinary function or as an overloaded operator. Those operations with a logical mapping to an operator are good candidates for defining as overloaded operators:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the class does IO, define the shift operators to be consistent with how IO is done for the built-in types.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the class has an operation to test for equality, define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator==</span></tt></code>. If the class has <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator==</span></tt></code>, it should usually have <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator!=</span></tt></code> as well.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the class has a single, natural ordering operation, define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&lt;</span></tt></code>. If the class has <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&lt;</span></tt></code>, it should probably have all of the relational operators.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The return type of an overloaded operator usually should be compatible with the return from the built-in version of the operator: The logical and relational operators should return <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, the arithmetic operators should return a value of the class type, and assignment and compound assignment should return a reference to the left-hand operand.</p></blockquote><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Assignment and Compound Assignment Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Assignment operators should behave analogously to the synthesized operators: After an assignment, the values in the left-hand and right-hand operands should have the same value, and the operator should return a reference to its left-hand operand. Overloaded assignment should generalize the built-in meaning of assignment, not circumvent it.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos3562487"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Use Operator Overloading Judiciously</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Each operator has an associated meaning from its use on the built-in types. Binary <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>, for example, is strongly identified with addition. Mapping binary <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> to an analogous operation for a class type can provide a convenient notational shorthand. For example, the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> type, following a convention common to many programming languages, uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> to represent concatenation&#8212;&#8220;adding&#8221; one <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to the other.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type. Using overloaded operators rather than inventing named operations can make our programs more natural and intuitive. Overuse or outright abuse of operator overloading can make our classes incomprehensible.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Obvious abuses of operator overloading rarely happen in practice. As an example, no responsible programmer would define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+</span></tt></code> to perform subtraction. More common, but still inadvisable, are uses that contort an operator&#8217;s &#8220;normal&#8221; meaning to force a fit to a given type. Operators should be used only for operations that are likely to be unambiguous to users. An operator has an ambiguous meaning if it plausibly has more than one interpretation.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">If a class has an arithmetic (&#167; <a href="040-4.2._arithmetic_operators.html#filepos1028232">4.2</a>, p. <a href="040-4.2._arithmetic_operators.html#filepos1028232">139</a>) or bitwise (&#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a>, p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">152</a>) operator, then it is usually a good idea to provide the corresponding compound-assignment operator as well. Needless to say, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">+=</span></tt></code> operator should be defined to behave the same way the built-in operators do: it should behave as <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> followed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Choosing Member or Nonmember Implementation</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we define an overloaded operator, we must decide whether to make the operator a class member or an ordinary nonmember function. In some cases, there is no choice&#8212;some operators are required to be members; in other cases, we may not be able to define the operator appropriately if it is a member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The following guidelines can be of help in deciding whether to make an operator a member or an ordinary nonmember function:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The assignment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>), subscript (<code class="calibre23"><tt class="calibre23"><span class="calibre24">[]</span></tt></code>), call (<code class="calibre23"><tt class="calibre23"><span class="calibre24">()</span></tt></code>), and member access arrow (<code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code>) operators <em class="calibre16">must</em> be defined as members.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The compound-assignment operators ordinarily <em class="calibre16">ought</em> to be members. However, unlike assignment, they are not required to be members.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Operators that change the state of their object or that are closely tied to their given type&#8212;such as increment, decrement, and dereference&#8212;usually should be members.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Symmetric operators&#8212;those that might convert either operand, such as the arithmetic, equality, relational, and bitwise operators&#8212;usually should be defined as ordinary nonmember functions.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">Programmers expect to be able to use symmetric operators in expressions with mixed types. For example, we can add an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. The addition is symmetric because we can use either type as the left-hand or the right-hand operand. <a id="filepos3567654"/>If we want to provide similar mixed-type expressions involving class objects, then the operator must be defined as a nonmember function.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we define an operator as a member function, then the left-hand operand must be an object of the class of which that operator is a member. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s = "world";<br class="calibre6"/>string t = s + "!";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: we can add a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const char*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>string u = "hi" + s; // <span><span class="calibre45"><span class="calibre16">would be an error if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">+</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">were a member of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+</span></tt></code> were a member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class, the first addition would be equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">s.operator+("!")</span></tt></code>. Likewise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">"hi" + s</span></tt></code> would be equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">"hi".operator+(s)</span></tt></code>. However, the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">"hi"</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code>, and that is a built-in type; it does not even have member functions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> as an ordinary nonmember function, <code class="calibre23"><tt class="calibre23"><span class="calibre24">"hi" + s</span></tt></code> is equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+("hi", s)</span></tt></code>. As with any function call, either of the arguments can be converted to the type of the parameter. The only requirements are that at least one of the operands has a class type, and that both operands can be converted (unambiguously) to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.1:</strong> In what ways does an overloaded operator differ from a built-in operator? In what ways are overloaded operators the same as the built-in operators?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.2:</strong> Write declarations for the overloaded input, output, addition, and compound-assignment operators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.3:</strong> Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> define an overloaded <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> that can be used to compare objects of those types. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec2</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s that hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, identify which version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> is applied in each of the following expressions:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">"cobble" == "stone"</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">svec1[0] == svec2[0]</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">svec1 == svec2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">"svec1[0] == "stone"</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.4:</strong> Explain how to decide whether the following should be class members:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">%</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">%=</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(g)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(h)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">()</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.5:</strong> In <a href="077-7.5._constructors_revisited.html#filepos1972067">exercise 7.40</a> from &#167; <a href="077-7.5._constructors_revisited.html#filepos1953073">7.5.1</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1953073">291</a>) you wrote a sketch of one of the following classes. Decide what, if any, overloaded operators your class should provide.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Book</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Date</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Employee</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Vehicle</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Object</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Tree</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="129-chapter_14._overloaded_operations_and_conversions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="131-14.2._input_and_output_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
