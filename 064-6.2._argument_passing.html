<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>6.2. Argument Passing</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="063-6.1._function_basics.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="065-6.3._return_types_and_the_return_statement.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1451214" class="calibre29"><span class="bold">6.2. Argument Passing</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, each time we call a function, its parameters are created and initialized by the arguments passed in the call.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Parameter initialization works the same way as variable initialization.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference (&#167; <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">50</a>), then the parameter is bound to its argument. Otherwise, the argument&#8217;s value is copied.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When a parameter is a reference, we say that its corresponding argument is <strong class="calibre5">&#8220;passed by reference&#8221;</strong> or that the function is <strong class="calibre5">&#8220;called by reference.&#8221;</strong> As with any other reference, a reference parameter is an alias for the object to which it is bound; that is, the parameter is an alias for its corresponding argument.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos1452816"/>When the argument value is copied, the parameter and argument are independent objects. We say such arguments are <strong class="calibre5">&#8220;passed by value&#8221;</strong> or alternatively that the function is <strong class="calibre5">&#8220;called by value.&#8221;</strong></p><div class="calibre22">&#160;</div>
<h4 id="filepos1453096" class="calibre37"><span class="calibre5">6.2.1. Passing Arguments by Value</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">When we initialize a nonreference type variable, the value of the initializer is copied. Changes made to the variable have no effect on the initializer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int n = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ordinary variable of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int i = n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a copy of the value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span><br class="calibre6"/>i = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is changed;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Passing an argument by value works exactly the same way; nothing the function does to the parameter can affect the argument. For example, inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">fact</span></tt></code> (&#167; <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">202</a>) the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is decremented:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ret *= val--;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">decrements the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">fact</span></tt></code> changes the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>, that change has no effect on the argument passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fact</span></tt></code>. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">fact(i)</span></tt></code> does not change the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Pointers (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>) behave like any other nonreference type. When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points. We can change the value of that object by assigning through the pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">55</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int n = 0, i = 42;<br class="calibre6"/>int *p = &amp;n, *q = &amp;i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>*p = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is changed</span></span></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is unchanged</span></span></span><br class="calibre6"/>p = q;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><span class="calibre45"><span class="calibre16">values in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The same behavior applies to pointer parameters:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">function that takes a pointer and sets the pointed-to value to zero</span></span></span><br class="calibre6"/>void reset(int *ip)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;*ip = 0;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">changes the value of the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ip = 0;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">changes only the local copy of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; the argument is unchanged</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">After a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>, the object to which the argument points will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, but the pointer argument itself is unchanged:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>reset(&amp;i);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">changes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">but not the address of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span> = 0</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos1461475"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos1462148"/><strong class="calibre5">Exercise 6.10:</strong> Using pointers, write a function to swap the values of two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Test the function by calling it and printing the swapped values.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1462468" class="calibre37"><span class="calibre5">6.2.2. Passing Arguments by Reference</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Recall that operations on a reference are actually operations on the object to which the reference refers (&#167; <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">50</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int n = 0, i = 42;<br class="calibre6"/>int &amp;r = n;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(i.e.,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is another name for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span><span><span class="calibre45"><span class="calibre16">)</span></span></span><br class="calibre6"/>r = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is now</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><br class="calibre6"/>r = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now has the same value as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>i = r;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has the same value as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Reference parameters exploit this behavior. They are often used to allow a function to change the value of one or more of its arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As one example, we can rewrite our <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> program from the previous section to take a reference instead of a pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">function that takes a reference to an int and sets the given object to zero</span></span></span><br class="calibre6"/>void reset(int &amp;i)&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is just another name for the object passed to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reset</span></span></tt></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;i = 0;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">changes the value of the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with any other reference, a reference parameter is bound directly to the object from which it is initialized. When we call this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> will be bound to whatever <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> object we pass. As with any reference, changes made to <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> are made to the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> refers. In this case, that object is the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>, we pass an object directly; there is no need to pass its address:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int j = 42;<br class="calibre6"/>reset(j);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is passed by reference; the value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is changed</span></span></span><br class="calibre6"/>cout &lt;&lt; "j = " &lt;&lt; j&#160;&#160;&lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j = 0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this call, the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is just another name for <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>. Any use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> is a use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1468676"/>Using References to Avoid Copies</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll write a function to compare the length of two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s can be long, we&#8217;d like to avoid copying them, so we&#8217;ll make our parameters references. Because comparing two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s does not involve changing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, we&#8217;ll make the parameters references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, p. <a href="024-2.4._const_qualifier.html#filepos476737">61</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">compare the length of two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>bool isShorter(const string &amp;s1, const string &amp;s2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return s1.size() &lt; s2.size();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we&#8217;ll see in &#167; <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>), functions should use references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> for reference parameters they do not need to change.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Reference parameters that are not changed inside a function should be references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Reference Parameters to Return Additional Information</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results. As an example, we&#8217;ll define a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> that will return the position of the first occurrence of a given character in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We&#8217;d also like the function to return a count of how many times that character occurs.</p><div class="calibre15">&#160;</div>
<p class="calibre25">How can we define a function that returns a position and an occurrence count? We could define a new type that contains the position and the count. An easier solution is to pass an additional reference argument to hold the occurrence count:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns the index of the first occurrence of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the reference parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">occurs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">counts how often</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">occurs</span></span></span><br class="calibre6"/>string::size_type find_char(const string &amp;s, char c,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string::size_type &amp;occurs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret = s.size();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">position of the first occurrence, if any</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;occurs = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">set the occurrence count parameter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (decltype(ret) i = 0; i != s.size(); ++i) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (s[i] == c) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (ret == s.size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret = i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remember the first occurrence of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++occurs;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">increment the occurrence count</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">count is returned implicitly in</span></span></span> occurs<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1475079"/>When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code>, we have to pass three arguments: a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in which to look, the character to look for, and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>) object to hold the occurrence count. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> object, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto index = find_char(s, 'o', ctr);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">After the call, the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code> will be the number of times <code class="calibre23"><tt class="calibre23"><span class="calibre24">o</span></tt></code> occurs, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">index</span></tt></code> will refer to the first occurrence if there is one. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">index</span></tt></code> will be equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">s.size()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code> will be zero.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.11:</strong> Write and test your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> that takes a reference.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.12:</strong> Rewrite the program from <a href="064-6.2._argument_passing.html#filepos1462148">exercise 6.10</a> in &#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a> (p. <a href="064-6.2._argument_passing.html#filepos1453096">210</a>) to use references instead of pointers to swap the value of two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Which version do you think would be easier to use and why?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.13:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is the name of a type, explain the difference between a function declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">void f(T)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">void f(T&amp;)</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.14:</strong> Give an example of when a parameter should be a reference type. Give an example of when a parameter should not be a reference.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.15:</strong> Explain the rationale for the type of each of <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code>&#8217;s parameters In particular, why is <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> but <code class="calibre23"><tt class="calibre23"><span class="calibre24">occurs</span></tt></code> is a plain reference? Why are these parameters references, but the <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> is not? What would happen if we made <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> a plain reference? What if we made <code class="calibre23"><tt class="calibre23"><span class="calibre24">occurs</span></tt></code> a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1479382" class="calibre37"><span class="calibre5">6.2.3. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Parameters and Arguments</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">When we use parameters that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, it is important to remember the discussion of top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> from &#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a> (p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>). As we saw in that section, a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> is one that applies to the object itself:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int ci = 42;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we cannot change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level</span></span></span><br class="calibre6"/>int i = ci;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: when we copy</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, its top-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is ignored</span></span></span><br class="calibre6"/>int * const p = &amp;i;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level; we can't assign to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>*p = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: changes through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are allowed;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is now</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Just as in any other initialization, when we copy an argument to initialize a parameter, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are ignored. As a result, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> on parameters are ignored. We can pass either a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object to a parameter that has a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn(const int i) { /* <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read but not write to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span> */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> passing it either a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code> or a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The fact that top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are ignored on a parameter has one possibly surprising implication:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1483921"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn(const int i) { /* <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read but not write to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span> */ }<br class="calibre6"/>void fcn(int i) { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span> */ } // <span><span class="calibre45"><span class="calibre16">error: redefines</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn(int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In C++, we can define several different functions that have the same name. However, we can do so only if their parameter lists are sufficiently different. Because top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are ignored, we can pass exactly the same types to either version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code>. The second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> is an error. Despite appearances, its parameter list doesn&#8217;t differ from the list in the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer or Reference Parameters and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Because parameters are initialized in the same way that variables are initialized, it can be helpful to remember the general initialization rules. We can initialize an object with a low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> from a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object but not vice versa, and a plain reference must be initialized from an object of the same type.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>const int *cp = &amp;i; // <span><span class="calibre45"><span class="calibre16">ok: but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can't change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(&#167; 2.4.2 (p. 62))</span></span></span><br class="calibre6"/>const int &amp;r = i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can't change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(&#167; 2.4.1 (p. 61))</span></span></span><br class="calibre6"/>const int &amp;r2 = 42; // <span><span class="calibre45"><span class="calibre16">ok: (&#167; 2.4.1 (p. 61))</span></span></span><br class="calibre6"/>int *p = cp;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: types of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">don't match (&#167; 2.4.2 (p. 62))</span></span></span><br class="calibre6"/>int &amp;r3 = r;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: types of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">don't match (&#167; 2.4.1 (p. 61))</span></span></span><br class="calibre6"/>int &amp;r4 = 42; // <span><span class="calibre45"><span class="calibre16">error: can't initialize a plain reference from a literal (&#167; 2.3.1 (p. 50)</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Exactly the same initialization rules apply to parameter passing:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0;<br class="calibre6"/>const int ci = i;<br class="calibre6"/>string::size_type ctr = 0;<br class="calibre6"/>reset(&amp;i);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls the version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that has an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter</span></span></span><br class="calibre6"/>reset(&amp;ci);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: can't initialize an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from a pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>reset(i);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls the version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that has an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter</span></span></span><br class="calibre6"/>reset(ci);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: can't bind a plain reference to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><br class="calibre6"/>reset(42);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: can't bind a plain reference to a literal</span></span></span><br class="calibre6"/>reset(ctr);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: types don't match;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ctr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unsigned</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok</span></span></span>: <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">find_char's</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">first parameter is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>find_char("Hello World!", 'o', ctr);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can call the reference version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> (&#167; <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a>, p. <a href="064-6.2._argument_passing.html#filepos1462468">210</a>) only on <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> objects. We cannot pass a literal, an expression that evaluates to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, an object that requires conversion, or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code> object. Similarly, we may pass only an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code> to the pointer version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> (&#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>). On the other hand, we can pass a string literal as the first argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> (&#167; <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a>, p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>). That function&#8217;s reference parameter is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and we can initialize references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> from literals.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Use Reference to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> When Possible</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function&#8217;s caller the misleading impression that the function might change its argument&#8217;s value. Moreover, using a <a id="filepos1493334"/>reference instead of a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> unduly limits the type of arguments that can be used with the function. As we&#8217;ve just seen, we cannot pass a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, or a literal, or an object that requires conversion to a plain reference parameter.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The effect of this mistake can be surprisingly pervasive. As an example, consider our <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> function from &#167; <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a> (p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>). That function (correctly) made its <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> parameter a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Had we defined that parameter as a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">bad design: the first parameter should be a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const string&amp;</span></span></tt></span><br class="calibre6"/>string::size_type find_char(string &amp;s, char c,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string::size_type &amp;occurs);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">we could call <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> only on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> object. A call such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">find_char("Hello World", 'o', ctr);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">would fail at compile time.</p><div class="calibre15">&#160;</div>
<p class="calibre25">More subtly, we could not use this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> from other functions that (correctly) define their parameters as references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. For example, we might want to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> inside a function that determines whether a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> represents a sentence:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool is_sentence(const string &amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if there's a single period at the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, then</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a sentence</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;string::size_type ctr = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;return find_char(s, '.', ctr) == s.size() - 1 &amp;&amp; ctr == 1;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> took a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>, then this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> would be a compile-time error. The problem is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code> was (incorrectly) defined to take a plain reference.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It might be tempting to try to fix this problem by changing the type of the parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">is_sentence</span></tt></code>. But that fix only propagates the error&#8212;callers of <code class="calibre23"><tt class="calibre23"><span class="calibre24">is_sentence</span></tt></code> could pass only non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>s.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The right way to fix this problem is to fix the parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code>. If it&#8217;s not possible to change <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code>, then define a local <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">is_sentence</span></tt></code> and pass that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_char</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 id="filepos1499104" class="calibre37"><span class="calibre5">6.2.4. Array Parameters</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), and when we use an array it is (usually) converted to a pointer (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">117</a>). Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array&#8217;s first element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Even though we cannot pass an array by value, we can write a parameter that looks like an array:</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1500012"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.16:</strong> The following function, although legal, is less useful than it might be. Identify and correct the limitation on this function:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool is_empty(string&amp; s) { return s.empty(); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.17:</strong> Write a function to determine whether a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> contains any capital letters. Write a function to change a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to all lowercase. Do the parameters you used in these functions have the same type? If so, why? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.18:</strong> Write declarations for each of the following functions. When you write these declarations, use the name of the function to indicate what the function does.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong> A function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> and has two parameters that are references to a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">matrix</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong> A function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">change_val</span></tt></code> that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code> iterator and takes two parameters: One is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and the other is an iterator for a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.19:</strong> Given the following declarations, determine which calls are legal and which are illegal. For those that are illegal, explain why.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double calc(double);<br class="calibre6"/>int count(const string &amp;, char);<br class="calibre6"/>int sum(vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator, int);<br class="calibre6"/>vector&lt;int&gt; vec(10);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">calc(23.4, 55.1);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">count("abcda", 'a');</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">calc(66);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">sum(vec.begin(), vec.end(), 3.8);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.20:</strong> When should reference parameters be references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>? What happens if we make a parameter a plain reference when it could be a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">despite appearances, these three declarations of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are equivalent</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">each function has a single parameter of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int*</span></span></tt></span><br class="calibre6"/>void print(const int*);<br class="calibre6"/>void print(const int[]);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">shows the intent that the function takes an array</span></span></span><br class="calibre6"/>void print(const int[10]); // <span><span class="calibre45"><span class="calibre16">dimension for documentation purposes (at best</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Regardless of appearances, these declarations are equivalent: Each declares a function with a single parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int*</span></tt></code>. When the compiler checks a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>, it checks only that the argument has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int*</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, j[2] = {0, 1};<br class="calibre6"/>print(&amp;i); // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span><br class="calibre6"/>print(j);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is converted to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j[0]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we pass an array to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>, that argument is automatically converted to a pointer to the first element in the array; the size of the array is irrelevant.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As with any code that uses arrays, functions that take array parameters must ensure that all uses of the array stay within the array bounds.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos1507824"/>Because arrays are passed as pointers, functions ordinarily don&#8217;t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Marker to Specify the Extent of an Array</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings (&#167; <a href="034-3.5._arrays.html#filepos918393">3.5.4</a>, p. <a href="034-3.5._arrays.html#filepos918393">122</a>) are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void print(const char *cp)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (cp)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a null pointer</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (*cp)&#160;&#160;// <span><span class="calibre45"><span class="calibre16">so long as the character it points to is not a null character</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *cp++; // <span><span class="calibre45"><span class="calibre16">print the character and advance the pointer</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This convention works well for data where there is an obvious end-marker value (like the null character) that does not appear in ordinary data. It works less well with data, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, where every value in the range is a legitimate value.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Standard Library Conventions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array. This approach is inspired by techniques used in the standard library. We&#8217;ll learn more about this style of programming in <a href="081-part_ii_the_cpp_library.html#filepos2066884">Part II</a>. Using this approach, we&#8217;ll print the elements in an array as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void print(const int *beg, const int *end)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print every element starting at</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">beg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">up to but not including</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">end</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;while (beg != end)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *beg++ &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print the current element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">and advance the pointer</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> uses the dereference and postfix increment operators (&#167; <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">4.5</a>, p. <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">148</a>) to print the current element and advance <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> one element at a time through the array. The loop stops when <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To call this function, we pass two pointers&#8212;one to the first element we want to print and one just past the last element:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int j[2] = {0, 1};<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is converted to a pointer to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the second argument is a pointer to one past the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span><br class="calibre6"/>print(begin(j), end(j)); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">end</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">functions, see</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#167; 3.5.3 (p. 118</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This function is safe, as long as the caller correctly calculates the pointers. Here we let the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> functions (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) provide those pointers.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1514313"/>Explicitly Passing a Size Parameter</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array. Using this approach, we&#8217;ll rewrite <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int ia[]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int* ia</span></span></tt></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is passed explicitly and used to control access to elements of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span><br class="calibre6"/>void print(const int ia[], size_t size)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;for (size_t i = 0; i != size; ++i) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ia[i] &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> parameter to determine how many elements there are to print. When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>, we must pass this additional parameter:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int j[] = { 0, 1 };&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">array of size 2</span></span></span><br class="calibre6"/>print(j, end(j) - begin(j));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The function executes safely as long as the size passed is no greater than the actual size of the array.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Array Parameters and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Note that all three versions of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function defined their array parameters as pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. The discussion in &#167; <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>) applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>). A parameter should be a plain pointer to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type only if the function needs to change element values.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Array Reference Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as we can define a variable that is a reference to an array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), we can define a parameter that is a reference to an array. As usual, the reference parameter is bound to the corresponding argument, which in this case is an array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: parameter is a reference to an array; the dimension is part of the type</span></span></span><br class="calibre6"/>void print(int (&amp;arr)[10])<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;for (auto elem : arr)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; elem &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;arr</span></tt></code> are necessary (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>):</p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f(int &amp;arr[10])&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: declares</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as an array of references</span></span></span><br class="calibre6"/>f(int (&amp;arr)[10]) // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos1520481"/>Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. We may call this function only for an array of exactly ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, j[2] = {0, 1};<br class="calibre6"/>int k[10] = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>print(&amp;i);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: argument is not an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>print(j);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: argument is not an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>print(k);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: argument is an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We&#8217;ll see in &#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a> (p. <a href="154-16.1._defining_a_template.html#filepos4156441">654</a>) how we might write this function in a way that would allow us to pass a reference parameter to an array of any size.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Passing a Multidimensional Array</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Recall that there are no multidimensional arrays in C++ (&#167; <a href="035-3.6._multidimensional_arrays.html#filepos942882">3.6</a>, p. <a href="035-3.6._multidimensional_arrays.html#filepos942882">125</a>). Instead, what appears to be a multidimensional array is an array of arrays.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any array, a multidimensional array is passed as a pointer to its first element (&#167; <a href="035-3.6._multidimensional_arrays.html#filepos942882">3.6</a>, p. <a href="035-3.6._multidimensional_arrays.html#filepos942882">128</a>). Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">matrix</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first element in an array whose elements are arrays of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>void print(int (*matrix)[10], int rowSize) { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span> */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">declares <code class="calibre23"><tt class="calibre23"><span class="calibre24">matrix</span></tt></code> as a pointer to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Again, the parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">*matrix</span></tt></code> are necessary:</p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *matrix[10];&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of ten pointers</span></span></span><br class="calibre6"/>int (*matrix)[10]; // <span><span class="calibre45"><span class="calibre16">pointer to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">equivalent definition</span></span></span><br class="calibre6"/>void print(int matrix[][10], int rowSize) { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span> */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">declares <code class="calibre23"><tt class="calibre23"><span class="calibre24">matrix</span></tt></code> to be what looks like a two-dimensional array. In fact, the parameter is a pointer to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<h4 id="filepos1526324" class="calibre37"><span class="calibre5">6.2.5. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">main</span></span></tt></span></span></tt></code>: Handling Command-Line Options</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">It turns out that <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> is a good example of how C++ programs pass arrays to functions. Up to now, we have defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> with an empty parameter list:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main() { ... }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, we sometimes need to pass arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>. The most common use of arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> is to let the user specify a set of options to guide the operation of the program. For example, assuming our <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> program is in an executable file named <code class="calibre23"><tt class="calibre23"><span class="calibre24">prog</span></tt></code>, we might pass options to the program as follows:</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1527699"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.21:</strong> Write a function that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and returns the larger of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value or the value to which the pointer points. What type should you use for the pointer?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.22:</strong> Write a function to swap two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> pointers.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.23:</strong> Write your own versions of each of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> functions presented in this section. Call each of these functions to print <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> defined as follows:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, j[2] = {0, 1};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.24:</strong> Explain the behavior of the following function. If there are problems in the code, explain what they are and how you might fix them.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void print(const int ia[10])<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;for (size_t i = 0; i != 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; ia[i] &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">prog -d -o ofile data0</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Such command-line options are passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> in two (optional) parameters:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main(int argc, char *argv[]) { ... }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The second parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv</span></tt></code>, is an array of pointers to C-style character strings. The first parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">argc</span></tt></code>, passes the number of strings in that array. Because the second parameter is an array, we might alternatively define <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main(int argc, char **argv) { ... }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">indicating that <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv</span></tt></code> points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When arguments are passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>, the first element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv</span></tt></code> points either to the name of the program or to the empty string. Subsequent elements pass the arguments provided on the command line. The element just past the last pointer is guaranteed to be 0.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Given the previous command line, <code class="calibre23"><tt class="calibre23"><span class="calibre24">argc</span></tt></code> would be 5, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv</span></tt></code> would hold the following C-style character strings:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">argv[0] = "prog";&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">argv[0]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">might point to an empty string</span></span></span><br class="calibre6"/>argv[1] = "-d";<br class="calibre6"/>argv[2] = "-o";<br class="calibre6"/>argv[3] = "ofile";<br class="calibre6"/>argv[4] = "data0";<br class="calibre6"/>argv[5] = 0;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When you use the arguments in <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv</span></tt></code>, remember that the optional arguments begin in <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv[1]</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">argv[0]</span></tt></code> contains the program&#8217;s name, not user input.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1533816"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.25:</strong> Write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function that takes two arguments. Concatenate the supplied arguments and print the resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.26:</strong> Write a program that accepts the options presented in this section. Print the values of the arguments passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1534679" class="calibre37"><span class="calibre5">6.2.6. Functions with Varying Parameters</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes we do not know in advance how many arguments we need to pass to a function. For example, we might want to write a routine to print error messages generated from our program. We&#8217;d like to use a single function to print these error messages in order to handle them in a uniform way. However, different calls to our error-printing function might pass different arguments, corresponding to different kinds of error messages.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code>. If the argument types vary, we can write a special kind of function, known as a variadic template, which we&#8217;ll cover in &#167; <a href="157-16.4._variadic_templates.html#filepos4464798">16.4</a> (p. <a href="157-16.4._variadic_templates.html#filepos4464798">699</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments. We&#8217;ll look briefly at ellipsis parameters in this section. However, it is worth noting that this facility ordinarily should be used only in programs that need to interface to C functions.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">initializer_list</span></span></tt></span></span></tt></code> Parameters</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos1536414"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">We can write a function that takes an unknown number of arguments of a single type by using an <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos1536683" href="071-defined_terms.html#filepos1734206">initializer_list</a></span></span></tt></span></span></tt></code> parameter. An <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> is a library type that represents an array (&#167; <a href="034-3.5._arrays.html#filepos853883">3.5</a>, p. <a href="034-3.5._arrays.html#filepos853883">113</a>) of values of the specified type. This type is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> header. The operations that <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> provides are listed in <a href="064-6.2._argument_passing.html#filepos1537380">Table 6.1</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos1537380"/>Table 6.1. Operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">initializer_list</span></span></tt></span></span></tt></code>s</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00039.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1537712"/>Like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> is a template type (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). When we define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code>, we must specify the type of the elements that the list will contain:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">initializer_list&lt;string&gt; ls; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">initializer_list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>initializer_list&lt;int&gt; li;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">initializer_list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, the elements in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> are always <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> values; there is no way to change the value of an element in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can write our function to produce error messages from a varying number of arguments as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void error_msg(initializer_list&lt;string&gt; il)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;for (auto beg = il.begin(); beg != il.end(); ++beg)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; *beg &lt;&lt; " " ;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> objects are analogous to the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> members (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin()</span></tt></code> member gives us a pointer to the first element in the list, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code> is an off-the-end pointer one past the last element. Our function initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> to denote the first element and iterates through each element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code>. In the body of the loop we dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> in order to access the current element and print its value.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we pass a sequence of values to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> parameter, we must enclose the sequence in curly braces:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">expected</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">actual</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>if (expected != actual)<br class="calibre6"/>&#160;&#160;&#160;&#160;error_msg({"functionX", expected, actual});<br class="calibre6"/>else<br class="calibre6"/>&#160;&#160;&#160;&#160;error_msg({"functionX", "okay"});</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;re calling the same function, <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code>, passing three values in the first call and two values in the second.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A function with an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> parameter can have other parameters as well. For example, our debugging system might have a class, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">ErrCode</span></tt></code>, that represents various kinds of errors. We can revise our program to take an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ErrCode</span></tt></code> in addition to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void error_msg(ErrCode e, initializer_list&lt;string&gt; il)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; e.msg() &lt;&lt; ": ";<br class="calibre6"/>&#160;&#160;&#160;&#160;for (const auto &amp;elem : il)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; elem &lt;&lt; " " ;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> has <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members, we can use a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> (&#167; <a href="057-5.4._iterative_statements.html#filepos1331917">5.4.3</a>, p. <a href="057-5.4._iterative_statements.html#filepos1331917">187</a>) to process the elements. This program, like our previous version, iterates an element at a time through the braced list of values passed to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">il</span></tt></code> parameter.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos1544813"/>To call this version, we need to revise our calls to pass an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ErrCode</span></tt></code> argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (expected != actual)<br class="calibre6"/>&#160;&#160;&#160;&#160;error_msg(ErrCode(42), {"functionX", expected, actual});<br class="calibre6"/>else<br class="calibre6"/>&#160;&#160;&#160;&#160;error_msg(ErrCode(0), {"functionX", "okay"});</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Ellipsis Parameters</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named <code class="calibre23"><tt class="calibre23"><span class="calibre24">varargs</span></tt></code>. Generally an ellipsis parameter should not be used for other purposes. Your C compiler documentation will describe how to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">varargs</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void foo(parm_list, ...);<br class="calibre6"/>void foo(...);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first form specifies the type(s) for some of <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code>&#8217;s parameters. Arguments that correspond to the specified parameters are type checked as usual. No type checking is done for the arguments that correspond to the ellipsis parameter. In this first form, the comma following the parameter declarations is optional.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.2.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.27:</strong> Write a function that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;int&gt;</span></tt></code> and produces the sum of the elements in the list.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.28:</strong> In the second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code> that has an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ErrCode</span></tt></code> parameter, what is the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.29:</strong> When you use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> in a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> would you ever use a reference as the loop control variable? If so, why? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="063-6.1._function_basics.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="065-6.3._return_types_and_the_return_statement.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
