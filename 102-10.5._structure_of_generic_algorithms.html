<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>10.5. Structure of Generic Algorithms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="101-10.4._revisiting_iterators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="103-10.6._containerspecific_algorithms.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2671539" class="calibre29"><span class="bold">10.5. Structure of Generic Algorithms</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Some algorithms, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>, require only the ability to access an element through the iterator, to increment the iterator, and to compare two iterators for equality. Others, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five <strong class="calibre5"><a id="filepos2672310" href="105-defined_terms.html#filepos2714214">iterator categories</a></strong> listed in <a href="102-10.5._structure_of_generic_algorithms.html#filepos2672603">Table 10.5</a>. Each algorithm specifies what kind of iterator must be supplied for each of its iterator parameters.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2672603"/>Table 10.5. Iterator Categories</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00077.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">A second way is to classify the algorithms (as we did in the beginning of this chapter) is by whether they read, write, or reorder the elements in the sequence. <a href="187-appendix_a._the_library.html#filepos5411866">Appendix A</a> covers all the algorithms according to this classification.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The algorithms also share a set of parameter-passing conventions and a set of naming conventions, which we shall cover after looking at iterator categories.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2673303" class="calibre37"><span class="calibre5">10.5.1. The Five Iterator Categories</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Like the containers, iterators define a common set of operations. Some operations are provided by all iterators; other operations are supported by only specific kinds of iterators. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream_iterator</span></tt></code>s have only increment, dereference, and assignment. Iterators on <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>s support these operations and the decrement, relational, and arithmetic operators.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Iterators are categorized by the operations they provide and the categories form a sort of hierarchy. With the exception of output iterators, an iterator of a higher category provides all the operations of the iterators of a lower categories.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The standard specifies the minimum category for each iterator parameter of the <a id="filepos2674588"/>generic and numeric algorithms. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>&#8212;which implements a one-pass, read-only traversal over a sequence&#8212;minimally requires an input iterator. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">replace</span></tt></code> function requires a pair of iterators that are at least forward iterators. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">replace_copy</span></tt></code> requires forward iterators for its first two iterators. Its third iterator, which represents a destination, must be at least an output iterator, and so on. For each parameter, the iterator must be at least as powerful as the stipulated minimum. Passing an iterator of a lesser power is an error.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Many compilers will not complain when we pass the wrong category of iterator to an algorithm.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Iterator Categories</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos2675943" href="105-defined_terms.html#filepos2713031">Input iterators</a></strong>: can read elements in a sequence. An input iterator must provide</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Equality and inequality operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code>) to compare two iterators</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Prefix and postfix increment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code>) to advance the iterator</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Dereference operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>) to read an element; dereference may appear only on the right-hand side of an assignment</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The arrow operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code>) as a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">(* it).member</span></tt></code>&#8212;that is, dereference the iterator and fetch a member from the underlying object</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Input iterators may be used only sequentially. We are guaranteed that <code class="calibre23"><tt class="calibre23"><span class="calibre24">*it++</span></tt></code> is valid, but incrementing an input iterator may invalidate all other iterators into the stream. As a result, there is no guarantee that we can save the state of an input iterator and examine an element through that saved iterator. Input iterators, therefore, may be used only for single-pass algorithms. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> algorithms require input iterators; <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream_iterator</span></tt></code>s are input iterators.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos2678096" href="105-defined_terms.html#filepos2716436">Output iterators</a></strong>: can be thought of as having complementary functionality to input iterators; they write rather than read elements. Output iterators must provide</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Prefix and postfix increment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code>) to advance the iterator</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Dereference (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>), which may appear only as the left-hand side of an assignment (Assigning to a dereferenced output iterator writes to the underlying element.)</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">We may assign to a given value of an output iterator only once. Like input iterators, output iterators may be used only for single-pass algorithms. Iterators used as a destination are typically output iterators. For example, the third parameter to <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> is an output iterator. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream_iterator</span></tt></code> type is an output iterator.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos2679434" href="105-defined_terms.html#filepos2712113">Forward iterators</a></strong>: can read and write a given sequence. They move in only one direction through the sequence. Forward iterators support all the operations of both input iterators and output iterators. Moreover, they can read or write the same element multiple times. Therefore, we can use the saved state of a forward iterator. Hence, algorithms that use forward iterators may make multiple passes through the sequence. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">replace</span></tt></code> algorithm requires a forward iterator; iterators on <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> are forward iterators.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2680196"/><strong class="calibre5"><a id="filepos2680212" href="105-defined_terms.html#filepos2710113">Bidirectional iterators</a></strong>: can read and write a sequence forward or backward. In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (<code class="calibre23"><tt class="calibre23"><span class="calibre24">--</span></tt></code>) operators. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">reverse</span></tt></code> algorithm requires bidirectional iterators, and aside from <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>, the library containers supply iterators that meet the requirements for a bidirectional iterator.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos2680939" href="105-defined_terms.html#filepos2717117">Random-access iterators</a></strong>: provide constant-time access to any position in the sequence. These iterators support all the functionality of bidirectional iterators. In addition, random-access iterators support the operations from <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a> (p. <a href="033-3.4._introducing_iterators.html#filepos840512">111</a>):</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The relational operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;=</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;=</span></tt></code>) to compare the relative positions of two iterators.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Addition and subtraction operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">+=</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">-=</span></tt></code>) on an iterator and an integral value. The result is the iterator advanced (or retreated) the integral number of elements within the sequence.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The subtraction operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code>) when applied to two iterators, which yields the distance between two iterators.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The subscript operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">iter[n]</span></tt></code>) as a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">* (iter + n)</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> algorithms require random-access iterators. Iterators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">array, deque, string</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> are random-access iterators, as are pointers when used to access elements of a built-in array.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.5.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.38:</strong> List the five iterator categories and the operations that each supports.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.39:</strong> What kind of iterator does a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> have? What about a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.40:</strong> What kinds of iterators do you think <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> requires? What about <code class="calibre23"><tt class="calibre23"><span class="calibre24">reverse</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2684451" class="calibre37"><span class="calibre5">10.5.2. Algorithm Parameter Patterns</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Superimposed on any other classification of the algorithms is a set of parameter conventions. Understanding these parameter conventions can aid in learning new algorithms&#8212;by knowing what the parameters mean, you can concentrate on understanding the operation the algorithm performs. Most of the algorithms have one of the following four forms:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><span class="calibre45"><span class="calibre16">alg</span></span></span>(beg, end, <span><span class="calibre45"><span class="calibre16">other args</span></span></span>);<br class="calibre6"/><span><span class="calibre45"><span class="calibre16">alg</span></span></span>(beg, end, dest, <span><span class="calibre45"><span class="calibre16">other args</span></span></span>);<br class="calibre6"/><span><span class="calibre45"><span class="calibre16">alg</span></span></span>(beg, end, beg2, <span><span class="calibre45"><span class="calibre16">other args</span></span></span>);<br class="calibre6"/><span><span class="calibre45"><span class="calibre16">alg</span></span></span>(beg, end, beg2, end2, <span><span class="calibre45"><span class="calibre16">other args</span></span></span>);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">alg</em> is the name of the algorithm, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> denote the input range on which the algorithm operates. Although nearly all algorithms take an input <a id="filepos2686289"/>range, the presence of the other parameters depends on the work being performed. The common ones listed here&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2</span></tt></code>&#8212;are all iterators. When used, these iterators fill similar roles. In addition to these iterator parameters, some algorithms take additional, noniterator parameters that are algorithm specific.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms with a Single Destination Iterator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> parameter is an iterator that denotes a destination in which the algorithm can write its output. Algorithms <em class="calibre16">assume</em> that it is safe to write as many elements as needed.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Algorithms that write to an output iterator assume the destination is large enough to hold the output.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> is an iterator that refers directly to a container, then the algorithm writes its output to existing elements within the container. More commonly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> is bound to an insert iterator (&#167; <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>) or an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream_iterator</span></tt></code> (&#167; <a href="101-10.4._revisiting_iterators.html#filepos2629061">10.4.2</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2629061">403</a>). An insert iterator adds new elements to the container, thereby ensuring that there is enough space. An <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream_iterator</span></tt></code> writes to an output stream, again presenting no problem regardless of how many elements are written.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms with a Second Input Sequence</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Algorithms that take either <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> alone or <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2</span></tt></code> use those iterators to denote a second input range. These algorithms typically use the elements from the second range in combination with the input range to perform a computation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When an algorithm takes both <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2</span></tt></code>, these iterators denote a second range. Such algorithms take two completely specified ranges: the input range denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">[beg, end)</span></tt></code>, and a second input range denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">[beg2, end2)</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Algorithms that take only <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> (and not <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2)</span></tt></code> treat <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> as the first element in a second input range. The end of this range is not specified. Instead, these algorithms <em class="calibre16">assume</em> that the range starting at <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> is at least as large as the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg, end</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Algorithms that take <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> alone <em class="calibre16">assume</em> that the sequence beginning at <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> is as large as the range denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2691116" class="calibre37"><span class="calibre5">10.5.3. Algorithm Naming Conventions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Separate from the parameter conventions, the algorithms also conform to a set of naming and overload conventions. These conventions deal with how we supply an operation to use in place of the default <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator and with whether the algorithm writes to its input sequence or to a separate destination.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Some Algorithms Use Overloading to Pass a Predicate</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Algorithms that take a predicate to use in place of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator, and that do not take other arguments, typically are overloaded. One version of the function <a id="filepos2692224"/>uses the element type&#8217;s operator to compare elements; the second takes an extra parameter that is a predicate to use in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unique(beg, end);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">==</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operator to compare the elements</span></span></span><br class="calibre6"/>unique(beg, end, comp); // <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">comp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to compare the elements</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both calls reorder the given sequence by removing adjacent duplicated elements. The first uses the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator to check for duplicates; the second calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">comp</span></tt></code> to decide whether two elements are equal. Because the two versions of the function differ as to the number of arguments, there is no possible ambiguity (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) as to which function is being called.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms with <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">_if</span></span></tt></span></span></tt></code> Versions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Algorithms that take an element value typically have a second named (not overloaded) version that takes a predicate (&#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a>, p. <a href="100-10.3._customizing_operations.html#filepos2520495">386</a>) in place of the value. The algorithms that take a predicate have the suffix <code class="calibre23"><tt class="calibre23"><span class="calibre24">_if</span></tt></code> appended:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">find(beg, end, val);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">find the first instance of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the input range</span></span></span><br class="calibre6"/>find_if(beg, end, pred); // <span><span class="calibre45"><span class="calibre16">find the first instance for which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pred</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These algorithms both find the first instance of a specific element in the input range. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> algorithm looks for a specific value; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> algorithm looks for a value for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">pred</span></tt></code> returns a nonzero value.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These algorithms provide a named version rather than an overloaded one because both versions of the algorithm take the same number of arguments. Overloading ambiguities would therefore be possible, albeit rare. To avoid any possible ambiguities, the library provides separate named versions for these algorithms.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Distinguishing Versions That Copy from Those That Do Not</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, algorithms that rearrange elements write the rearranged elements back into the given input range. These algorithms provide a second version that writes to a specified output destination. As we&#8217;ve seen, algorithms that write to a destination append <code class="calibre23"><tt class="calibre23"><span class="calibre24">_copy</span></tt></code> to their names (&#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">10.2.2</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">383</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">reverse(beg, end);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reverse the elements in the input range</span></span></span><br class="calibre6"/>reverse_copy(beg, end, dest);// <span><span class="calibre45"><span class="calibre16">copy elements in reverse order into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dest</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Some algorithms provide both <code class="calibre23"><tt class="calibre23"><span class="calibre24">_copy</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">_if</span></tt></code> versions. These versions take a destination iterator and a predicate:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">removes the odd elements from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><br class="calibre6"/>remove_if(v1.begin(), v1.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int i) { return i % 2; });<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">copies only the even elements from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2; v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is unchanged</span></span></span><br class="calibre6"/>remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int i) { return i % 2; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both calls use a lambda (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) to determine whether an element is odd. In the first case, we remove the odd elements from the input sequence itself. In the second, we copy the non-odd (aka even) elements from the input range into <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2699703"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.5.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.41:</strong> Based only on the algorithm and argument names, describe the operation that the each of the following library algorithms performs:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">replace(beg, end, old_val, new_val);<br class="calibre6"/>replace_if(beg, end, pred, new_val);<br class="calibre6"/>replace_copy(beg, end, dest, old_val, new_val);<br class="calibre6"/>replace_copy_if(beg, end, dest, pred, new_val);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="101-10.4._revisiting_iterators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="103-10.6._containerspecific_algorithms.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
