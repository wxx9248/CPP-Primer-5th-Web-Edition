<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>14.9. Overloading, Conversions, and Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="137-14.8._functioncall_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="139-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3713073" class="calibre29"><span class="bold">14.9. Overloading, Conversions, and Operators</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In &#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1990205">294</a>) we saw that a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor that can be called with one argument defines an implicit conversion. Such constructors convert an object from the argument&#8217;s type <em class="calibre16">to</em> the class type. We can also define conversions <em class="calibre16">from</em> the class type. We define a conversion from a class type by defining a conversion <a id="filepos3713754"/>operator. Converting constructors and conversion operators define <strong class="calibre5"><a id="filepos3713836" href="140-defined_terms.html#filepos3775553">class-type conversions</a></strong>. Such conversions are also referred to as <strong class="calibre5"><a id="filepos3713962" href="140-defined_terms.html#filepos3778805">user-defined conversions</a></strong>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos3714067" class="calibre37"><span class="calibre5">14.9.1. Conversion Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos3714207" href="140-defined_terms.html#filepos3776100">conversion operator</a></strong> is a special kind of member function that converts a value of a class type to a value of some other type. A conversion function typically has the general form</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">operator <span><span class="calibre45"><span class="calibre16">type</span></span></span>() const;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">type</em> represents a type. Conversion operators can be defined for any type (other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>) that can be a function return type (&#167; <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">204</a>). Conversions to an array or a function type are not permitted. Conversions to pointer types&#8212;both data and function pointers&#8212;and to reference types are allowed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Conversion operators have no explicitly stated return type and no parameters, and they must be defined as member functions. Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually should be defined as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> members.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A conversion function must be a member function, may not specify a return type, and must have an empty parameter list. The function usually should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Class with a Conversion Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll define a small class that represents an integer in the range of 0 to 255:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SmallInt {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;SmallInt(int i = 0): val(i)<br class="calibre6"/>&#160;&#160;&#160;&#160;{<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (i &lt; 0 || i &gt; 255)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw std::out_of_range("Bad SmallInt value");<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;operator int() const { return val; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::size_t val;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> class defines conversions <em class="calibre16">to</em> and <em class="calibre16">from</em> its type. The constructor converts values of arithmetic type to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code>. The conversion operator converts <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> objects to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">SmallInt si;<br class="calibre6"/>si = 4; // <span><span class="calibre45"><span class="calibre16">implicitly converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SmallInt</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">then calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SmallInt::operator=</span></span></tt></span><br class="calibre6"/>si + 3; // <span><span class="calibre45"><span class="calibre16">implicitly converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">si</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">followed by integer addition</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3718929"/>Although the compiler will apply only one user-defined conversion at a time (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>), an implicit user-defined conversion can be preceded or followed by a standard (built-in) conversion (&#167; <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">159</a>). As a result, we can pass any arithmetic type to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> constructor. Similarly, we can use the converion operator to convert a <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and then convert the resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value to another arithmetic type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">argument is converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">using the built-in conversion</span></span></span><br class="calibre6"/>SmallInt si = 3.14; // <span><span class="calibre45"><span class="calibre16">calls the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SmallInt(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">constructor</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SmallInt</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">conversion operator converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">si</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span><br class="calibre6"/>si + 3.14; // <span><span class="calibre45"><span class="calibre16">that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">using the built-in conversion</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because conversion operators are implicitly applied, there is no way to pass arguments to these functions. Hence, conversion operators may not be defined to take parameters. Although a conversion function does not specify a return type, each conversion function must return a value of its corresponding type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SmallInt;<br class="calibre6"/>operator int(SmallInt&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: nonmember</span></span></span><br class="calibre6"/>class SmallInt {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;int operator int() const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: return type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;operator int(int = 0) const;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: parameter list</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;operator int*() const { return 42; } // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a pointer</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Avoid Overuse of Conversion Functions</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As with using overloaded operators, judicious use of conversion operators can greatly simplify the job of a class designer and make using a class easier. However, some conversions can be misleading. Conversion operators are misleading when there is no obvious single mapping between the class type and the conversion type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">For example, consider a class that represents a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Date</span></tt></code>. We might think it would be a good idea to provide a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Date</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. However, what value should the conversion function return? The function might return a decimal representation of the year, month, and day. For example, July 30, 1989 might be represented as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value 19800730. Alternatively, the conversion operator might return an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> representing the number of days that have elapsed since some epoch point, such as January 1, 1970. Both these conversions have the desirable property that later dates correspond to larger integers, and so either might be useful.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">The problem is that there is no single one-to-one mapping between an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Date</span></tt></code> and a value of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. In such cases, it is better not to define the conversion operator. Instead, the class ought to define one or more ordinary members to extract the information in these various forms.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Conversion Operators Can Yield Suprising Results</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In practice, classes rarely provide conversion operators. Too often users are more likely to be surprised if a conversion happens automatically than to be helped by <a id="filepos3725848"/>the existence of the conversion. However, there is one important exception to this rule of thumb: It is not uncommon for classes to define conversions to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre14">Under earlier versions of the standard, classes that wanted to define a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> faced a problem: Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is an arithmetic type, a class-type object that is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> can be used in any context where an arithmetic type is expected. Such conversions can happen in surprising ways. In particular, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> had a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, the following code would compile:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>cin &lt;&lt; i; // <span><span class="calibre45"><span class="calibre16">this code would be legal if the conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">were not explicit!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program attempts to use the output operator on an input stream. There is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> defined for <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code>, so the code is almost surely in error. However, this code could use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> conversion operator to convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. The resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value would then be promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and used as the left-hand operand to the built-in version of the left-shift operator. The promoted <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value (either 1 or 0) would be shifted left 42 positions.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">explicit</span></span></tt></span></span></tt></code> Conversion Operators</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3728715"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">To prevent such problems, the new standard introduced <a id="filepos3728856" href="140-defined_terms.html#filepos3776999"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">explicit</span></span></tt></span></span></tt></code>
<strong class="calibre5">conversion operators</strong></a>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SmallInt {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the compiler won't automatically apply this conversion</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;explicit operator int() const { return val; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>), the compiler won&#8217;t (generally) use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> conversion operator for implicit conversions:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">SmallInt si = 3;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SmallInt</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor is not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span><br class="calibre6"/>si + 3; // <span><span class="calibre45"><span class="calibre16">error: implicit is conversion required, but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span><br class="calibre6"/>static_cast&lt;int&gt;(si) + 3; // <span><span class="calibre45"><span class="calibre16">ok: explicitly request the conversion</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the conversion operator is <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>, we can still do the conversion. However, with one exception, we must do so explicitly through a cast.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The exception is that the compiler will apply an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> conversion to an expression used as a condition. That is, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> conversion will be used implicitly to convert an expression used as</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The condition of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">if, while</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">do</span></tt></code> statement</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The condition expression in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> statement header</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; An operand to the logical <small class="calibre48">NOT</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">!</span></tt></code>), <small class="calibre48">OR</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code>), or <small class="calibre48">AND</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>) operators</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The condition expression in a conditional <code class="calibre23"><tt class="calibre23"><span class="calibre24">(?:</span></tt></code>) operator</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3733071"/>Conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bool</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In earlier versions of the library, the IO types defined a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code>. They did so to avoid the kinds of problems illustrated above. Under the new standard, the IO library instead defines an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Whenever we use a stream object in a condition, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator bool</span></tt></code> that is defined for the IO types. For example,</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">while (std::cin &gt;&gt; value)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The condition in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> executes the input operator, which reads into <code class="calibre23"><tt class="calibre23"><span class="calibre24">value</span></tt></code> and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code>. To evaluate the condition, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> is implicitly converted by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream operator bool</span></tt></code> conversion function. That function returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the condition state of <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">good</span></tt></code> (&#167; <a href="083-8.1._the_io_classes.html#filepos2085669">8.1.2</a>, p. <a href="083-8.1._the_io_classes.html#filepos2085669">312</a>), and <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> otherwise.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is usually intended for use in conditions. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator bool</span></tt></code> ordinarily should be defined as <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.9.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.45:</strong> Write conversion operators to convert a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. What values do you think these operators should return?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.46:</strong> Explain whether defining these <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> conversion operators is a good idea and whether they should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.47:</strong> Explain the difference between these two conversion operators:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct Integral {<br class="calibre6"/>&#160;&#160;&#160;&#160;operator const int();<br class="calibre6"/>&#160;&#160;&#160;&#160;operator int() const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.48:</strong> Determine whether the class you used in <a href="077-7.5._constructors_revisited.html#filepos1972067">exercise 7.40</a> from &#167; <a href="077-7.5._constructors_revisited.html#filepos1953073">7.5.1</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1953073">291</a>) should have a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. If so, explain why, and explain whether the operator should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>. If not, explain why not.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.49:</strong> Regardless of whether it is a good idea to do so, define a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> for the class from the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3738144" class="calibre37"><span class="calibre5">14.9.2. Avoiding Ambiguous Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">If a class has one or more conversions, it is important to ensure that there is only one way to convert from the class type to the target type. If there is more than one way to perform a conversion, it will be hard to write unambiguous code.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There are two ways that multiple conversion paths can occur. The first happens when two classes provide mutual conversions. For example, mutual conversions exist when a class <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> defines a converting constructor that takes an object of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> itself defines a conversion operator to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3739262"/>The second way to generate multiple conversion paths is to define multiple conversions from or to types that are themselves related by conversions. The most obvious instance is the built-in arithmetic types. A given class ordinarily ought to define at most one conversion to or from an arithmetic type.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily, it is a bad idea to define classes with mutual conversions or to define conversions to or from two arithmetic types.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Argument Matching and Mutual Conversions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In the following example, we&#8217;ve defined two ways to obtain an <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>: either by using <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>&#8217;s conversion operator or by using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">usually a bad idea to have mutual conversions between two class types</span></span></span><br class="calibre6"/>struct B;<br class="calibre6"/>struct A {<br class="calibre6"/>&#160;&#160;&#160;&#160;A() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;A(const B&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">converts a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};<br class="calibre6"/>struct B {<br class="calibre6"/>&#160;&#160;&#160;&#160;operator A() const; // <span><span class="calibre45"><span class="calibre16">also converts a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};<br class="calibre6"/>A f(const A&amp;);<br class="calibre6"/>B b;<br class="calibre6"/>A a = f(b); // <span><span class="calibre45"><span class="calibre16">error ambiguous:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(B::operator A())</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(A::A(const B&amp;)</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because there are two ways to obtain an <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>, the compiler doesn&#8217;t know which conversion to run; the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is ambiguous. This call can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>, or it can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> conversion operator that converts a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>. Because these two functions are equally good, the call is in error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we want to make this call, we have to explicitly call the conversion operator or the constructor:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">A a1 = f(b.operator A()); // <span><span class="calibre45"><span class="calibre16">ok: use <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>'s conversion operator</span></span></span><br class="calibre6"/>A a2 = f(A(b));&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: use <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span>'s constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Note that we can&#8217;t resolve the ambiguity by using a cast&#8212;the cast itself would have the same ambiguity.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Ambiguities and Multiple Conversions to Built-in Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ambiguities also occur when a class defines multiple conversions to (or from) types that are themselves related by conversions. The easiest case to illustrate&#8212;and one that is particularly problematic&#8212;is when a class defines constructors from or conversions to more than one arithmetic type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, the following class has converting constructors from two different arithmetic types, and conversion operators to two different arithmetic types:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3745401"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct A {<br class="calibre6"/>&#160;&#160;&#160;&#160;A(int = 0);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">usually a bad idea to have two</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;A(double);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">conversions from arithmetic types</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;operator int() const;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">usually a bad idea to have two</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;operator double() const; // <span><span class="calibre45"><span class="calibre16">conversions to arithmetic types</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;//&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/><br class="calibre6"/>};<br class="calibre6"/>void f2(long double);<br class="calibre6"/>A a;<br class="calibre6"/>f2(a); // <span><span class="calibre45"><span class="calibre16">error ambiguous:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(A::operator int())</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(A::operator double())</span></span></tt></span><br class="calibre6"/>long lg;<br class="calibre6"/>A a2(lg); // <span><span class="calibre45"><span class="calibre16">error ambiguous:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::A(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::A(double</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code>, neither conversion is an exact match to <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>. However, either conversion can be used, followed by a standard conversion to get to <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>. Hence, neither conversion is better than the other; the call is ambiguous.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We encounter the same problem when we try to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>. Neither constructor is an exact match for <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>. Each would require that the argument be converted before using the constructor:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Standard <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> conversion followed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">A(double)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Standard <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> conversion followed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">A(int)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">These conversion sequences are indistinguishable, so the call is ambiguous.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code>, and the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code>, are ambiguous because the standard conversions that were needed had the same rank (&#167; <a href="068-6.6._function_matching.html#filepos1689576">6.6.1</a>, p. <a href="068-6.6._function_matching.html#filepos1689576">245</a>). When a user-defined conversion is used, the rank of the standard conversion, if any, is used to select the best match:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">short s = 42;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">promoting</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">short</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is better than converting</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">short</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>A a3(s);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::A(int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, promoting a <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> is preferred to converting the <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. Hence <code class="calibre23"><tt class="calibre23"><span class="calibre24">a3</span></tt></code> is constructed using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">A::A(int)</span></tt></code> constructor, which is run on the (promoted) value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When two user-defined conversions are used, the rank of the standard conversion, if any, <em class="calibre16">preceding</em> or <em class="calibre16">following</em> the conversion function is used to select the best match.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloaded Functions and Converting Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Choosing among multiple conversions is further complicated when we call an overloaded function. If two or more conversions provide a viable match, then the conversions are considered equally good.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As one example, ambiguity problems can arise when overloaded functions take parameters that differ by class types that define the same converting constructors:</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos3752485"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Conversions and Operators</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Correctly designing the overloaded operators, conversion constructors, and conversion functions for a class requires some care. In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. A few rules of thumb can be helpful:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Don&#8217;t define mutually converting classes&#8212;if class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> has a constructor that takes an object of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code>, do not give <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> a conversion operator to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Avoid conversions to the built-in arithmetic types. In particular, if you do define a conversion to an arithmetic type, then</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; Do not define overloaded versions of the operators that take arithmetic types. If users need to use these operators, the conversion operation will convert objects of your type, and then the built-in operators can be used.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; Do not define a conversion to more than one arithmetic type. Let the standard conversions provide conversions to the other arithmetic types.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The easiest rule of all: With the exception of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, avoid defining conversion functions and limit non<code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructors to those that are &#8220;obviously right.&#8221;</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct C {<br class="calibre6"/>&#160;&#160;&#160;&#160;C(int);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};<br class="calibre6"/>struct D {<br class="calibre6"/>&#160;&#160;&#160;&#160;D(int);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};<br class="calibre6"/>void manip(const C&amp;);<br class="calibre6"/>void manip(const D&amp;);<br class="calibre6"/>manip(10); // <span><span class="calibre45"><span class="calibre16">error ambiguous:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">manip(C(10)</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">manip(D(10)</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here both <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> have constructors that take an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Either constructor can be used to match a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code>. Hence, the call is ambiguous: It could mean convert the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code> and call the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code>, or it could mean convert the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> and call the second version.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The caller can disambiguate by explicitly constructing the correct type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">manip(C(10)); // <span><span class="calibre45"><span class="calibre16">ok: calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">manip(const C&amp;</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Needing to use a constructor or a cast to convert an argument in a call to an overloaded function frequently is a sign of bad design.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloaded Functions and User-Defined Conversion</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In a call to an overloaded function, if two (or more) user-defined conversions provide a viable match, the conversions are considered equally good. The rank of <a id="filepos3758158"/>any standard conversions that might or might not be required is not considered. Whether a built-in conversion is also needed is considered only if the overload set can be matched <em class="calibre16">using the same conversion function.</em></p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, our call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> would be ambiguous even if one of the classes defined a constructor that required a standard conversion for the argument:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct E {<br class="calibre6"/>&#160;&#160;&#160;&#160;E(double);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};<br class="calibre6"/>void manip2(const C&amp;);<br class="calibre6"/>void manip2(const E&amp;);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error ambiguous: two different user-defined conversions could be used</span></span></span><br class="calibre6"/>manip2(10); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">manip2(C(10</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">manip2(E(double(10))</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code> has a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">E</span></tt></code> has a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. For the call <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip2(10)</span></tt></code>, both <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip2</span></tt></code> functions are viable:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip2(const C&amp;)</span></tt></code> is viable because <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code> has a converting constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. That constructor is an exact match for the argument.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip2(const E&amp;)</span></tt></code> is viable because <code class="calibre23"><tt class="calibre23"><span class="calibre24">E</span></tt></code> has a converting constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> and we can use a standard conversion to convert the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> argument in order to use that converting constructor.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Because calls to the overloaded functions require <em class="calibre16">different</em> user-defined conversions from one another, this call is ambiguous. In particular, even though one of the calls requires a standard conversion and the other is an exact match, the compiler will still flag this call as an error.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In a call to an overloaded function, the rank of an additional standard conversion (if any) matters only if the viable functions require the same user-defined conversion. If different user-defined conversions are needed, then the call is ambiguous.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3762101" class="calibre37"><span class="calibre5">14.9.3. Function Matching and Overloaded Operators</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Overloaded operators are overloaded functions. Normal function matching (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) is used to determine which operator&#8212;built-in or overloaded&#8212;to apply to a given expression. However, when an operator function is used in an expression, the set of candidate functions is broader than when we call a function using the call operator. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> has a class type, the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>
<em class="calibre16">sym</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> might be</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">a.operator<span><span class="calibre45"><span class="calibre16">sym</span></span></span> (b); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator</span></span></tt></span><span><span class="calibre45"><span class="calibre16">sym as a member function</span></span></span><br class="calibre6"/>operator<span><span class="calibre45"><span class="calibre16">sym</span></span></span>(a, b); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator</span></span></tt></span><span><span class="calibre45"><span class="calibre16">sym is an ordinary function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Unlike ordinary function calls, we cannot use the form of the call to distinquish whether we&#8217;re calling a nonmember or a member function.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos3764166"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.9.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.50:</strong> Show the possible class-type conversion sequences for the initializations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ex1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ex2</span></tt></code>. Explain whether the initializations are legal or not.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct LongDouble {<br class="calibre6"/>&#160;&#160;&#160;&#160;LongDouble(double = 0.0);<br class="calibre6"/>&#160;&#160;&#160;&#160;operator double();<br class="calibre6"/>&#160;&#160;&#160;&#160;operator float();<br class="calibre6"/>};<br class="calibre6"/>LongDouble ldObj;<br class="calibre6"/>int ex1 = ldObj;<br class="calibre6"/>float ex2 = ldObj;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.51:</strong> Show the conversion sequences (if any) needed to call each version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">calc</span></tt></code> and explain why the best viable function is selected.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void calc(int);<br class="calibre6"/>void calc(LongDouble);<br class="calibre6"/>double dval;<br class="calibre6"/>calc(dval); // <span><span class="calibre45"><span class="calibre16">which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">calc</span></span></tt></span><span><span class="calibre45"><span class="calibre16">?</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">When we use an overloaded operator with an operand of class type, the candidate functions include ordinary nonmember versions of that operator, as well as the built-in versions of the operator. Moreover, if the left-hand operand has class type, the overloaded versions of the operator, if any, defined by that class are also included.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we call a named function, member and nonmember functions with the same name do <em class="calibre16">not</em> overload one another. There is no overloading because the syntax we use to call a named function distinguishes between member and nonmember functions. When a call is through an object of a class type (or through a reference or pointer to such an object), then only the member functions of that class are considered. When we use an overloaded operator in an expression, there is nothing to indicate whether we&#8217;re using a member or nonmember function. Therefore, both member and nonmember versions must be considered.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The set of candidate functions for an operator used in an expression can contain both nonmember and member functions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll define an addition operator for our <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SmallInt {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend<br class="calibre6"/>&#160;&#160;&#160;&#160;SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;);<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;SmallInt(int = 0);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">conversion from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;operator int() const { return val; } // <span><span class="calibre45"><span class="calibre16">conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::size_t val;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3768980"/>We can use this class to add two <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code>s, but we will run into ambiguity problems if we attempt to perform mixed-mode arithmetic:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">SmallInt s1, s2;<br class="calibre6"/>SmallInt s3 = s1 + s2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses overloaded</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator+</span></span></tt></span><br class="calibre6"/>int i = s3 + 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: ambiguous</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first addition uses the overloaded version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> values. The second addition is ambiguous, because we can convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> and use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>, or convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">s3</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and use the built-in addition operator on <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Providing both conversion functions to an arithmetic type and overloaded operators for the same class type may lead to ambiguities between the overloaded operators and the built-in operators.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.9.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.52:</strong> Which <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator+</span></tt></code>, if any, is selected for each of the addition expressions? List the candidate functions, the viable functions, and the type conversions on the arguments for each viable function:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct LongDouble {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator+</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">for illustration purposes;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">+</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is usually a nonmember</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;LongDouble operator+(const SmallInt&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in &#167; 14.9.2 (p. 587)</span></span></span><br class="calibre6"/>};<br class="calibre6"/>LongDouble operator+(LongDouble&amp;, double);<br class="calibre6"/>SmallInt si;<br class="calibre6"/>LongDouble ld;<br class="calibre6"/>ld = si + ld;<br class="calibre6"/>ld = ld + si;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.53:</strong> Given the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">SmallInt</span></tt></code> on page <a href="138-14.9._overloading_conversions_and_operators.html#filepos3764166">588</a>, determine whether the following addition expression is legal. If so, what addition operator is used? If not, how might you change the code to make it legal?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">SmallInt s1;<br class="calibre6"/>double d = s1 + 3.14;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="137-14.8._functioncall_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="139-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
