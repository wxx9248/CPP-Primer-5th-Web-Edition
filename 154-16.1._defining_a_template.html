<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>16.1. Defining a Template</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="153-chapter_16._templates_and_generic_programming.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="155-16.2._template_argument_deduction.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4153781" class="calibre29"><span class="bold">16.1. Defining a Template</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Imagine that we want to write a function to compare two values and indicate whether the first is less than, equal to, or greater than the second. In practice, we&#8217;d want to define several such functions, each of which will compare values of a given type. Our first attempt might be to define several overloaded functions:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if the values are equal,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is smaller,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is smaller</span></span></span><br class="calibre6"/>int compare(const string &amp;v1, const string &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 &lt; v2) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v2 &lt; v1) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}<br class="calibre6"/>int compare(const double &amp;v1, const double &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 &lt; v2) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v2 &lt; v1) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These functions are nearly identical: The only difference between them is the type of their parameters. The function body is the same in each function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Having to repeat the body of the function for each type that we compare is tedious and error-prone. More importantly, we need to know when we write the program all the types that we might ever want to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>. This strategy cannot work if we want to be able to use the function on types that our users might supply.</p><div class="calibre22">&#160;</div>
<h4 id="filepos4156441" class="calibre37"><span class="calibre5">16.1.1. Function Templates</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Rather than defining a new function for each type, we can define a <strong class="calibre5"><a id="filepos4156704" href="160-defined_terms.html#filepos4551331">function template</a></strong>. A function template is a formula from which we can generate type-specific versions of that function. The template version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> looks like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>int compare(const T &amp;v1, const T &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 &lt; v2) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v2 &lt; v1) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4157570"/>A template definition starts with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">template</span></tt></code> followed by a <strong class="calibre5"><a id="filepos4157718" href="160-defined_terms.html#filepos4555813">template parameter list</a></strong>, which is a comma-separated list of one or more <strong class="calibre5"><a id="filepos4157851" href="160-defined_terms.html#filepos4555055">template parameters</a></strong> bracketed by the less-than (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>) and greater-than (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>) tokens.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In a template definition, the template parameter list cannot be empty.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The template parameter list acts much like a function parameter list. A function parameter list defines local variable(s) of a specified type but does not say how to initialize them. At run time, arguments are supplied that initialize the parameters.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Analogously, template parameters represent types or values used in the definition of a class or function. When we use a template, we specify&#8212;either implicitly or explicitly&#8212;<strong class="calibre5"><a id="filepos4159089" href="160-defined_terms.html#filepos4554336">template argument(s)</a></strong> to bind to the template parameter(s).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function declares one type parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. Inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>, we use the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> to refer to a type. Which <em class="calibre16">actual type</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> represents is determined at compile time based on how <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> is used.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Instantiating a Function Template</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template argument(s) for us. That is, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>, the compiler uses the type of the arguments to determine what type to bind to the template parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. For example, in this call</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; compare(1, 0) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the arguments have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The compiler will deduce <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> as the template argument and will bind that argument to the template parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The compiler uses the deduced template parameter(s) to <strong class="calibre5"><a id="filepos4161538" href="160-defined_terms.html#filepos4551960">instantiate</a></strong> a specific version of the function for us. When the compiler instantiates a template, it creates a new &#8220;instance&#8221; of the template using the actual template argument(s) in place of the corresponding template parameter(s). For example, given the calls</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int compare(const int&amp;, const int&amp;)</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt; vec1{1, 2, 3}, vec2{4, 5, 6};<br class="calibre6"/>cout &lt;&lt; compare(vec1, vec2) &lt;&lt; endl; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the compiler will instantiate two different versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>. For the first call, the compiler will write and compile a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int compare(const int &amp;v1, const int &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 &lt; v2) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v2 &lt; v1) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For the second call, it will generate a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>. These compiler-generated functions are generally referred to as an <strong class="calibre5"><a id="filepos4164596" href="160-defined_terms.html#filepos4552485">instantiation</a></strong> of the template.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4164739"/>Template Type Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function has one template <strong class="calibre5"><a id="filepos4164949" href="160-defined_terms.html#filepos4557027">type parameter</a></strong>. In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: same type used for the return type and parameter</span></span></span><br class="calibre6"/>template &lt;typename T&gt; T foo(T* p)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;T tmp = *p; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">tmp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will have the type to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return tmp;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each type parameter must be preceded by the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: must precede</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">U</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with either</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">typename</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">class</span></span></tt></span><br class="calibre6"/>template &lt;typename T, U&gt; T calc(const T&amp;, const U&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These keywords have the same meaning and can be used interchangeably inside a template parameter list. A template parameter list can use both keywords:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: no distinction between</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">typename</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">class</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in a template parameter list</span></span></span><br class="calibre6"/>template &lt;typename T, class U&gt; calc (const T&amp;, const U&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">It may seem more intuitive to use the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> to designate a template type parameter. After all, we can use built-in (nonclass) types as a template type argument. Moreover, <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> more clearly indicates that the name that follows is a type name. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> was added to C++ after templates were already in widespread use; some programmers continue to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> exclusively.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Nontype Template Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In addition to defining type parameters, we can define templates that take <strong class="calibre5"><a id="filepos4169325" href="160-defined_terms.html#filepos4552972">nontype parameters</a></strong>. A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> keyword.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When the template is instantiated, nontype parameters are replaced with a value supplied by the user or deduced by the compiler. These values must be constant expressions (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>), which allows the compiler to instantiate the templates during compile time.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, we can write a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> that will handle string literals. Such literals are arrays of <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code>. Because we cannot copy an array, we&#8217;ll define our parameters as references to an array (&#167; <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a>, p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>). Because we&#8217;d like to be able to compare literals of different lengths, we&#8217;ll give our template two nontype parameters. The first template parameter will represent the size of the first array, and the second parameter will represent the size of the second array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4170906"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template&lt;unsigned N, unsigned M&gt;<br class="calibre6"/>int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return strcmp(p1, p2);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we call this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">compare("hi", "mom")</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the compiler will use the size of the literals to instantiate a version of the template with the sizes substituted for <code class="calibre23"><tt class="calibre23"><span class="calibre24">N</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">M</span></tt></code>. Remembering that the compiler inserts a null terminator at the end of a string literal (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>), the compiler will instantiate</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A nontype parameter may be an integral type, or a pointer or (lvalue) reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression. Arguments bound to a pointer or reference nontype parameter must have static lifetime (<a href="113-chapter_12._dynamic_memory.html#filepos2900383">Chapter 12</a>, p. <a href="113-chapter_12._dynamic_memory.html#filepos2900383">450</a>). We may not use an ordinary (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>) local object or a dynamic object as a template argument for reference or pointer nontype template parameters. A pointer parameter can also be instantiated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> or a zero-valued constant expression.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required, for example, to specify the size of an array.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Template arguments used for nontype template parameters must be constant expressions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inline</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">constexpr</span></span></tt></span></span></tt></code> Function Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A function template can be declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> in the same ways as nontemplate functions. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> specifier follows the template parameter list and precedes the return type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">specifier follows the template parameter list</span></span></span><br class="calibre6"/>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: incorrect placement of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">specifier</span></span></span><br class="calibre6"/>inline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Writing Type-Independent Code</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Simple though it is, our initial <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function illustrates two important principles for writing generic code:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The function parameters in the template are references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The tests in the body use only <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> comparisons.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos4176665"/>By making the function parameters references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we ensure that our function can be used on types that cannot be copied. Most types&#8212;including the built-in types and, except for <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> and the IO types, all the library types we&#8217;ve used&#8212;do allow copying. However, there can be class types that do not allow copying. By making our parameters references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we ensure that such types can be used with our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function. Moreover, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> is called with large objects, then this design will also make the function run faster.</p><div class="calibre15">&#160;</div>
<p class="calibre25">You might think it would be more natural for the comparisons to be done using both the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code> operators:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">expected comparison</span></span></span><br class="calibre6"/>if (v1 &lt; v2) return -1;<br class="calibre6"/>if (v1 &gt; v2) return 1;<br class="calibre6"/>return 0;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, by writing the code using only the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator, we reduce the requirements on types that can be used with our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function. Those types must support <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, but they need not also support <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre14">In fact, if we were truly concerned about type independence and portability, we probably should have defined our function using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">less</span></tt></code> (&#167; <a href="137-14.8._functioncall_operator.html#filepos3679636">14.8.2</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3679636">575</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that will be correct even if used on pointers; see</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#167; 14.8.2 (p. 575)</span></span></tt></span><br class="calibre6"/>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (less&lt;T&gt;()(v1, v2)) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (less&lt;T&gt;()(v2, v1)) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem with our original version is that if a user calls it with two pointers and those pointers do not point to the same array, then our code is undefined.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Template programs should try to minimize the number of requirements placed on the argument types.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Compilation</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">When the compiler sees the definition of a template, it does not generate code. It generates code only when we instantiate a specific instance of the template. The fact that code is generated only when we use a template (and not when we define it) affects how we organize our source code and when errors are detected.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarly, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class definitions and function declarations in header files and definitions of ordinary and class-member functions in source files.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Templates are different: To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. As a result, unlike nontemplate code, headers for templates typically include definitions as well as declarations</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos4181999"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Definitions of function templates and member functions of class templates are ordinarily put into header files.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Templates and Headers</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Templates contain two kinds of names:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Those that do not depend on a template parameter</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Those that do depend on a template parameter</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is up to the provider of a template to ensure that all names that do not depend on a template parameter are visible when the template is used. Moreover, the template provider must ensure that the definition of the template, including the definitions of the members of a class template, are visible when the template is instantiated.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">It is up to <em class="calibre16">users</em> of a template to ensure that declarations for all functions, types, and operators associated with the types used to instantiate the template are visible.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Both of these requirements are easily satisfied by well-structured programs that make appropriate use of headers. Authors of templates should provide a header that contains the template definition along with declarations for all the names used in the class template or in the definitions of its members. Users of the template must include the header for the template and for any types used to instantiate that template.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Compilation Errors Are Mostly Reported during Instantiation</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that code is not generated until a template is instantiated affects when we learn about compilation errors in the code inside the template. In general, there are three stages during which the compiler might flag an error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The first stage is when we compile the template itself. The compiler generally can&#8217;t find many errors at this stage. The compiler can detect syntax errors&#8212;such as forgetting a semicolon or misspelling a variable name&#8212;but not much else.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The second error-detection time is when the compiler sees a use of the template. At this stage, there is still not much the compiler can check. For a call to a function template, the compiler typically will check that the number of the arguments is appropriate. It can also detect whether two arguments that are supposed to have the same type do so. For a class template, the compiler can check that the right number of template arguments are provided but not much more.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The third time when errors are detected is during instantiation. It is only then that type-related errors can be found. Depending on how the compiler manages instantiation, these errors may be reported at link time.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we write a template, the code may not be overtly type specific, but template code usually makes some assumptions about the types that will be used. For example, the code inside our original <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (v1 &lt; v2) return -1;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">requires &lt; on objects of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span><br class="calibre6"/>if (v2 &lt; v1) return 1;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">requires &lt; on objects of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span><br class="calibre6"/>return 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">not dependent on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4187356"/>assumes that the argument type has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. When the compiler processes the body of this template, it cannot verify whether the conditions in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> statements are legal. If the arguments passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operation, then the code is fine, but not otherwise. For example,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data data1, data2;<br class="calibre6"/>cout &lt;&lt; compare(data1, data2) &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">error: no</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call instantiates a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> conditions attempt to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects, but there is no such operator. This instantiation generates a version of the function that will not compile. However, errors such as this one cannot be detected until the compiler instantiates the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> on type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is up to the caller to guarantee that the arguments passed to the template support any operations that template uses, and that those operations behave correctly in the context in which the template uses them.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.1:</strong> Define instantiation.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.2:</strong> Write and test your own versions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> functions.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.3:</strong> Call your <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function on two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects to see how your compiler handles errors during instantiation.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.4:</strong> Write a template that acts like the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> algorithm. The function will need two template type parameters, one to represent the function&#8217;s iterator parameters and the other for the type of the value. Use your function to find a given value in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code> and in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;string&gt;</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.5:</strong> Write a template version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function from &#167; <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a> (p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>) that takes a reference to an array and can handle arrays of any size and any element type.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.6:</strong> How do you think the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> functions that take an array argument work? Define your own versions of these functions.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.7:</strong> Write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> template that returns the size of a given array.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.8:</strong> In the &#8220;Key Concept&#8221; box on page <a href="033-3.4._introducing_iterators.html#filepos815330">108</a>, we noted that as a matter of habit C++ programmers prefer using <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> to using <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>. Explain the rationale for this habit.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4193169" class="calibre37"><span class="calibre5">16.1.2. Class Templates</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos4193364" href="160-defined_terms.html#filepos4549024">class template</a></strong> is a blueprint for generating classes. Class templates differ from function templates in that the compiler cannot deduce the template parameter type(s) for a class template. Instead, as we&#8217;ve seen many times, to use a class template we must supply additional information inside angle brackets following <a id="filepos4193741"/>the template&#8217;s name (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">97</a>). That extra information is the list of template arguments to use in place of the template parameters.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Class Template</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll implement a template version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>). We&#8217;ll name our template <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> to indicate that it is no longer specific to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>, our template will provide shared (and checked) access to the elements it holds. Unlike that class, our template can be used on elements of pretty much any type. As with the library containers, our users will have to specify the element type when they use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like function templates, class templates begin with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">template</span></tt></code> followed by a template parameter list. In the definition of the class template (and its members), we use the template parameters as stand-ins for types or values that will be supplied when the template is used:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; class Blob {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef T value_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef typename std::vector&lt;T&gt;::size_type size_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">constructors</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Blob();<br class="calibre6"/>&#160;&#160;&#160;&#160;Blob(std::initializer_list&lt;T&gt; il);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">number of elements in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;size_type size() const { return data-&gt;size(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;bool empty() const { return data-&gt;empty(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">add and remove elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(const T &amp;t) {data-&gt;push_back(t);}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move version; see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 13.6.3 (p. 548)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(T &amp;&amp;t) { data-&gt;push_back(std::move(t)); }<br class="calibre6"/>&#160;&#160;&#160;&#160;void pop_back();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">element access</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;T&amp; back();<br class="calibre6"/>&#160;&#160;&#160;&#160;T&amp; operator[](size_type i); // <span><span class="calibre45"><span class="calibre16">defined in</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 14.5 (p. 566)</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">throws</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">msg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">data[i]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">isn't valid</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void check(size_type i, const std::string &amp;msg) const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> template has one template type parameter, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. We use the type parameter anywhere we refer to the element type that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> holds. For example, we define the return type of the operations that provide access to the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;</span></tt></code>. When a user instantiates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>, these uses of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> will be replaced by the specified template argument type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">With the exception of the template parameter list, and the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> instead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, this class is the same as the version we defined in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>) and updated in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">12.1.6</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">475</a>) and in <a href="120-chapter_13._copy_control.html#filepos3197881">Chapters 13</a> and <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">14</a>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4199389"/>Instantiating a Class Template</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen many times, when we use a class template, we must supply extra information. We can now see that that extra information is a list of <strong class="calibre5">explicit template arguments</strong> that are bound to the template&#8217;s parameters. The compiler uses these template arguments to instantiate a specific class from the template.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, to define a type from our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> template, we must provide the element type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt; ia;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span><br class="calibre6"/>Blob&lt;int&gt; ia2 = {0,1,2,3,4}; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with five elements</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia2</span></tt></code> use the same type-specific version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;</span></tt></code>). From these definitions, the compiler will instantiate a class that is equivalent to</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;&gt; class Blob&lt;int&gt; {<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef typename std::vector&lt;int&gt;::size_type size_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;Blob();<br class="calibre6"/>&#160;&#160;&#160;&#160;Blob(std::initializer_list&lt;int&gt; il);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int&amp; operator[](size_type i);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;std::vector&lt;int&gt;&gt; data;<br class="calibre6"/>&#160;&#160;&#160;&#160;void check(size_type i, const std::string &amp;msg) const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler instantiates a class from our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> template, it rewrites the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> template, replacing each instance of the template parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> by the given template argument, which in this case is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The compiler generates a different class for each element type we specify:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">these definitions instantiate two distinct</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">types</span></span></span><br class="calibre6"/>Blob&lt;string&gt; names; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>Blob&lt;double&gt; prices;// <span><span class="calibre45"><span class="calibre16">different element type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These definitions would trigger instantiations of two distinct classes: The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">names</span></tt></code> creates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> class in which each occurrence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">prices</span></tt></code> generates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Each instantiation of a class template constitutes an independent class. The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt;</span></tt></code> has no relationship to, or any special access to, the members of any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">References to a Template Type in the Scope of the Template</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">In order to read template class code, it can be helpful to remember that the name of a class template is not the name of a type (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">97</a>). A class template is used to instantiate a type, and an instantiated type always includes template argument(s).</p><div class="calibre15">&#160;</div>
<p class="calibre25">What can be confusing is that code in a class template generally doesn&#8217;t use the name of an actual type (or value) as a template argument. Instead, we often use the template&#8217;s own parameter(s) as the template argument(s). For example, our <a id="filepos4206136"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member uses two templates, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Whenever we use a template, we must supply template arguments. In this case, the template argument we supply is the same type that is used to instantiate the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>. Therefore, the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code></p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>&#8217;s type parameter to say that <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> is the instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> that points to the instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. When we instantiate a particular kind of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt;</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> will be</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;vector&lt;string&gt;&gt;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;vector&lt;int&gt;&gt;</span></tt></code>, and so on.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Member Functions of Class Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As with any class, we can define the member functions of a class template either inside or outside of the class body. As with any other class, members defined inside the class body are implicitly inline.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A class template member function is itself an ordinary function. However, each instantiation of the class template has its own version of each member. As a result, a member function of a class template has the same template parameters as the class itself. Therefore, a member function defined outside the class template body starts with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">template</span></tt></code> followed by the class&#8217; template parameter list.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As usual, when we define a member outside its class, we must say to which class the member belongs. Also as usual, the name of a class generated from a template includes its template arguments. When we define a member, the template argument(s) are the same as the template parameter(s). That is, for a given member function of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> that was defined as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret-type</span></span></tt></span> StrBlob::<span><span class="calibre45"><span class="calibre16">member-name(parm-list</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> member will look like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret-type</span></span></tt></span> Blob&lt;T&gt;::<span><span class="calibre45"><span class="calibre16">member-name(parm-list</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">check</span></span></tt></span></span></tt></code> and Element Access Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;ll start by defining the <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> member, which verifies a given index:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>void Blob&lt;T&gt;::check(size_type i, const std::string &amp;msg) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (i &gt;= data-&gt;size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw std::out_of_range(msg);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Aside from the differences in the class name and the use of the template parameter list, this function is identical to the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The subscript operator and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> function use the template parameter to specify the return type but are otherwise unchanged:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4212631"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>T&amp; Blob&lt;T&gt;::back()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;check(0, "back on empty Blob");<br class="calibre6"/>&#160;&#160;&#160;&#160;return data-&gt;back();<br class="calibre6"/>}<br class="calibre6"/>template &lt;typename T&gt;<br class="calibre6"/>T&amp; Blob&lt;T&gt;::operator[](size_type i)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is too big,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will throw, preventing access to a nonexistent element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;check(i, "subscript out of range");<br class="calibre6"/>&#160;&#160;&#160;&#160;return (*data)[i];<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In our original <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class these operators returned <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>. The template versions will return a reference to whatever type is used to instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code> function is nearly identical to our original <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void Blob&lt;T&gt;::pop_back()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;check(0, "pop_back on empty Blob");<br class="calibre6"/>&#160;&#160;&#160;&#160;data-&gt;pop_back();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The subscript operator and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> members are overloaded on <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. We leave the definition of these members, and of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> members, as an exercise.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Blob</span></span></tt></span></span></tt></code> Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As with any other member defined outside a class template, a constructor starts by declaring the template parameters for the class template of which it is a member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>Blob&lt;T&gt;::Blob(): data(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we are defining the member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> in the scope of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;T&gt;</span></tt></code>. Like our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> default constructor (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>), this constructor allocates an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and stores the pointer to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code>. As we&#8217;ve seen, we use the class&#8217; own type parameter as the template argument of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> we allocate.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Similarly, the constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> uses its type parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> as the element type for its <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> parameter:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like the default constructor, this constructor allocates a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. In this case, we initialize that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> from the parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">il</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To use this constructor, we must pass an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> in which the elements are compatible with the element type of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt; articles = {"a", "an", "the"};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The parameter in this constructor has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;string&gt;</span></tt></code>. Each string literal in the list is implicitly converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4219319"/>Instantiation of Class-Template Member Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, a member function of a class template is instantiated <em class="calibre16">only</em> if the program uses that member function. For example, this code</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">initializer_list&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor</span></span></span><br class="calibre6"/>Blob&lt;int&gt; squares = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;::size() const</span></span></tt></span><br class="calibre6"/>for (size_t i = 0; i != squares.size(); ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;squares[i] = i*i; // <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;::operator[](size_t</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">instantiates the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;</span></tt></code> class and three of its member functions: <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator[]</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>, and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;int&gt;</span></tt></code> constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If a member function isn&#8217;t used, it is not instantiated. The fact that members are instantiated only if we use them lets us instantiate a class with a type that may not meet the requirements for some of the template&#8217;s operations (&#167; <a href="090-9.2._container_library_overview.html#filepos2188055">9.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2188055">329</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">By default, a member of an instantiated class template is instantiated only if the member is used.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Simplifying Use of a Template Class Name inside Class Code</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">There is one exception to the rule that we must supply template arguments when we use a class template type. Inside the scope of the class template itself, we may use the name of the template without arguments:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">BlobPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">throws an exception on attempts to access a nonexistent element</span></span></span><br class="calibre6"/>template &lt;typename T&gt; class BlobPtr<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;BlobPtr(): curr(0) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;BlobPtr(Blob&lt;T&gt; &amp;a, size_t sz = 0):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wptr(a.data), curr(sz) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;T&amp; operator*() const<br class="calibre6"/>&#160;&#160;&#160;&#160;{ auto p = check(curr, "dereference past end");<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;return (*p)[curr];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">(*p)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which this object points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">increment and decrement</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;BlobPtr&amp; operator++();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prefix operators</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;BlobPtr&amp; operator--();<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if the check succeeds</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;std::vector&lt;T&gt;&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;check(std::size_t, const std::string&amp;) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">store a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">weak_ptr</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">which means the underlying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">might be destroyed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::size_t curr;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">current position within the array</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Careful readers will have noted that the prefix increment and decrement members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> return <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr&amp;</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr&lt;T&gt;&amp;</span></tt></code>. When we are inside the scope of a class template, the compiler treats references to the template itself as if we had <a id="filepos4226009"/>supplied template arguments matching the template&#8217;s own parameters. That is, it is as if we had written:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">BlobPtr&lt;T&gt;&amp; operator++();<br class="calibre6"/>BlobPtr&lt;T&gt;&amp; operator--();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Class Template Name outside the Class Template Body</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen (&#167; <a href="076-7.4._class_scope.html#filepos1923787">7.4</a>, p. <a href="076-7.4._class_scope.html#filepos1923787">282</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">postfix: increment/decrement the object but return the unchanged value</span></span></span><br class="calibre6"/>template &lt;typename T&gt;<br class="calibre6"/>BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator++(int)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no check needed here; the call to prefix increment will do the check</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;BlobPtr ret = *this;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">save the current value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++*this;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance one element; prefix</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">++</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">checks the increment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return the saved state</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the return type appears outside the scope of the class, we must specify that the return type returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> instantiated with the same type as the class. Inside the function body, we are in the scope of the class so do not need to repeat the template argument when we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code>. When we do not supply template arguments, the compiler assumes that we are using the same type as the member&#8217;s instantiation. Hence, the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code> is as if we had written:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">BlobPtr&lt;T&gt; ret = *this;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Inside the scope of a class template, we may refer to the template without specifying template argument(s).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Class Templates and Friends</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a class contains a friend declaration (&#167; <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">269</a>), the class and the friend can independently be templates or not. A class template that has a nontemplate friend grants that friend access to all the instantiations of the template. When the friend is itself a template, the class granting friendship controls whether friendship includes all instantiations of the template or only specific instantiation(s).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">One-to-One Friendship</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The most common form of friendship from a class template to another template (class or function) establishes friendship between corresponding instantiations of the class and its friend. For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> class should declare the <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> class and a template version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> equality operator (originally defined for <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> in the exercises in &#167; <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">14.3.1</a> (p. <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">562</a>)) as friends.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In order to refer to a specific instantiation of a template (class or function) we must first declare the template itself. A template declaration includes the template&#8217;s template parameter list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4231180"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">forward declarations needed for friend declarations in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span><br class="calibre6"/>template &lt;typename&gt; class BlobPtr;<br class="calibre6"/>template &lt;typename&gt; class Blob; // <span><span class="calibre45"><span class="calibre16">needed for parameters in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator==</span></span></tt></span><br class="calibre6"/>template &lt;typename T&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);<br class="calibre6"/>template &lt;typename T&gt; class Blob {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">each instantiation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">grants access to the version of</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">BlobPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and the equality operator instantiated with the same type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend class BlobPtr&lt;T&gt;;<br class="calibre6"/>&#160;&#160;&#160;&#160;friend bool operator==&lt;T&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 12.1.1 (p. 456)</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by declaring that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator==</span></tt></code> are templates. These declarations are needed for the parameter declaration in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator==</span></tt></code> function and the friend declarations in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The friend declarations use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>&#8217;s template parameter as their own template argument. Thus, the friendship is restricted to those instantiations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> and the equality operator that are instantiated with the same type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Blob&lt;char&gt; ca; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">BlobPtr&lt;char&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator==&lt;char&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are friends</span></span></span><br class="calibre6"/>Blob&lt;int&gt; ia;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">BlobPtr&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator==&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are friends</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr&lt;char&gt;</span></tt></code> may access the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> parts of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca</span></tt></code> (or any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;char&gt;</span></tt></code> object), but <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca</span></tt></code> has no special access to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> (or any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;)</span></tt></code> or to any other instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">General and Specific Template Friendship</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A class can also make every instantiation of another template its friend, or it may limit friendship to a specific instantiation:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">forward declaration necessary to befriend a specific instantiation of a template</span></span></span><br class="calibre6"/>template &lt;typename T&gt; class Pal;<br class="calibre6"/>class C {&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an ordinary, nontemplate class</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Pal&lt;C&gt;;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">instantiated with class</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a friend to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">all instances of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are friends to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C</span></span></tt></span>;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no forward declaration required when we befriend all instantiations</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;typename T&gt; friend class Pal2;<br class="calibre6"/>};<br class="calibre6"/>template &lt;typename T&gt; class C2 { // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is itself a class template</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">each instantiation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has the same instance of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a friend</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Pal&lt;T&gt;;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a template declaration for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must be in scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">all instances of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are friends of each instance of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C2,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">prior declaration needed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;typename X&gt; friend class Pal2;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a nontemplate class that is a friend of every instance of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C2</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Pal3;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prior declaration for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Pal3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not needed</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To allow all instantiations as friends, the friend declaration must use template parameter(s) that differ from those used by the class itself.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4240095"/>Befriending the Template&#8217;s Own Type Parameter</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos4240204"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can make a template type parameter a friend:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename Type&gt; class Bar {<br class="calibre6"/>friend Type; // <span><span class="calibre45"><span class="calibre16">grants access to the type used to instantiate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bar</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;//&#160;&#160;...<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we say that whatever type is used to instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> is a friend. Thus, for some type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo, Foo</span></tt></code> would be a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar&lt;Foo&gt;, Sales_data</span></tt></code> a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar&lt;Sales_data&gt;</span></tt></code>, and so on.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that even though a friend ordinarily must be a class or a function, it is okay for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> to be instantiated with a built-in type. Such friendship is allowed so that we can instantiate classes such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> with built-in types.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Type Aliases</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">An instantiation of a class template defines a class type, and as with any other class type, we can define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) that refers to that instantiated class:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef Blob&lt;string&gt; StrBlob;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> will let us run the code we wrote in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>) using our template version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> instantiated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Because a template is not a type, we cannot define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> that refers to a template. That is, there is no way to define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> that refers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;T&gt;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4243350"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">However, the new standard lets us define a type alias for a class template:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;<br class="calibre6"/>twin&lt;string&gt; authors; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">authors</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;string, string&gt;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">twin</span></tt></code> as a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>s in which the members have the same type. Users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">twin</span></tt></code> need to specify that type only once.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A template type alias is a synonym for a family of classes:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">twin&lt;int&gt; win_loss;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">win_loss</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;int, int&gt;</span></span></tt></span><br class="calibre6"/>twin&lt;double&gt; area;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">area</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;double, double&gt;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Just as we do when we use a class template, when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">twin</span></tt></code>, we specify which particular kind of <code class="calibre23"><tt class="calibre23"><span class="calibre24">twin</span></tt></code> we want.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we define a template type alias, we can fix one or more of the template parameters:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; using partNo = pair&lt;T, unsigned&gt;;<br class="calibre6"/>partNo&lt;string&gt; books;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">books</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;string, unsigned&gt;</span></span></tt></span><br class="calibre6"/>partNo&lt;Vehicle&gt; cars;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cars</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;Vehicle, unsigned&gt;</span></span></tt></span><br class="calibre6"/>partNo&lt;Student&gt; kids;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">kids</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;Student, unsigned&gt;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">partNo</span></tt></code> as a synonym for the family of types that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>s in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> member is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>. Users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">partNo</span></tt></code> specify a type for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> but have no choice about <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4248140"/><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Members of Class Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like any other class, a class template can declare <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members (&#167; <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">300</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;static std::size_t count() { return ctr; }<br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other interface members</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;static std::size_t ctr;<br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other implementation members</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> is a class template that has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public static</span></tt></code> member function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private static</span></tt></code> data member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code>. Each instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> has its own instance of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members. That is, for any given type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code>, there is one <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;X&gt;::ctr</span></tt></code> and one <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;X&gt;::count</span></tt></code> member. All objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;X&gt;</span></tt></code> share the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code> object and <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> function. For example,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;string&gt;::ctr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;string&gt;::count</span></span></tt></span><br class="calibre6"/>Foo&lt;string&gt; fs;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">all three objects share the same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::ctr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::count</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members</span></span></span><br class="calibre6"/>Foo&lt;int&gt; fi, fi2, fi3;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">As with any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member, there must be exactly one definition of each <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member of a template class. However, there is a distinct object for each instantiation of a class template. As a result, we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member as a template similarly to how we define the member functions of that template:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>size_t Foo&lt;T&gt;::ctr = 0; // <span><span class="calibre45"><span class="calibre16">define and initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ctr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with any other member of a class template, we start by defining the template parameter list, followed by the type of the member we are defining and the member&#8217;s name. As usual, a member&#8217;s name includes the member&#8217;s class name, which for a class generated from a template includes its template arguments. Thus, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> is instantiated for a particular template argument type, a separate <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctr</span></tt></code> will be instantiated for that class type and initialized to <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with static members of nontemplate classes, we can access a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member of a class template through an object of the class type or by using the scope operator to access the member directly. Of course, to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member through the class, we must refer to a specific instantiation:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Foo&lt;int&gt; fi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">and the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">data member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ctr</span></span></tt></span><br class="calibre6"/>auto ct = Foo&lt;int&gt;::count(); // <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::count</span></span></tt></span><br class="calibre6"/>ct = fi.count();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::count</span></span></tt></span><br class="calibre6"/>ct = Foo::count();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: which template instantiation?</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like any other member function, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member function is instantiated only if it is used in a program.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4256148"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.9:</strong> What is a function template? What is a class template?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.10:</strong> What happens when a class template is instantiated?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.11:</strong> The following definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">List</span></tt></code> is incorrect. How would you fix it?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename elemType&gt; class ListItem;<br class="calibre6"/>template &lt;typename elemType&gt; class List {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;List&lt;elemType&gt;();<br class="calibre6"/>&#160;&#160;&#160;&#160;List&lt;elemType&gt;(const List&lt;elemType&gt; &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;List&lt;elemType&gt;&amp; operator=(const List&lt;elemType&gt; &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;~List();<br class="calibre6"/>&#160;&#160;&#160;&#160;void insert(ListItem *ptr, elemType value);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;ListItem *front, *end;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.12:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> templates. including the various <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> members that were not shown in the text.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.13:</strong> Explain which kind of friendship you chose for the equality and relational operators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.14:</strong> Write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class template that uses nontype parameters to define the height and width of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.15:</strong> Implement input and output operators for your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> template. Which, if any, friends are necessary in class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> to make the input and output operators work? Explain why each friend declaration, if any, was needed.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.16:</strong> Rewrite the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>) as a template named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Vec</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4259709" class="calibre37"><span class="calibre5">16.1.3. Template Parameters</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Like the names of function parameters, a template parameter name has no intrinsic meaning. We ordinarily name type parameters <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>, but we can use any name:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename Foo&gt; Foo calc(const Foo&amp; a, const Foo&amp; b)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo tmp = a; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">tmp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has the same type as the parameters and return type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return tmp;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return type and parameters have the same type</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Parameters and Scope</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Template parameters follow normal scoping rules. The name of a template parameter can be used after it has been declared and until the end of the template declaration or definition. As with any other name, a template parameter hides any <a id="filepos4261375"/>declaration of that name in an outer scope. Unlike most other contexts, however, a name used as a template parameter may not be reused within the template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef double A;<br class="calibre6"/>template &lt;typename A, typename B&gt; void f(A a, B b)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;A tmp = a; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">tmp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has same type as the template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double B;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: redeclares template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Normal name hiding says that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> is hidden by the type parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">tmp</span></tt></code> is not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>; it has whatever type gets bound to the template parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> when <code class="calibre23"><tt class="calibre23"><span class="calibre24">calc</span></tt></code> is used. Because we cannot reuse names of template parameters, the declaration of the variable named <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> is an error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because a parameter name cannot be reused, the name of a template parameter can appear only once with in a given template parameter list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: illegal reuse of template parameter name</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">V</span></span></tt></span><br class="calibre6"/>template &lt;typename V, typename V&gt; // ...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Declarations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A template declaration must include the template parameters :</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">declares but does not define</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span><br class="calibre6"/>template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);<br class="calibre6"/>template &lt;typename T&gt; class Blob;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with function parameters, the names of a template parameter need not be the same across the declaration(s) and the definition of the same template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">all three uses of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">calc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refer to the same function template</span></span></span><br class="calibre6"/>template &lt;typename T&gt; T calc(const T&amp;, const T&amp;); // <span><span class="calibre45"><span class="calibre16">declaration</span></span></span><br class="calibre6"/>template &lt;typename U&gt; U calc(const U&amp;, const U&amp;); // <span><span class="calibre45"><span class="calibre16">declaration</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">definition of the template</span></span></span><br class="calibre6"/>template &lt;typename Type&gt;<br class="calibre6"/>Type calc(const Type&amp; a, const Type&amp; b) { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span> */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Of course, every declaration and the definition of a given template must have the same number and kind (i.e., type or nontype) of parameters.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">For reasons we&#8217;ll explain in &#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">698</a>), declarations for all the templates needed by a given file usually should appear together at the beginning of a file before any code that uses those names.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Class Members That Are Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Recall that we use the scope operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">::</span></tt></code>) to access both <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members and type members (&#167; <a href="076-7.4._class_scope.html#filepos1923787">7.4</a>, p. <a href="076-7.4._class_scope.html#filepos1923787">282</a>, and &#167; <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">301</a>). In ordinary (nontemplate) code, the compiler has access to the class defintion. As a result, it knows whether a name accessed through the scope operator is a type or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member. For example, <a id="filepos4268006"/>when we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">string::size_type</span></tt></code>, the compiler has the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and can see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> is a type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is a template type parameter, When the compiler sees code such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">T::mem</span></tt></code> it won&#8217;t know until instantiation time whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is a type or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member. However, in order to process the template, the compiler must know whether a name represents a type. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is the name of a type parameter, when the compiler sees a statement of the following form:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">T::size_type * p;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">it needs to know whether we&#8217;re defining a variable named <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> or are multiplying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> by a variable named <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">By default, the language assumes that a name accessed through the scope operator is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type. We do so by using the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>typename T::value_type top(const T&amp; c)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (!c.empty())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return c.back();<br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return typename T::value_type();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">top</span></tt></code> function expects a container as its argument and uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> to specify its return type and to generate a value initialized element (&#167; <a href="077-7.5._constructors_revisited.html#filepos1979405">7.5.3</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1979405">293</a>) to return if <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> has no elements.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we want to inform the compiler that a name represents a type, we must use the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Default Template Arguments</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as we can supply default arguments to function parameters (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>), we can also supply <strong class="calibre5"><a id="filepos4272100" href="160-defined_terms.html#filepos4549642">default template arguments</a></strong>. Under the new standard, we can supply default arguments for both function and class templates. Earlier versions of the language, allowed default arguments only with class templates.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4272407"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">As an example, we&#8217;ll rewrite <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> to use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">less</span></tt></code> function-object template (&#167; <a href="137-14.8._functioncall_operator.html#filepos3679636">14.8.2</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3679636">574</a>) by default:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has a default template argument,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">less&lt;T&gt;</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">and a default function argument,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">F()</span></span></tt></span><br class="calibre6"/>template &lt;typename T, typename F = less&lt;T&gt;&gt;<br class="calibre6"/>int compare(const T &amp;v1, const T &amp;v2, F f = F())<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (f(v1, v2)) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (f(v2, v1)) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4273865"/>Here we&#8217;ve given our template a second type parameter, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">F</span></tt></code>, that represents the type of a callable object (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) and defined a new function parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, that will be bound to a callable object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We&#8217;ve also provided defaults for this template parameter and its corresponding function parameter. The default template argument specifies that <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> will use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">less</span></tt></code> function-object class, instantiated with the same type parameter as <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>. The default function argument says that <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> will be a default-initialized object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">F</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When users call this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>, they may supply their own comparison operation but are not required to do so:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool i = compare(0, 42); // <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">less</span></span></tt></span>; <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-1</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">result depends on the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">isbn</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item2</span></span></tt></span><br class="calibre6"/>Sales_data item1(cin), item2(cin);<br class="calibre6"/>bool j = compare(item1, item2, compareIsbn);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first call uses the default function argument, which is a default-initialized object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">less&lt;T&gt;</span></tt></code>. In this call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> so that object has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">less&lt;int&gt;</span></tt></code>. This instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> will use <code class="calibre23"><tt class="calibre23"><span class="calibre24">less&lt;int&gt;</span></tt></code> to do its comparisons.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the second call, we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">compareIsbn</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>) and two objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> is called with three arguments, the type of the third argument must be a callable object that returns a type that is convertible to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> and takes arguments of a type compatible with the types of the first two arguments. As usual, the types of the template parameters are deduced from their corresponding function arguments. In this call, the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is deduced as <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">F</span></tt></code> is deduced as the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compareIsbn</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As with function default arguments, a template parameter may have a default argument only if all of the parameters to its right also have default arguments.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Default Arguments and Class Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Whenever we use a class template, we must always follow the template&#8217;s name with brackets. The brackets indicate that a class must be instantiated from a template. In particular, if a class template provides default arguments for all of its template parameters, and we want to use those defaults, we must put an empty bracket pair following the template&#8217;s name:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;class T = int&gt; class Numbers {&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">by default</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Numbers(T v = 0): val(v) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">various operations on numbers</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;T val;<br class="calibre6"/>};<br class="calibre6"/>Numbers&lt;long double&gt; lots_of_precision;<br class="calibre6"/>Numbers&lt;&gt; average_precision; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">says we want the default type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we instantiate two versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Numbers</span></tt></code>: <code class="calibre23"><tt class="calibre23"><span class="calibre24">average_precision</span></tt></code> instantiates <code class="calibre23"><tt class="calibre23"><span class="calibre24">Numbers</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">lots_of_precision</span></tt></code> instantiates <code class="calibre23"><tt class="calibre23"><span class="calibre24">Numbers</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4281155"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.17:</strong> What, if any, are the differences between a type parameter that is declared as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> and one that is declared as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code>? When must <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> be used?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.18:</strong> Explain each of the following function template declarations and identify whether any are illegal. Correct each error that you find.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><span class="calibre50">(a)</span></span> template &lt;typename T, U, typename V&gt; void f1(T, U, V);<br class="calibre6"/><span><span class="calibre50">(b)</span></span> template &lt;typename T&gt; T f2(int &amp;T);<br class="calibre6"/><span><span class="calibre50">(c)</span></span> inline template &lt;typename T&gt; T foo(T, unsigned int*);<br class="calibre6"/><span><span class="calibre50">(d)</span></span> template &lt;typename T&gt; f4(T, T);<br class="calibre6"/><span><span class="calibre50">(e)</span></span> typedef char Ctype;<br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;typename Ctype&gt; Ctype f5(Ctype a);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.19:</strong> Write a function that takes a reference to a container and prints the elements in that container. Use the container&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> members to control the loop that prints the elements.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.20:</strong> Rewrite the function from the previous exercise to use iterators returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> to control the loop.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4283763" class="calibre37"><span class="calibre5">16.1.4. Member Templates</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A class&#8212;either an ordinary class or a class template&#8212;may have a member function that is itself a template. Such members are referred to as <strong class="calibre5"><a id="filepos4284048" href="160-defined_terms.html#filepos4552721">member templates</a></strong>. Member templates may not be virtual.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Member Templates of Ordianary (Nontemplate) Classes</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example of an ordinary class that has a member template, we&#8217;ll define a class that is similar to the default deleter type used by <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>). Like the default deleter, our class will have an overloaded function-call operator (&#167; <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>) that will take a pointer and execute <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on the given pointer. Unlike the default deleter, our class will also print a message whenever the deleter is executed. Because we want to use our deleter with any type, we&#8217;ll make the call operator a template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">function-object class that calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on a given pointer</span></span></span><br class="calibre6"/>class DebugDelete {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;DebugDelete(std::ostream &amp;s = std::cerr): os(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">as with any function template, the type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is deduced by the compiler</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;typename T&gt; void operator()(T *p) const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;{ os &lt;&lt; "deleting unique_ptr" &lt;&lt; std::endl; delete p; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::ostream &amp;os;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4286402"/>Like any other template, a member template starts with its own template parameter list. Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> object has an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> member on which to write, and a member function that is itself a template. We can use this class as a replacement for <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double* p = new double;<br class="calibre6"/>DebugDelete d;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">an object that can act like a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">expression</span></span></span><br class="calibre6"/>d(p); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">DebugDelete::operator()(double*),</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>int* ip = new int;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">operator()(int*)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on a temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">DebugDelete</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>DebugDelete()(ip);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Because calling a <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> object <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>s its given pointer, we can also use <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> as the deleter of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. To override the deleter of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>, we supply the type of the deleter inside brackets and supply an object of the deleter type to the constructor (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">destroying the the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">DebugDelete::operator()&lt;int&gt;(int *)</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">destroying the the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">DebugDelete::operator()&lt;string&gt;(string*)</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we&#8217;ve said that <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>&#8217;s deleter will have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code>, and we have supplied an unnamed object of that type in <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>&#8217;s constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> destructor calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code>&#8217;s call operator. Thus, whenever <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>&#8217;s destructor is instantiated, <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code>&#8217;s call operator will also be instantiated: Thus, the definitions above will instantiate:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">sample instantiations for member templates of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">DebugDelete</span></span></tt></span><br class="calibre6"/>void DebugDelete::operator()(int *p) const { delete p; }<br class="calibre6"/>void DebugDelete::operator()(string *p) const { delete p; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Member Templates of Class Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can also define a member template of a class template. In this case, both the class and the member have their own, independent, template parameters.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll give our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> class a constructor that will take two iterators denoting a range of elements to copy. Because we&#8217;d like to support iterators into varying kinds of sequences, we&#8217;ll make this constructor a template:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; class Blob {<br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;typename It&gt; Blob(It b, It e);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This constructor has its own template type parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">It</span></tt></code>, which it uses for the type of its two function parameters.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike ordinary function members of class templates, member templates <em class="calibre16">are</em> function templates. When we define a member template outside the body of a <a id="filepos4293617"/>class template, we must provide the template parameter list for the class template and for the function template. The parameter list for the class template comes first, followed by the member&#8217;s own template parameter list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">type parameter for the class</span></span></span><br class="calibre6"/>template &lt;typename It&gt;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">type parameter for the constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Blob&lt;T&gt;::Blob(It b, It e):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we are defining a member of a class template that has one template type parameter, which we have named <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. The member itself is a function template that has a type parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">It</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Instantiation and Member Templates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To instantiate a member template of a class template, we must supply arguments for the template parameters for both the class and the function templates. As usual, argument(s) for the class template parameter(s) are determined by the type of the object through which we call the member template. Also as usual, the compiler typically deduces template argument(s) for the member template&#8217;s own parameter(s) from the arguments passed in the call (&#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">653</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>vector&lt;long&gt; vi = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>list&lt;const char*&gt; w = {"now", "is", "the", "time"};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">and the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor that has two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameters</span></span></span><br class="calibre6"/>Blob&lt;int&gt; a1(begin(ia), end(ia));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor that has</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;long&gt;::iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameters</span></span></span><br class="calibre6"/>Blob&lt;int&gt; a2(vi.begin(), vi.end());<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;string&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class and the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob&lt;string&gt;</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">constructor that has two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">(list&lt;const char*&gt;::iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameters</span></span></span><br class="calibre6"/>Blob&lt;string&gt; a3(w.begin(), w.end());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">a1</span></tt></code>, we explicitly specify that the compiler should instantiate a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> with the template parameter bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The type parameter for the constructor&#8217;s own parameters will be deduced from the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin(ia)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end(ia)</span></tt></code>. That type is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code>. Thus, the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a1</span></tt></code> instantiates:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;::Blob(int*, int*);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code> uses the already instantiated <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;</span></tt></code> class, and instantiates the constructor with <code class="calibre23"><tt class="calibre23"><span class="calibre24">It</span></tt></code> replaced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;short&gt;::iterator</span></tt></code>. The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a3</span></tt></code> (explicitly) instantiates the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> with its template parameter bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and (implicitly) instantiates the member template constructor of that class with its parameter bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;const char*&gt;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4300047"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.21:</strong> Write your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.22:</strong> Revise your <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> programs from &#167; <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>) so that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> members use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> as their deleter (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.23:</strong> Predict when the call operator will be executed in your main query program. If your expectations and what happens differ, be sure you understand why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.24:</strong> Add a constructor that takes two iterators to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> template.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4301573" class="calibre37"><span class="calibre5">16.1.5. Controlling Instantiations</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">The fact that instantiations are generated when a template is used (&#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">656</a>) means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4302204"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">In large systems, the overhead of instantiating the same template in multiple files can become significant. Under the new standard, we can avoid this overhead through an <strong class="calibre5"><a id="filepos4302470" href="160-defined_terms.html#filepos4549932">explicit instantiation</a></strong>. An explicit instantiation has the form</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">extern template <span><span class="calibre45"><span class="calibre16">declaration;</span></span></span> // <span><span class="calibre45"><span class="calibre16">instantiation declaration</span></span></span><br class="calibre6"/>template <span><span class="calibre45"><span class="calibre16">declaration;</span></span></span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">instantiation definition</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">declaration</em> is a class or function declaration in which all the template parameters are replaced by the template arguments. For example,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">instantion declaration and definition</span></span></span><br class="calibre6"/>extern template class Blob&lt;string&gt;;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declaration</span></span></span><br class="calibre6"/>template int compare(const int&amp;, const int&amp;);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">definition</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler sees an <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> template declaration, it will not generate code for that instantiation in that file. Declaring an instantiation as <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> is a promise that there will be a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> use of that instantiation elsewhere in the program. There may be several <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> declarations for a given instantiation but there must be exactly one definition for that instantiation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the compiler automatically instantiates a template when we use it, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> declaration must appear before any code that uses that instantiation:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Application.cc</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">these template types must be instantiated elsewhere in the program</span></span></span><br class="calibre6"/>extern template class Blob&lt;string&gt;;<br class="calibre6"/>extern template int compare(const int&amp;, const int&amp;);<br class="calibre6"/>Blob&lt;string&gt; sa1, sa2; // <span><span class="calibre45"><span class="calibre16">instantiation will appear elsewhere</span></span></span><br class="calibre6"/>// Blob&lt;int&gt; <span><span class="calibre45"><span class="calibre16">and its</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">initializer_list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor instantiated in this file</span></span></span><br class="calibre6"/>Blob&lt;int&gt; a1 = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>Blob&lt;int&gt; a2(a1);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor instantiated in this file</span></span></span><br class="calibre6"/>int i = compare(a1[0], a2[0]); // <span><span class="calibre45"><span class="calibre16">instantiation will appear elsewhere</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4306656"/>The file <code class="calibre23"><tt class="calibre23"><span class="calibre24">Application.o</span></tt></code> will contain instantiations for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;int&gt;</span></tt></code>, along with the <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> and copy constructors for that class. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare&lt;int&gt;</span></tt></code> function and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt;</span></tt></code> class will not be instantiated in that file. There must be definitions of these templates in some other file in the program:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">templateBuild.cc</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">instantiation file must provide a (non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">extern</span></span></tt></span><span><span class="calibre45"><span class="calibre16">) definition for every</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">type and function that other files declare as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">extern</span></span></tt></span><br class="calibre6"/>template int compare(const int&amp;, const int&amp;);<br class="calibre6"/>template class Blob&lt;string&gt;; // <span><span class="calibre45"><span class="calibre16">instantiates all members of the class template</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler sees an instantiation definition (as opposed to a declaration), it generates code. Thus, the file <code class="calibre23"><tt class="calibre23"><span class="calibre24">templateBuild.o</span></tt></code> will contain the definitions for <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> instantiated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt;</span></tt></code> class. When we build the application, we must link <code class="calibre23"><tt class="calibre23"><span class="calibre24">templateBuild.o</span></tt></code> with the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Application.o</span></tt></code> files.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">There must be an explicit instantiation definition somewhere in the program for every instantiation declaration.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Instantiation Definitions Instantiate All Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">An instantiation definition for a class template instantiates <em class="calibre16">all</em> the members of that template including inline member functions. When the compiler sees an instantiation definition it cannot know which member functions the program uses. Hence, unlike the way it handles ordinary class template instantiations, the compiler instantiates <em class="calibre16">all</em> the members of that class. Even if we do not use a member, that member will be instantiated. Consequently, we can use explicit instantiation only for types that can be used with all the members of that template.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An instantiation definition can be used only for types that can be used with every member function of a class template.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4310778" class="calibre37"><span class="calibre5">16.1.6. Efficiency and Flexibility</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">The library smart pointer types (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">12.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">450</a>) offer a good illustration of design choices faced by designers of templates.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The obvious difference between <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> is the strategy they use in managing the pointer they hold&#8212;one class gives us shared ownership; the other owns the pointer that it holds. This difference is essential to what these classes do.</p><div class="calibre22">&#160;</div>
<p class="calibre25">These classes also differ in how they let users override their default deleter. We can easily override the deleter of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> by passing a callable object when we create or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> the pointer. In contrast, the type of the deleter is part of the type of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> object. Users must supply that type as an explicit template argument when they define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. As a result, it is more complicated for users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> to provide their own deleter.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4312501"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.25:</strong> Explain the meaning of these declarations:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">extern template class vector&lt;string&gt;;<br class="calibre6"/>template class vector&lt;Sales_data&gt;;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.26:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">NoDefault</span></tt></code> is a class that does not have a default constructor, can we explicitly instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;NoDefault&gt;</span></tt></code>? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.27:</strong> For each labeled statement explain what, if any, instantiations happen. If a template is instantiated, explain why; if not, explain why not.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; class Stack { };<br class="calibre6"/>void f1(Stack&lt;char&gt;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">(a)</span></span></span><br class="calibre6"/>class Exercise {<br class="calibre6"/>&#160;&#160;&#160;&#160;Stack&lt;double&gt; &amp;rsd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">(b)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Stack&lt;int&gt;&#160;&#160;&#160;&#160;si;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">(c)</span></span></span><br class="calibre6"/>};<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;Stack&lt;char&gt; *sc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">(d)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;f1(*sc);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">(e)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int iObj = sizeof(Stack&lt; string &gt;); // <span><span class="calibre45"><span class="calibre16">(f)</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The difference in how the deleter is handled is incidental to the functionality of these classes. However, as we&#8217;ll see, this difference in implementation strategy may have important performance impacts.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Binding the Deleter at Run Time</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although we don&#8217;t know how the library types are implemented, we can infer that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> must access its deleter indirectly. That is the deleter must be stored as a pointer or as a class (such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> (&#167; <a href="137-14.8._functioncall_operator.html#filepos3690557">14.8.3</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3690557">577</a>)) that encapsulates a pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can be certain that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> does not hold the deleter as a direct member, because the type of the deleter isn&#8217;t known until run time. Indeed, we can change the type of the deleter in a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> during that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>&#8217;s lifetime. We can construct a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> using a deleter of one type, and subsequently use <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> to give that same <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> a different type of deleter. In general, we cannot have a member whose type changes at run time. Hence, the deleter must be stored indirectly.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To think about how the deleter must work, let&#8217;s assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> stores the pointer it manages in a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>, and that the deleter is accessed through a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">del</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> destructor must include a statement such as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">del</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">known only at run time; call through a pointer</span></span></span><br class="calibre6"/>del ? del(p) : delete p; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">del(p)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">requires run-time jump to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">del</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s location</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4318961"/>Because the deleter is stored indirectly, the call <code class="calibre23"><tt class="calibre23"><span class="calibre24">del(p)</span></tt></code> requires a run-time jump to the location stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">del</span></tt></code> to execute the code to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">del</span></tt></code> points.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Binding the Deleter at Compile Time</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Now, let&#8217;s think about how <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> might work. In this class, the type of the deleter is part of the type of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> has two template parameters, one that represents the pointer that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> manages and the other that represents the type of the deleter. Because the type of the deleter is part of the type of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>, the type of the deleter member is known at compile time. The deleter can be stored directly in each <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> destructor operates similarly to its <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> counterpart in that it calls a user-supplied deleter or executes <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on its stored pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">del</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bound at compile time; direct call to the deleter is instantiated</span></span></span><br class="calibre6"/>del(p);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no run-time overhead</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">del</span></tt></code> is either the default deleter type or a user-supplied type. It doesn&#8217;t matter; either way the code that will be executed is known at compile time. Indeed, if the deleter is something like our <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> class (&#167; <a href="154-16.1._defining_a_template.html#filepos4283763">16.1.4</a>, p. <a href="154-16.1._defining_a_template.html#filepos4283763">672</a>) this call might even be inlined at compile time.</p><div class="calibre15">&#160;</div>
<p class="calibre25">By binding the deleter at compile time, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> avoids the run-time cost of an indirect call to its deleter. By binding the deleter at run time, <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> makes it easier for users to override the deleter.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.1.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.28:</strong> Write your own versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.29:</strong> Revise your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> class to use your version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> rather than the library version.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.30:</strong> Rerun some of your programs to verify your <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> and revised <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> classes. (Note: Implementing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> type is beyond the scope of this Primer, so you will not be able to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> class with your revised <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>.)</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.31:</strong> Explain how the compiler might inline the call to the deleter if we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">DebugDelete</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="153-chapter_16._templates_and_generic_programming.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="155-16.2._template_argument_deduction.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
