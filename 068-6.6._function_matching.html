<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>6.6. Function Matching</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="067-6.5._features_for_specialized_uses.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="069-6.7._pointers_to_functions.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1674559" class="calibre29"><span class="bold">6.6. Function Matching</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In many (if not most) cases, it is easy to figure out which overloaded function matches a given call. However, it is not so simple when the overloaded functions have the same number of parameters and when one or more of the parameters have types that are related by conversions. As an example, consider the following set of functions and function call:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f();<br class="calibre6"/>void f(int);<br class="calibre6"/>void f(int, int);<br class="calibre6"/>void f(double, double = 3.14);<br class="calibre6"/>f(5.6);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">void f(double, double</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1675709"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.5.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.47:</strong> Revise the program you wrote in the exercises in &#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a> (p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">228</a>) that used recursion to print the contents of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to conditionally print information about its execution. For example, you might print the size of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> on each call. Compile and run the program with debugging turned on and again with it turned off.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.48:</strong> Explain what this loop does and whether it is a good use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">assert</span></tt></code>:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s;<br class="calibre6"/>while (cin &gt;&gt; s &amp;&amp; s != sought) { }&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty body</span></span></span><br class="calibre6"/>assert(cin);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Determining the Candidate and Viable Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The first step of function matching identifies the set of overloaded functions considered for the call. The functions in this set are the <strong class="calibre5"><a id="filepos1677543" href="071-defined_terms.html#filepos1731522">candidate functions</a></strong>. A candidate function is a function with the same name as the called function and for which a declaration is visible at the point of the call. In this example, there are four candidate functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second step selects from the set of candidate functions those functions that can be called with the arguments in the given call. The selected functions are the <strong class="calibre5"><a id="filepos1678119" href="071-defined_terms.html#filepos1740528">viable functions</a></strong>. To be viable, a function must have the same number of parameters as there are arguments in the call, and the type of each argument must match&#8212;or be convertible to&#8212;the type of its corresponding parameter.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can eliminate two of our candidate functions based on the number of arguments. The function that has no parameters and the one that has two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameters are not viable for this call. Our call has only one argument, and these functions have zero and two parameters, respectively.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The function that takes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and the function that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>s might be viable. Either of these functions can be called with a single argument. The function taking two <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>s has a default argument, which means it can be called with a single argument.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When a function has default arguments (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>), a call may appear to have fewer arguments than it actually does.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Having used the number of arguments to winnow the candidate functions, we next look at whether the argument types match those of the parameters. As with any call, an argument might match its parameter either because the types match exactly or because there is a conversion from the argument type to the type of the parameter. In this example, both of our remaining functions are viable:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int)</span></tt></code> is viable because a conversion exists that can convert the argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> to the parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code> is viable because a default argument is provided for the function&#8217;s second parameter and its first parameter is of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, which exactly matches the type of the parameter.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos1681218"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If there are no viable functions, the compiler will complain that there is no matching function.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Finding the Best Match, If Any</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The third step of function matching determines which viable function provides the best match for the call. This process looks at each argument in the call and selects the viable function (or functions) for which the corresponding parameter best matches the argument. We&#8217;ll explain the details of &#8220;best&#8221; in the next section, but the idea is that the closer the types of the argument and parameter are to each other, the better the match.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In our case, there is only one (explicit) argument in the call. That argument has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. To call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int)</span></tt></code>, the argument would have to be converted from <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The other viable function, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code>, is an exact match for this argument. An exact match is better than a match that requires a conversion. Therefore, the compiler will resolve the call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(5.6)</span></tt></code> as a call to the function that has two <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> parameters. The compiler will add the default argument for the second, missing argument.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Function Matching with Multiple Parameters</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Function matching is more complicated if there are two or more arguments. Given the same functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, let&#8217;s analyze the following call:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f(42, 2.56);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The set of viable functions is selected in the same way as when there is only one parameter. The compiler selects those functions that have the required number of parameters and for which the argument types match the parameter types. In this case, the viable functions are <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int, int)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code>. The compiler then determines, argument by argument, which function is (or functions are) the best match. There is an overall best match if there is one and only one function for which</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The match for each argument is no worse than the match required by any other viable function</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There is at least one argument for which the match is better than the match provided by any other viable function</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">If after looking at each argument there is no single function that is preferable, then the call is in error. The compiler will complain that the call is ambiguous.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this call, when we look only at the first argument, we find that the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int, int)</span></tt></code> is an exact match. To match the second function, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> argument <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code> must be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. A match through a built-in conversion is &#8220;less good&#8221; than one that is exact. Considering only the first argument, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int, int)</span></tt></code> is a better match than <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos1685911"/>When we look at the second argument, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code> is an exact match to the argument <code class="calibre23"><tt class="calibre23"><span class="calibre24">2.56</span></tt></code>. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(int, int)</span></tt></code> would require that <code class="calibre23"><tt class="calibre23"><span class="calibre24">2.56</span></tt></code> be converted from <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. When we consider only the second parameter, the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">f(double, double)</span></tt></code> is a better match.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The compiler will reject this call because it is ambiguous: Each viable function is a better match than the other on one of the arguments to the call. It might be tempting to force a match by explicitly casting (&#167; <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a>, p. <a href="049-4.11._type_conversions.html#filepos1189032">162</a>) one of our arguments. However, in well-designed systems, argument casts should not be necessary.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Casts should not be needed to call an overloaded function. The need for a cast suggests that the parameter sets are designed poorly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.49:</strong> What is a candidate function? What is a viable function?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.50:</strong> Given the declarations for <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> from page <a href="067-6.5._features_for_specialized_uses.html#filepos1669800">242</a>, list the viable functions, if any for each of the following calls. Indicate which function is the best match, or if the call is illegal whether there is no match or why the call is ambiguous.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">f(2.56, 42)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">f(42)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">f(42, 0)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">f(2.56, 3.14)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.51:</strong> Write all four versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>. Each function should print a distinguishing message. Check your answers for the previous exercise. If your answers were incorrect, study this section until you understand why your answers were wrong.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1689576" class="calibre37"><span class="calibre5">6.6.1. Argument Type Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In order to determine the best match, the compiler ranks the conversions that could be used to convert each argument to the type of its corresponding parameter. Conversions are ranked as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> An exact match. An exact match happens when:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre57">&#8226; The argument and parameter types are identical.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre57">&#8226; The argument is converted from an array or function type to the corresponding pointer type. (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a> (p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>) covers function pointers.)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre57">&#8226; A top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> is added to or discarded from the argument.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> Match through a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> conversion (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong> Match through a promotion (&#167; <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">160</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">4.</strong> Match through an arithmetic (&#167; <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">159</a>) or pointer conversion (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">161</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">5.</strong> Match through a class-type conversion. (&#167; <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">14.9</a> (p. <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">579</a>) covers these conversions.)</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1691922"/>Matches Requiring Promotion or Arithmetic Conversion</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Promotions and conversions among the built-in types can yield surprising results in the context of function matching. Fortunately, well-designed systems rarely include functions with parameters as closely related as those in the following examples.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">In order to analyze a call, it is important to remember that the small integral types always promote to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> or to a larger integral type. Given two functions, one of which takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and the other a <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> version will be called only on values of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>. Even though the smaller integral values might appear to be a closer match, those values are promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, whereas calling the <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> version would require a conversion:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void ff(int);<br class="calibre6"/>void ff(short);<br class="calibre6"/>ff('a');&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">promotes to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">All the arithmetic conversions are treated as equivalent to each other. The conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>, for example, does not take precedence over the conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. As a concrete example, consider</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void manip(long);<br class="calibre6"/>void manip(float);<br class="calibre6"/>manip(3.14); // <span><span class="calibre45"><span class="calibre16">error: ambiguous call</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The literal <code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. That type can be converted to either <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code>. Because there are two possible arithmetic conversions, the call is ambiguous.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Function Matching and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Arguments</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we call an overloaded function that differs on whether a reference or pointer parameter refers or points to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the compiler uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of the argument to decide which function to call:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Record lookup(Account&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function that takes a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span><br class="calibre6"/>Record lookup(const Account&amp;); // <span><span class="calibre45"><span class="calibre16">new function that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference</span></span></span><br class="calibre6"/>const Account a;<br class="calibre6"/>Account b;<br class="calibre6"/>lookup(a);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lookup(const Account&amp;)</span></span></tt></span><br class="calibre6"/>lookup(b);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lookup(Account&amp;</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">In the first call, we pass the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>. We cannot bind a plain reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. In this case the only viable function is the version that takes a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Moreover, that call is an exact match to the argument <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In the second call, we pass the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>. For this call, both functions are viable. We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> to initialize a reference to either <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. However, initializing a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> from a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object requires a conversion. The version that takes a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> parameter is an exact match for <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>. Hence, the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version is preferred.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos1699413"/>Pointer parameters work in a similar way. If two functions differ only as to whether a pointer parameter points to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the compiler can distinguish which function to call based on the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of the argument: If the argument is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the call will match the function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const*</span></tt></code>; otherwise, if the argument is a pointer to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the function taking a plain pointer is called.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.6.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.52:</strong> Given the following declarations,</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void manip(int, int);<br class="calibre6"/>double dobj;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44">what is the rank (&#167; <a href="068-6.6._function_matching.html#filepos1689576">6.6.1</a>, p. <a href="068-6.6._function_matching.html#filepos1689576">245</a>) of each conversion in the following calls?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">manip('a', 'z');</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">manip(55.4, dobj);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.53:</strong> Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(int&amp;, int&amp;);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(const int&amp;, const int&amp;);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(char*, char*);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(const char*, const char*);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(char*, char*);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(char* const, char* const);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="067-6.5._features_for_specialized_uses.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="069-6.7._pointers_to_functions.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
