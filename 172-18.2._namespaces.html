<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>18.2. Namespaces</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="171-18.1._exception_handling.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="173-18.3._multiple_and_virtual_inheritance.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4928252" class="calibre29"><span class="bold">18.2. Namespaces</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Large programs tend to use independently developed libraries. Such libraries also tend to define a large number of global names, such as classes, functions, and templates. When an application uses libraries from many different vendors, it is almost inevitable that some of these names will clash. Libraries that put names into the global namespace are said to cause <strong class="calibre5"><a id="filepos4928745" href="175-defined_terms.html#filepos5112313">namespace pollution</a></strong>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Traditionally, programmers avoided namespace pollution by using very long names for the global entities they defined. Those names often contained a prefix indicating which library defined the name:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class cplusplus_primer_Query { ... };<br class="calibre6"/>string cplusplus_primer_make_plural(size_t, string&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><strong class="calibre5"><a id="filepos4929726" href="175-defined_terms.html#filepos5111084">Namespaces</a></strong> provide a much more controlled mechanism for preventing name collisions. Namespaces partition the global namespace. A namespace is a scope. By defining a library&#8217;s names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.</p><div class="calibre22">&#160;</div>
<h4 id="filepos4930092" class="calibre37"><span class="calibre5">18.2.1. Namespace Definitions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A namespace definition begins with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace</span></tt></code> followed by the namespace name. Following the namespace name is a sequence of declarations and definitions delimited by curly braces. Any declaration that can appear at global scope can be put into a namespace: classes, variables (with their initializations), functions (with their definitions), templates, and other namespaces:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace cplusplus_primer {<br class="calibre6"/>&#160;&#160;&#160;&#160;class Sales_data { / * ... * /};<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data operator+(const Sales_data&amp;,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Sales_data&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;class Query { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;class Query_base { /* ... */};<br class="calibre6"/>} // <span><span class="calibre45"><span class="calibre16">like blocks, namespaces do not end with a semicolon</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4931600"/>This code defines a namespace named <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> with four members: three classes and an overloaded <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any name, a namespace name must be unique within the scope in which the namespace is defined. Namespaces may be defined at global scope or inside another namespace. They may not be defined inside a function or a class.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A namespace scope does not end with a semicolon.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Each Namespace Is a Scope</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As is the case for any scope, each name in a namespace must refer to a unique entity within that namespace. Because different namespaces introduce different scopes, different namespaces may have members with the same name.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Names defined in a namespace may be accessed directly by other members of the namespace, including scopes nested within those members. Code outside the namespace must indicate the namespace in which the name is defined:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cplusplus_primer::Query q =<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cplusplus_primer::Query("hello");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">If another namespace (say, <code class="calibre23"><tt class="calibre23"><span class="calibre24">AddisonWesley</span></tt></code>) also provides a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class and we want to use that class instead of the one defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code>, we can do so by modifying our code as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">AddisonWesley::Query q = AddisonWesley::Query("hello");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Namespaces Can Be Discontiguous</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we saw in &#167; <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a> (p. <a href="158-16.5._template_specializations.html#filepos4508634">709</a>), unlike other scopes, a namespace can be defined in several parts. Writing a namespace definition:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace nsp {<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">declarations</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">either defines a new namespace named <code class="calibre23"><tt class="calibre23"><span class="calibre24">nsp</span></tt></code> or adds to an existing one. If the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">nsp</span></tt></code> does not refer to a previously defined namespace, then a new namespace with that name is created. Otherwise, this definition opens an existing namespace and adds declarations to that already existing namespace.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fact that namespace definitions can be discontiguous lets us compose a namespace from separate interface and implementation files. Thus, a namespace can be organized in the same way that we manage our own class and function definitions:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Namespace members that define classes, and declarations for the functions and objects that are part of the class interface, can be put into header files. These headers can be included by files that use those namespace members.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The definitions of namespace members can be put in separate source files.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos4936358"/>Organizing our namespaces this way also satisfies the requirement that various entities&#8212;non-inline functions, static data members, variables, and so forth&#8212;may be defined only once in a program. This requirement applies equally to names defined in a namespace. By separating the interface and implementation, we can ensure that the functions and other names we need are defined only once, but the same declaration will be seen whenever the entity is used.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Namespaces that define multiple, unrelated types should use separate files to represent each type (or each collection of related types) that the namespace defines.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining the Primer Namespace</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Using this strategy for separating interface and implementation, we might define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> library in several separate files. The declarations for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> and its related functions would be placed in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data.h</span></tt></code>, those for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> classes of <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query.h</span></tt></code>, and so on. The corresponding implementation files would be in files such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data.cc</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query.cc</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// ---- <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data.h</span></span></tt></span>----<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">#includes</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should appear before opening the namespace</span></span></span><br class="calibre6"/>#include &lt;string&gt;<br class="calibre6"/>namespace cplusplus_primer {<br class="calibre6"/>&#160;&#160;&#160;&#160;class Sales_data { /* ... */};<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data operator+(const Sales_data&amp;,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Sales_data&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declarations for the remaining functions in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">interface</span></span></span><br class="calibre6"/>}<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">---- Sales_data.cc----</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">be sure any</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">#includes</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">appear before opening the namespace</span></span></span><br class="calibre6"/>#include "Sales_data.h"<br class="calibre6"/><br class="calibre6"/>namespace cplusplus_primer {<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">definitions for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members and overloaded operators</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A program using our library would include whichever headers it needed. The names in those headers are defined inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">---- user.cc----</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">names in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data.h</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">header are in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cplusplus_primer</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace</span></span></span><br class="calibre6"/>#include "Sales_data.h"<br class="calibre6"/><br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;using cplusplus_primer::Sales_data;<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data trans1, trans2;<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">This program organization gives the developers and the users of our library the needed modularity. Each class is still organized into its own interface and <a id="filepos4941806"/>implementation files. A user of one class need not compile names related to the others. We can hide the implementations from our users, while allowing the files <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data.cc</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">user.cc</span></tt></code> to be compiled and linked into one program without causing any compile-time or link-time errors. Developers of the library can work independently on the implementation of each type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is worth noting that ordinarily, we do not put a <code class="calibre23"><tt class="calibre23"><span class="calibre24">#include</span></tt></code> inside the namespace. If we did, we would be attempting to define all the names in that header as members of the enclosing namespace. For example, if our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data.h</span></tt></code> file opened the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> before including the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> header our program would be in error. It would be attempting to define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace nested inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining Namespace Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Assuming the appropriate declarations are in scope, code inside a namespace may use the short form for names defined in the same (or in an enclosing) namespace:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">#include "Sales_data.h"<br class="calibre6"/>namespace cplusplus_primer {&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reopen</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cplusplus_primer</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">members defined inside the namespace may use unqualified names</span></span></span><br class="calibre6"/>std::istream&amp;<br class="calibre6"/>operator&gt;&gt;(std::istream&amp; in, Sales_data&amp; s) { /* ... */}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">It is also possible to define a namespace member outside its namespace definition. The namespace declaration of the name must be in scope, and the definition must specify the namespace to which the name belongs:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">namespace members defined outside the namespace must use qualified names</span></span></span><br class="calibre6"/>cplusplus_primer::Sales_data<br class="calibre6"/>cplusplus_primer::operator+(const Sales_data&amp; lhs,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Sales_data&amp; rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data ret(lhs);<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with class members defined outside a class, once the fully qualified name is seen, we are in the scope of the namespace. Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace, we can use other namespace member names without qualification. Thus, even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> is a member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace, we can use its unqualified name to define the parameters in this function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although a namespace member can be defined outside its namespace, such definitions must appear in an enclosing namespace. That is, we can define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data operator+</span></tt></code> inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace or at global scope. We cannot define this operator in an unrelated namespace.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Template Specializations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Template specializations must be defined in the same namespace that contains the original template (&#167; <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a>, p. <a href="158-16.5._template_specializations.html#filepos4508634">709</a>). As with any other namespace name, so long as <a id="filepos4946800"/>we have declared the specialization inside the namespace, we can define it outside the namespace:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">we must declare the specialization as a member of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span><br class="calibre6"/>namespace std {<br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;&gt; struct hash&lt;Sales_data&gt;;<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">having added the declaration for the specialization to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">we can define the specialization outside the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace</span></span></span><br class="calibre6"/>template &lt;&gt; struct std::hash&lt;Sales_data&gt;<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t operator()(const Sales_data&amp; s) const<br class="calibre6"/>&#160;&#160;&#160;&#160;{ return hash&lt;string&gt;()(s.bookNo) ^<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash&lt;unsigned&gt;()(s.units_sold) ^<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash&lt;double&gt;()(s.revenue); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Global Namespace</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Names defined at global scope (i.e., names declared outside any class, function, or namespace) are defined inside the <strong class="calibre5"><a id="filepos4948788" href="175-defined_terms.html#filepos5109867">global namespace</a></strong>. The global namespace is implicitly declared and exists in every program. Each file that defines entities at global scope (implicitly) adds those names to the global namespace.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The scope operator can be used to refer to members of the global namespace. Because the global namespace is implicit, it does not have a name; the notation</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">::member_name</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">refers to a member of the global namespace.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Nested Namespaces</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A nested namespace is a namespace defined inside another namespace:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace cplusplus_primer {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">first nested namespace: defines the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">portion of the library</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;namespace QueryLib {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Query { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Query operator&amp;(const Query&amp;, const Query&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">second nested namespace: defines the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">portion of the library</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;namespace Bookstore {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Quote { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class Disc_quote : public Quote { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace now contains two nested namespaces: the namespaces named <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryLib</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bookstore</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4951703"/>A nested namespace is a nested scope&#8212;its scope is nested within the namespace that contains it. Nested namespace names follow the normal rules: Names declared in an inner namespace hide declarations of the same name in an outer namespace. Names defined inside a nested namespace are local to that inner namespace. Code in the outer parts of the enclosing namespace may refer to a name in a nested namespace only through its qualified name: For example, the name of the class declared in the nested namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryLib</span></tt></code> is</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cplusplus_primer::QueryLib::Query</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Inline Namespaces</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos4952747"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">The new standard introduced a new kind of nested namespace, an <strong class="calibre5"><a id="filepos4952905" href="175-defined_terms.html#filepos5110381">inline namespace</a></strong>. Unlike ordinary nested namespaces, names in an inline namespace can be used as if they were direct members of the enclosing namespace. That is, we need not qualify names from an inline namespace by their namespace name. We can access them using only the name of the enclosing namespace.</p><div class="calibre15">&#160;</div>
<p class="calibre25">An inline namespace is defined by preceding the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace</span></tt></code> with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">inline namespace FifthEd {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">namespace for the code from the Primer Fifth Edition</span></span></span><br class="calibre6"/>}<br class="calibre6"/>namespace FifthEd { // <span><span class="calibre45"><span class="calibre16">implicitly inline</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;class Query_base { /* ... * /};<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>-<span><span class="calibre45"><span class="calibre16">related declarations</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The keyword must appear on the first definition of the namespace. If the namespace is later reopened, the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> need not be, but may be, repeated.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Inline namespaces are often used when code changes from one release of an application to the next. For example, we can put all the code from the current edition of the Primer into an inline namespace. Code for previous versions would be in non-inlined namespaces:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace FourthEd {<br class="calibre6"/>&#160;&#160;&#160;&#160;class Item_base { /* ... */};<br class="calibre6"/>&#160;&#160;&#160;&#160;class Query_base { /* ... */};<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other code from the Fourth Edition</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The overall <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> namespace would include the definitions of both namespaces. For example, assuming that each namespace was defined in a header with the corresponding name, we&#8217;d define <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace cplusplus_primer {<br class="calibre6"/>#include "FifthEd.h"<br class="calibre6"/>#include "FourthEd.h"<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4956469"/>Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">FifthEd</span></tt></code> is inline, code that refers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer::</span></tt></code> will get the version from that namespace. If we want the earlier edition code, we can access it as we would any other nested namespace, by using the names of all the enclosing namespaces: for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cplusplus_primer::FourthEd::Query_base</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Unnamed Namespaces</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">An <strong class="calibre5"><a id="filepos4957130" href="175-defined_terms.html#filepos5118215">unnamed namespace</a></strong> is the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace</span></tt></code> followed immediately by a block of declarations delimited by curly braces. Variables defined in an unnamed namespace have static lifetime: They are created before their first use and destroyed when the program ends.</p><div class="calibre15">&#160;</div>
<p class="calibre25">An unnamed namespace may be discontiguous within a given file but does not span files. Each file has its own unnamed namespace. If two files contain unnamed namespaces, those namespaces are unrelated. Both unnamed namespaces can define the same name; those definitions would refer to different entities. If a header defines an unnamed namespace, the names in that namespace define different entities local to each file that includes the header.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Unlike other namespaces, an unnamed namespace is local to a particular file and never spans multiple files.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Names defined in an unnamed namespace are used directly; after all, there is no namespace name with which to qualify them. It is not possible to use the scope operator to refer to members of unnamed namespaces.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Names defined in an unnamed namespace are in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">global declaration for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>namespace {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ambiguous: defined globally and in an unnested, unnamed namespace</span></span></span><br class="calibre6"/>i = 10;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In all other ways, the members of an unnamed namespace are normal program entities. An unnamed namespace, like any other namespace, may be nested inside another namespace. If the unnamed namespace is nested, then names in it are accessed in the normal way, using the enclosing namespace name(s):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace local {<br class="calibre6"/>&#160;&#160;&#160;&#160;namespace {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">defined in a nested unnamed namespace is distinct from global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>local::i = 42;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos4960971"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Unnamed Namespaces Replace File Statics</span></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Prior to the introduction of namespaces, programs declared names as <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> to make them local to a file. The use of <em class="calibre16"><a id="filepos4961358" href="175-defined_terms.html#filepos5108719">file statics</a></em> is inherited from C. In C, a global entity declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> is invisible outside the file in which it is declared.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The use of file <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> declarations is deprecated by the C++ standard. File statics should be avoided and unnamed namespaces used instead.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.12:</strong> Organize the programs you have written to answer the questions in each chapter into their own namespaces. That is, namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">chapter15</span></tt></code> would contain code for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> programs and <code class="calibre23"><tt class="calibre23"><span class="calibre24">chapter10</span></tt></code> would contain the <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> code. Using this structure, compile the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> code examples.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.13:</strong> When might you use an unnamed namespace?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.14:</strong> Suppose we have the following declaration of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator*</span></tt></code> that is a member of the nested namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">mathLib::MatrixLib</span></tt></code>:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace mathLib {<br class="calibre6"/>&#160;&#160;&#160;&#160;namespace MatrixLib {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;class matrix { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;matrix operator*<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(const matrix &amp;, const matrix &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">How would you declare this operator in global scope?</p><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4964533" class="calibre37"><span class="calibre5">18.2.2. Using Namespace Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Referring to namespace members as <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace_name::member_name</span></tt></code> is admittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members. Our programs have used one of these ways, <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations (&#167; <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>). The others, namespace aliases and <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives, will be described in this section.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Namespace Aliases</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos4965437" href="175-defined_terms.html#filepos5111539">namespace alias</a></strong> can be used to associate a shorter synonym with a namespace name. For example, a long namespace name such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace cplusplus_primer&#160;&#160;&#160;&#160;&#160;&#160;{ /* ... */ };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">can be associated with a shorter synonym as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace primer = cplusplus_primer;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4966330"/>A namespace alias declaration begins with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace</span></tt></code>, followed by the alias name, followed by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> sign, followed by the original namespace name and a semicolon. It is an error if the original namespace name has not already been defined as a namespace.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A namespace alias can also refer to a nested namespace:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace Qlib = cplusplus_primer::QueryLib;<br class="calibre6"/>Qlib::Query q;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A namespace can have many synonyms, or aliases. All the aliases and the original namespace name can be used interchangeably.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Declarations: A Recap</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <a id="filepos4967941" href="175-defined_terms.html#filepos5118647"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code>
<strong class="calibre5">declaration</strong></a> introduces only one namespace member at a time. It allows us to be very specific regarding which names are used in our programs.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Names introduced in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration obey normal scope rules: They are visible from the point of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration to the end of the scope in which the declaration appears. Entities with the same name defined in an outer scope are hidden. The unqualified name may be used only within the scope in which it is declared and in scopes nested within that scope. Once the scope ends, the fully qualified name must be used.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration can appear in global, local, namespace, or class scope. In class scope, such declarations may only refer to a base class member (&#167; <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">615</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Directives</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <a id="filepos4969522" href="175-defined_terms.html#filepos5119548"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code>
<strong class="calibre5">directive</strong></a>, like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration, allows us to use the unqualified form of a namespace name. Unlike a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration, we retain no control over which names are made visible&#8212;they all are.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive begins with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code>, followed by the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">namespace</span></tt></code>, followed by a namespace name. It is an error if the name is not a previously defined namespace name. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive may appear in global, local, or namespace scope. It may not appear in a class scope.</p><div class="calibre22">&#160;</div>
<p class="calibre25">These directives make all the names from a specific namespace visible without qualification. The short form names can be used from the point of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive to the end of the scope in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive appears.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Providing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive for namespaces, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>, that our application does not control reintroduces all the name collision problems inherent in using multiple libraries.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Directives and Scope</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The scope of names introduced by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive is more complicated than the scope of names in <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations. As we&#8217;ve seen, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration puts the name in the same scope as that of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration itself. It is as if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration declares a local alias for the namespace member.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4972677"/>A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive does not declare local aliases. Rather, it has the effect of lifting the namespace members into the nearest scope that contains both the namespace itself and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This difference in scope between a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive stems directly from how these two facilities work. In the case of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration, we are simply making name directly accessible in the local scope. In contrast, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive makes the entire contents of a namespace available In general, a namespace might include definitions that cannot appear in a local scope. As a consequence, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive is treated as if it appeared in the nearest enclosing namespace scope.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In the simplest case, assume we have a namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> and a function <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, both defined at global scope. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive for <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>, then in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> it will be as if the names in <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> appeared in the global scope prior to the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and function</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are defined at global scope</span></span></span><br class="calibre6"/>namespace A {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i, j;<br class="calibre6"/>}<br class="calibre6"/>void f()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;using namespace A;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">injects the names from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into the global scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; i *&#160;&#160;j &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Directives Example</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Let&#8217;s look at an example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace blip {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i = 16, j = 15, k = 23;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other declarations</span></span></span><br class="calibre6"/>}<br class="calibre6"/>int j = 0; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is hidden inside a namespace</span></span></span><br class="calibre6"/>void manip()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">using</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">directive; the names in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are ''added'' to the global scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;using namespace blip; // <span><span class="calibre45"><span class="calibre16">clash between ::</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip::j</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">detected only if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is used</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">sets</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip::i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">17</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++j;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error ambiguous: global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip::j</span></span></tt></span>?<br class="calibre6"/>&#160;&#160;&#160;&#160;++::j;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: sets global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++blip::j;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: sets</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip::j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">16</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int k = 97; // <span><span class="calibre45"><span class="calibre16">local</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">blip::k</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++k;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">sets local</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">98</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive in <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> makes all the names in <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code> directly accessible; code inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> can refer to the names of these members, using their short form.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4981282"/>The members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code> appear as if they were defined in the scope in which both <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> are defined. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> is defined at global scope, then the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code> appear as if they were declared in global scope.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When a namespace is injected into an enclosing scope, it is possible for names in the namespace to conflict with other names defined in that (enclosing) scope. For example, inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code> member <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> conflicts with the global object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>. Such conflicts are permitted, but to use the name, we must explicitly indicate which version is wanted. Any unqualified use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> within <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> is ambiguous.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To use a name such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>, we must use the scope operator to indicate which name is wanted. We would write <code class="calibre23"><tt class="calibre23"><span class="calibre24">::j</span></tt></code> to obtain the variable defined in global scope. To use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip</span></tt></code>, we must use its qualified name, <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip::j</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because the names are in different scopes, local declarations within <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> may hide some of the namespace member names. The local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">k</span></tt></code> hides the namespace member <code class="calibre23"><tt class="calibre23"><span class="calibre24">blip::k</span></tt></code>. Referring to <code class="calibre23"><tt class="calibre23"><span class="calibre24">k</span></tt></code> within <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> is not ambiguous; it refers to the local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">k</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Headers and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Declarations or Directives</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A header that has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive or declaration at its top-level scope injects names into every file that includes the header. Ordinarily, headers should define only the names that are part of its interface, not names used in its own implementation. As a result, header files should not contain <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives or <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations except inside functions or namespaces (&#167; <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">83</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Avoid <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> Directives</span></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives, which inject all the names from a namespace, are deceptively simple to use: With only a single statement, all the member names of a namespace are suddenly visible. Although this approach may seem simple, it can introduce its own problems. If an application uses many libraries, and if the names within these libraries are made visible with <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives, then we are back to square one, and the global namespace pollution problem reappears.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Moreover, it is possible that a working program will fail to compile when a new version of the library is introduced. This problem can arise if a new version introduces a name that conflicts with a name that the application is using.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Another problem is that ambiguity errors caused by <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives are detected only at the point of use. This late detection means that conflicts can arise long after introducing a particular library. If the program begins using a new part of the library, previously undetected collisions may arise.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Rather than relying on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive, it is better to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for each namespace name used in the program. Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations are detected at the point of declaration, not use, and so are easier to find and fix.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">One place where <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives are useful is in the implementation files of the namespace itself.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4987746"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.15:</strong> Explain the differences between <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations and directives.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.16:</strong> Explain the following code assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations for all the members of namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">Exercise</span></tt></code> are located at the location labeled <em class="calibre16">position 1.</em> What if they appear at <em class="calibre16">position 2</em> instead? Now answer the same question but replace the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive for namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">Exercise</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace Exercise {<br class="calibre6"/>&#160;&#160;&#160;&#160;int ivar = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;double dvar = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;const int limit = 1000;<br class="calibre6"/>}<br class="calibre6"/>int ivar = 0;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">position 1</span></span></span><br class="calibre6"/>void manip() {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">position 2</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double dvar = 3.1416;<br class="calibre6"/>&#160;&#160;&#160;&#160;int iobj = limit + 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;++ivar;<br class="calibre6"/>&#160;&#160;&#160;&#160;++::ivar;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.17:</strong> Write code to test your answers to the previous question.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4989992" class="calibre37"><span class="calibre5">18.2.3. Classes, Namespaces, and Scope</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Name lookup for names used inside a namespace follows the normal lookup rules: The search looks outward through the enclosing scopes. An enclosing scope might be one or more nested namespaces, ending in the all-encompassing global namespace. Only names that have been declared before the point of use that are in blocks that are still open are considered:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace A {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>&#160;&#160;&#160;&#160;namespace B {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">within</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int f1()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is local to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::B::j</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return i; // <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B::i</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;}&#160;&#160;// <span><span class="calibre45"><span class="calibre16">namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is closed and names in it are no longer visible</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int f2() {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return j;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not defined</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;int j = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initialized from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::i</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4993189"/>When a class is wrapped in a namespace, the normal lookup still happens: When a name is used by a member function, look for that name in the member first, then within the class (including base classes), then look in the enclosing scopes, one or more of which might be a namespace:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace A {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>&#160;&#160;&#160;&#160;int k;<br class="calibre6"/><br class="calibre6"/>&#160;&#160;&#160;&#160;class C1 {<br class="calibre6"/>&#160;&#160;&#160;&#160;public:<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C1(): i(0), j(0) { }&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C1::i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C1::j</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int f1() { return k; } // <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::k</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int f2() { return h; } // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">h</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not defined</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int f3();<br class="calibre6"/>&#160;&#160;&#160;&#160;private:<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">within</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C1</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int j;<br class="calibre6"/>&#160;&#160;&#160;&#160;};<br class="calibre6"/>&#160;&#160;&#160;&#160;int h = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initialized from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::i</span></span></tt></span><br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is defined outside class</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and outside namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>int A::C1::f3() { return h; }&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::h</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">With the exception of member function definitions that appear inside the class body (&#167; <a href="076-7.4._class_scope.html#filepos1931587">7.4.1</a>, p. <a href="076-7.4._class_scope.html#filepos1931587">283</a>), scopes are always searched upward; names must be declared before they can be used. Hence, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> will not compile. It attempts to reference the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code> from namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code> has not yet been defined. Had that name been defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> before the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">C1</span></tt></code>, the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code> would be legal. Similarly, the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> is okay, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> is defined after <code class="calibre23"><tt class="calibre23"><span class="calibre24">A::h</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The order in which scopes are examined to find a name can be inferred from the qualified name of a function. The qualified name indicates, in reverse order, the scopes that are searched.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The qualifiers <code class="calibre23"><tt class="calibre23"><span class="calibre24">A::C1::f3</span></tt></code> indicate the reverse order in which the class scopes and namespace scopes are to be searched. The first scope searched is that of the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code>. Then the class scope of its enclosing class <code class="calibre23"><tt class="calibre23"><span class="calibre24">C1</span></tt></code> is searched. The scope of the namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> is searched last before the scope containing the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> is examined.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Argument-Dependent Lookup and Parameters of Class Type</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Consider the following simple program:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::string s;<br class="calibre6"/>std::cin &gt;&gt; s;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we know, this call is equivalent to (&#167; <a href="130-14.1._basic_concepts.html#filepos3549336">14.1</a>, p. <a href="130-14.1._basic_concepts.html#filepos3549336">553</a>):</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">operator&gt;&gt;(std::cin, s);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4999892"/>This <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&gt;&gt;</span></tt></code> function is defined by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> library, which in turn is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace. Yet we can we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&gt;&gt;</span></tt></code> without an <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::</span></tt></code> qualifier and without a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can directly access the output operator because there is an important exception to the rule that names defined in a namespace are hidden. When we pass an object of a class type to a function, the compiler searches the namespace in which the argument&#8217;s class is defined <em class="calibre16">in addition</em> to the normal scope lookup. This exception also applies for calls that pass pointers or references to a class type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In this example, when the compiler sees the &#8220;call&#8221; to <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&gt;&gt;</span></tt></code>, it looks for a matching function in the current scope, including the scopes enclosing the output statement. In addition, because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> expression has parameters of class type, the compiler also looks in the namespace(s) in which the types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> are defined. Thus, for this call, the compiler looks in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace, which defines the <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> types. When it searches <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>, the compiler finds the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> output operator function.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This exception in the lookup rules allows nonmember functions that are conceptually part of the interface to a class to be used without requiring a separate <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration. In the absence of this exception to the lookup rules, either we would have to provide an appropriate <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for the output operator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using std::operator&gt;&gt;;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">needed to allow</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin &gt;&gt; s</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">or we would have to use the function-call notation in order to include the namespace qualifer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::operator&gt;&gt;(std::cin, s); // <span><span class="calibre45"><span class="calibre16">ok: explicitly use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std::&gt;&gt;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There would be no way to use operator syntax. Either of these declarations is awkward and would make simple uses of the IO library more complicated.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Lookup and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::move</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::forward</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Many, perhaps even most, C++ programmers never have to think about argument-dependent lookup. Ordinarily, if an application defines a name that is also defined in the library, one of two things is true: Either normal overloading determines (correctly) whether a particular call is intended for the application version or the one from the library, or the application never intends to use the library function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Now consider the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> functions. Both of these functions are template functions, and the library defines versions of them that have a single rvalue reference function parameter. As we&#8217;ve seen, in a function template, an rvalue reference parameter can match any type (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4403933">16.2.6</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4403933">690</a>). If our application defines a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> that takes a single parameter, then&#8212;no matter what type the parameter has&#8212;the application&#8217;s version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> will collide with the library version. Similarly for <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As a result, name collisions with <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code>) are more likely than collisions with other library functions. In addition, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> do very specialized type manipulations, the chances that an application specifically wants to override the behavior of these functions are pretty small.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5006547"/>The fact that collisions are more likely&#8212;and are less likely to be intentional&#8212;explains why we suggest always using the fully qualified versions of these names (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">470</a>). So long as we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we know that we will get the version from the standard library.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Friend Declarations and Argument-Dependent Lookup</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Recall that when a class declares a friend, the friend declaration does not make the friend visible (&#167; <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">270</a>). However, an otherwise undeclared class or function that is first named in a friend declaration is assumed to be a member of the closest enclosing namespace. The combination of this rule and argument-dependent lookup can lead to surprises:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace A {<br class="calibre6"/>&#160;&#160;&#160;&#160;class C {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">two friends; neither is declared apart from a friend declaration</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">these functions implicitly are members of namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;friend void f2();&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">won't be found, unless otherwise declared</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;friend void f(const C&amp;); // <span><span class="calibre45"><span class="calibre16">found by argument-dependent lookup</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;};<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, both <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> are members of namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>. Through argument-dependent lookup, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> even if there is no additional declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;A::C cobj;<br class="calibre6"/>&#160;&#160;&#160;&#160;f(cobj);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: finds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through the friend declaration in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::C</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;f2();&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A::f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not declared</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> takes an argument of a class type, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is implicitly declared in the same namespace as <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is found when called. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> has no parameter, it will not be found.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.18:</strong> Given the following typical definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> &#167; <a href="123-13.3._swap.html#filepos3315883">13.3</a> (p. <a href="123-13.3._swap.html#filepos3315883">517</a>), determine which version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is used if <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem1</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. What if <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem1</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>? Explain how name lookup works in both cases.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void swap(T v1, T v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;using std::swap;<br class="calibre6"/>&#160;&#160;&#160;&#160;swap(v1.mem1, v2.mem1);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">swap remaining members of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.19:</strong> What if the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> was <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::swap(v1.mem1, v2.mem1)?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos5012905" class="calibre37"><span class="calibre5"><a id="filepos5012938"/>18.2.4. Overloading and Namespaces</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Namespaces have two impacts on function matching (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>). One of these should be obvious: A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration or directive can add functions to the candidate set. The other is much more subtle.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Argument-Dependent Lookup and Overloading</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">As we saw in the previous section, name lookup for functions that have class-type arguments includes the namespace in which each argument&#8217;s class is defined. This rule also impacts how we determine the candidate set. Each namespace that defines a class used as an argument (and those that define its base classes) is searched for candidate functions. Any functions in those namespaces that have the same name as the called function are added to the candidate set. These functions are added <em class="calibre16">even though they otherwise are not visible at the point of the call</em>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace NS {<br class="calibre6"/>&#160;&#160;&#160;&#160;class Quote { /* ... */ };<br class="calibre6"/>&#160;&#160;&#160;&#160;void display(const Quote&amp;) { /* ... */ }<br class="calibre6"/>}<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_item'</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s base class is declared in namespace</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NS</span></span></tt></span><br class="calibre6"/>class Bulk_item : public NS::Quote { /* ... */ };<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;Bulk_item book1;<br class="calibre6"/><br class="calibre6"/>&#160;&#160;&#160;&#160;display(book1);<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The argument we passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> has class type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_item</span></tt></code>. The candidate functions for the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> are not only the functions with declarations that are in scope where <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> is called, but also the functions in the namespace where <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_item</span></tt></code> and its base class, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>, are declared. The function <code class="calibre23"><tt class="calibre23"><span class="calibre24">display(const Quote&amp;)</span></tt></code> declared in namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">NS</span></tt></code> is added to the set of candidate functions.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Declarations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To understand the interaction between <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations and overloading, it is important to remember that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration declares a name, not a specific function (&#167; <a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">15.6</a>, p. <a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">621</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using NS::print(int);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot specify a parameter list</span></span></span><br class="calibre6"/>using NS::print;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">using</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">declarations specify names only</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for a function, all the versions of that function are brought into the current scope.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration incorporates all versions to ensure that the interface of the namespace is not violated. The author of a library provided different functions for a reason. Allowing users to selectively ignore some but not all of the functions from a set of overloaded functions could lead to surprising program behavior.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5018200"/>The functions introduced by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration overload any other declarations of the functions with the same name already present in the scope where the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration appears. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration appears in a local scope, these names hide existing declarations for that name in the outer scope. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration introduces a function in a scope that already has a function of the same name with the same parameter list, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration is in error. Otherwise, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration defines additional overloaded instances of the given name. The effect is to increase the set of candidate functions.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Directives</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive lifts the namespace members into the enclosing scope. If a namespace function has the same name as a function declared in the scope at which the namespace is placed, then the namespace member is added to the overload set:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace libs_R_us {<br class="calibre6"/>&#160;&#160;&#160;&#160;extern void print(int);<br class="calibre6"/>&#160;&#160;&#160;&#160;extern void print(double);<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ordinary declaration</span></span></span><br class="calibre6"/>void print(const std::string &amp;);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">using</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">directive adds names to the candidate set for calls to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print:</span></span></tt></span><br class="calibre6"/>using namespace libs_R_us;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the candidates for calls to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">at this point in the program are:</span></span></span><br class="calibre6"/>//<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#160;&#160;&#160;print(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">libs_R_us</span></span></tt></span><br class="calibre6"/>//<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#160;&#160;&#160;print(double</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">libs_R_us</span></span></tt></span><br class="calibre6"/>//<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#160;&#160;&#160;print(const std::string &amp;</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">declared explicitly</span></span></span><br class="calibre6"/>void fooBar(int ival)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;print("Value: "); // <span><span class="calibre45"><span class="calibre16">calls global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const string &amp;)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(ival);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">libs_R_us::print(int)</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Differently from how <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations work, it is not an error if a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directive introduces a function that has the same parameters as an existing function. As with other conflicts generated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives, there is no problem unless we try to call the function without specifying whether we want the one from the namespace or from the current scope.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading across Multiple <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">using</span></span></tt></span></span></tt></code> Directives</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If many <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> directives are present, then the names from each namespace become part of the candidate set:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace AW {<br class="calibre6"/>&#160;&#160;&#160;&#160;int print(int);<br class="calibre6"/>}<br class="calibre6"/>namespace Primer {<br class="calibre6"/>&#160;&#160;&#160;&#160;double print(double);<br class="calibre6"/>}<br class="calibre6"/><a id="filepos5023699"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">using</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">directives create an overload set of functions from different namespaces</span></span></span><br class="calibre6"/>using namespace AW;<br class="calibre6"/>using namespace Primer;<br class="calibre6"/>long double print(long double);<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;print(1);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">AW::print(int)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(3.1); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Primer::print(double)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The overload set for the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> in global scope contains the functions <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(int), print(double)</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(long double)</span></tt></code>. These functions are all part of the overload set considered for the function calls in <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>, even though these functions were originally declared in different namespace scopes.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.20:</strong> In the following code, determine which function, if any, matches the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compute</span></tt></code>. List the candidate and viable functions. What type conversions, if any, are applied to the argument to match the parameter in each viable function?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">namespace primerLib {<br class="calibre6"/>&#160;&#160;&#160;&#160;void compute();<br class="calibre6"/>&#160;&#160;&#160;&#160;void compute(const void *);<br class="calibre6"/>}<br class="calibre6"/>using primerLib::compute;<br class="calibre6"/>void compute(int);<br class="calibre6"/>void compute(double, double = 3.4);<br class="calibre6"/>void compute(char*, char* = 0);<br class="calibre6"/>void f()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;compute(0);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">What would happen if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration were located in <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> before the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compute?</span></tt></code> Answer the same questions as before.</p><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="171-18.1._exception_handling.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="173-18.3._multiple_and_virtual_inheritance.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
