<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>11.3. Operations on Associative Containers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="108-11.2._overview_of_the_associative_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="110-11.4._the_unordered_containers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2776538" class="calibre29"><span class="bold">11.3. Operations on Associative Containers</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">In addition to the types listed in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>), the associative containers define the types listed in <a href="109-11.3._operations_on_associative_containers.html#filepos2777022">Table 11.3</a>. These types represent the container&#8217;s key and value types.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2777022"/>Table 11.3. Associative Container Additional Type Aliases</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00082.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">For the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> types, the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2777414" href="112-defined_terms.html#filepos2891894">key_type</a></span></span></tt></span></span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2777604" href="112-defined_terms.html#filepos2897344">value_type</a></span></span></tt></span></span></tt></code> are the same; the values held in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> are the keys. In a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, the elements are key&#8211;value pairs. That is, each element is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> object containing a key and a associated value. Because we cannot change an element&#8217;s key, the key part of these <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>s is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2778354"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">set&lt;string&gt;::value_type v1;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>set&lt;string&gt;::key_type v2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>map&lt;string, int&gt;::value_type v3; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;const string, int&gt;</span></span></tt></span><br class="calibre6"/>map&lt;string, int&gt;::key_type v4;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>map&lt;string, int&gt;::mapped_type v5; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v5</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with the sequential containers (&#167; <a href="090-9.2._container_library_overview.html#filepos2207848">9.2.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2207848">332</a>), we use the scope operator to fetch a type member&#8212;for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">map&lt;string, int&gt;::key_type</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Only the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> types (<code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_multimap</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>) define <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2780873" href="112-defined_terms.html#filepos2893651">mapped_type</a></span></span></tt></span></span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2780998" class="calibre37"><span class="calibre5">11.3.1. Associative Container Iterators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we dereference an iterator, we get a reference to a value of the container&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code>. In the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> holds the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> key and <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> holds the value:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">get an iterator to an element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word_count</span></span></tt></span><br class="calibre6"/>auto map_it = word_count.begin();<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*map_it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair&lt;const string, size_t&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>cout &lt;&lt; map_it-&gt;first;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints the key for this element</span></span></span><br class="calibre6"/>cout &lt;&lt; " " &lt;&lt; map_it-&gt;second;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints the value of the element</span></span></span><br class="calibre6"/>map_it-&gt;first = "new key";&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: key is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>++map_it-&gt;second;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: we can change the value through an iterator</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is essential to remember that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code> of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> and that we can change the value but not the key member of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Iterators for <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set</span></span></tt></span></span></tt></code>s Are <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> types define both the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> types, both types of iterators give us read-only access to the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>. Just as we cannot change the key part of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> element, the keys in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> are also <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. We can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> iterator to read, but not write, an element&#8217;s value:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">set&lt;int&gt; iset = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>set&lt;int&gt;::iterator set_it = iset.begin();<br class="calibre6"/>if (set_it != iset.end()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;*set_it = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: keys in a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are read-only</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; *set_it &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">ok: can read the key</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2786303"/>Iterating across an Associative Container</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> types provide all the <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operations from <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>). As usual, we can use these functions to obtain iterators that we can use to traverse the container. For example, we can rewrite the loop that printed the results in our word-counting program on page <a href="107-11.1._using_an_associative_container.html#filepos2725651">421</a> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">get an iterator positioned on the first element</span></span></span><br class="calibre6"/>auto map_it = word_count.cbegin();<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">compare the current iterator to the off-the-end iterator</span></span></span><br class="calibre6"/>while (map_it != word_count.cend()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">dereference the iterator to print the element key--value pairs</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; map_it-&gt;first &lt;&lt; " occurs "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; map_it-&gt;second &lt;&lt; " times" &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;++map_it;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">increment the iterator to denote the next element</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> condition and increment for the iterator in this loop look a lot like the programs we wrote that printed the contents of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We initialize an iterator, <code class="calibre23"><tt class="calibre23"><span class="calibre24">map_it</span></tt></code>, to refer to the first element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code>. As long as the iterator is not equal to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> value, we print the current element and then increment the iterator. The output statement dereferences <code class="calibre23"><tt class="calibre23"><span class="calibre24">map_it</span></tt></code> to get the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> but is otherwise the same as the one in our original program.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The output of this program is in alphabetical order. When we use an iterator to traverse a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map, multimap, set</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code>, the iterators yield elements in ascending key order.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Associative Containers and Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In general, we do not use the generic algorithms (<a href="097-chapter_10._generic_algorithms.html#filepos2454824">Chapter 10</a>) with the associative containers. The fact that the keys are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such algorithms need to write to the elements. The elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> types are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and those in <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>s are <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>s whose first element is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Associative containers can be used with the algorithms that read elements. However, many of these algorithms search the sequence. Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. For example, as we&#8217;ll see in &#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">436</a>), the associative containers define a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>, which directly fetches the element with a given key. We could use the generic <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> algorithm to look for an element, but that algorithm does a sequential search. It is much faster to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> member defined by the container than to call the generic version.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. For example, we might use the generic <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> algorithm to copy the elements from an associative container into another sequence. Similarly, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">inserter</span></tt></code> to bind an insert iterator (&#167; <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>) to an associative container. Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">inserter</span></tt></code>, we can use the associative container as a destination for another algorithm.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2792631"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.15:</strong> What are the <code class="calibre23"><tt class="calibre23"><span class="calibre24">mapped_type</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">key_type</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code> of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.16:</strong> Using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> iterator write an expression that assigns a value to an element.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.17:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s and <code class="calibre23"><tt class="calibre23"><span class="calibre24">v</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, explain the following calls. Indicate whether each call is legal:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>copy(v.begin(), v.end(), inserter(c, c.end()));<br class="calibre6"/>copy(v.begin(), v.end(), back_inserter(c));<br class="calibre6"/>copy(c.begin(), c.end(), inserter(v, v.end()));<br class="calibre6"/>copy(c.begin(), c.end(), back_inserter(v));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.18:</strong> Write the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">map_it</span></tt></code> from the loop on page <a href="109-11.3._operations_on_associative_containers.html#filepos2786303">430</a> without using <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.19:</strong> Define a variable that you initialize by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin()</span></tt></code> on the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookstore</span></tt></code> from &#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). Write the variable&#8217;s type without using <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2795913" class="calibre37"><span class="calibre5">11.3.2. Adding Elements</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> members (<a href="109-11.3._operations_on_associative_containers.html#filepos2797757">Table 11.4</a> (overleaf)) add one element or a range of elements. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> (and the corresponding unordered types) contain unique keys, inserting an element that is already present has no effect:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; ivec = {2,4,6,8,2,4,6,8};&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ivec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has eight elements</span></span></span><br class="calibre6"/>set&lt;int&gt; set2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty set</span></span></span><br class="calibre6"/>set2.insert(ivec.cbegin(), ivec.cend()); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has four elements</span></span></span><br class="calibre6"/>set2.insert({1,3,5,7,1,3,5,7});&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now has eight elements</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2797757"/>Table 11.4. Associative Container <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">insert</span></span></tt></span></span></tt></code> Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00083.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">The versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> that take a pair of iterators or an initializer list work similarly to the corresponding constructors (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">423</a>)&#8212;only the first element with a given key is inserted.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Adding Elements to a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">map</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, we must remember that the element type is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>. Often, we don&#8217;t have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> object that we want to insert. Instead, we create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> in the argument list to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">four ways to add</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word_count</span></span></tt></span><br class="calibre6"/>word_count.insert({word, 1});<br class="calibre6"/>word_count.insert(make_pair(word, 1));<br class="calibre6"/>word_count.insert(pair&lt;string, size_t&gt;(word, 1));<br class="calibre6"/>word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2800124"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, under the new standard the easiest way to create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> is to use brace initialization inside the argument list. Alternatively, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_pair</span></tt></code>
<a id="filepos2800508"/>or explicitly construct the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>. The argument in the last call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">map&lt;string, size_t&gt;::value_type(s, 1)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">constructs a new object of the appropriate <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> type to insert into the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Testing the Return from <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">insert</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace</span></tt></code>) depends on the container type and the parameters. For the containers that have unique keys, the versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace</span></tt></code> that add a single element return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> that lets us know whether the insertion happened. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> is an iterator to the element with the given key; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether that element was inserted, or was already there. If the key is already in the container, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> does nothing, and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> portion of the return value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. If the key isn&#8217;t present, then the element is inserted and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll rewrite our word-counting program to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">more verbose way to count number of times each word occurs in the input</span></span></span><br class="calibre6"/>map&lt;string, size_t&gt; word_count; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">map</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from string to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size_t</span></span></tt></span><br class="calibre6"/>string word;<br class="calibre6"/>while (cin &gt;&gt; word) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">inserts an element with key equal to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is already in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word_count</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">insert</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">does nothing</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret = word_count.insert({word, 1});<br class="calibre6"/>&#160;&#160;&#160;&#160;if (!ret.second)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">was already in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word_count</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++ret.first-&gt;second; // <span><span class="calibre45"><span class="calibre16">increment the counter</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For each <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code>, we attempt to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> it with a value <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> is already in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, then nothing happens. In particular, the counter associated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> is <a id="filepos2806248"/>unchanged. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> is not already in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, then that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is added to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and its counter value is set to 1.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> test examines the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> part of the return value. If that value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>, then the insertion didn&#8217;t happen. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> was already in <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code>, so we must increment the value associated with that element.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Unwinding the Syntax</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The statement that increments the counter in this version of the word-counting program can be hard to understand. It will be easier to understand that expression by first parenthesizing it to reflect the precedence (&#167; <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>) of the operators:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">++((ret.first)-&gt;second); // <span><span class="calibre45"><span class="calibre16">equivalent expression</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Explaining this expression step by step:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ret</span></span></tt></span></span></tt></code> holds the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>, which is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ret.first</span></span></tt></span></span></tt></code> is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>, which is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> iterator referring to the element with the given key.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ret.first-&gt;</span></span></tt></span></span></tt></code> dereferences that iterator to fetch that element. Elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> are also <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>s.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ret.first-&gt;second</span></span></tt></span></span></tt></code> is the value part of the map element <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">++ret.first-&gt;second</span></span></tt></span></span></tt></code> increments that value.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Putting it back together, the increment statement fetches the iterator for the element with the key <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> and increments the counter associated with the key we tried to insert.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For readers using an older compiler or reading code that predates the new standard, declaring and initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code> is also somewhat tricky:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pair&lt;map&lt;string, size_t&gt;::iterator, bool&gt; ret =<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word_count.insert(make_pair(word, 1));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">It should be easy to see that we&#8217;re defining a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> and that the second type of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. The first type of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> is a bit harder to understand. It is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> type defined by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map&lt;string, size_t&gt;</span></tt></code> type.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Adding Elements to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">multiset</span></span></tt></span></span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">multimap</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word. Sometimes, we want to be able to add additional elements with the same key. For example, we might want to map authors to titles of the books they have written. In this case, there might be multiple entries for each author, so we&#8217;d use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> rather than a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. Because keys in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multi</span></tt></code> container need not be unique, <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> on these types always inserts an element:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2813196"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">multimap&lt;string, string&gt; authors;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">adds the first element with the key</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Barth, John</span></span></tt></span><br class="calibre6"/>authors.insert({"Barth, John", "Sot-Weed Factor"});<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: adds the second element with the key</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Barth, John</span></span></tt></span><br class="calibre6"/>authors.insert({"Barth, John", "Lost in the Funhouse"});</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For the containers that allow multiple keys, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> operation that takes a single element returns an iterator to the new element. There is no need to return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> always adds a new element in these types.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.20:</strong> Rewrite the word-counting program from &#167; <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a> (p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>) to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> instead of subscripting. Which program do you think is easier to write and read? Explain your reasoning.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.21:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, explain the following loop:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;++word_count.insert({word, 0}).first-&gt;second;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.22:</strong> Given a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map&lt;string, vector&lt;int&gt;&gt;</span></tt></code>, write the types used as an argument and as the return value for the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> that inserts one element.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.23:</strong> Rewrite the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> that stored <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s of children&#8217;s names with a key that is the family last name for the exercises in &#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">424</a>) to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2817032" class="calibre37"><span class="calibre5">11.3.3. Erasing Elements</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The associative containers define three versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>, which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2817959">Table 11.5</a>. As with the sequential containers, we can <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> one element or a range of elements by passing <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> an iterator or an iterator pair. These versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2817959"/>Table 11.5. Removing Elements from an Associative Container</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00084.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The associative containers supply an additional <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> operation that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">key_type</span></tt></code> argument. This version removes all the elements, if any, with the given key and returns a count of how many elements were removed. We can use this version to remove a specific word from <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code> before printing the results:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">erase</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on a key returns the number of elements removed</span></span></span><br class="calibre6"/>if (word_count.erase(removal_word))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "ok: " &lt;&lt; removal_word &lt;&lt; " removed\n";<br class="calibre6"/>else cout &lt;&lt; "oops: " &lt;&lt; removal_word &lt;&lt; " not found!\n";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For the containers with unique keys, the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> is always either zero or one. If the return value is zero, then the element we wanted to erase was not in the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2819746"/>For types that allow multiple keys, the number of elements removed could be greater than one:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto cnt = authors.erase("Barth, John");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">authors</span></tt></code> is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> we created in &#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2795913">11.3.2</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2795913">434</a>), then <code class="calibre23"><tt class="calibre23"><span class="calibre24">cnt</span></tt></code> will be 2.</p><div class="calibre15">&#160;</div>
<h4 id="filepos2820595" class="calibre37"><span class="calibre5">11.3.4. Subscripting a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">map</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code> containers provide the subscript operator and a corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code> function (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2294924">9.3.2</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2294924">348</a>), which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2822041">Table 11.6</a> (overleaf). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> types do not support subscripting because there is no &#8220;value&#8221; associated with a key in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>. The elements are themselves keys, so the operation of &#8220;fetching the value associated with a key&#8221; is meaningless. We cannot subscript a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> or an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_multimap</span></tt></code> because there may be more than one value associated with a given key.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2822041"/>Table 11.6. Subscript Operation for <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">map</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unordered_map</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00085.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Like the other subscript operators we&#8217;ve used, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> subscript takes an index (that is, a key) and fetches the value associated with that key. However, unlike other subscript operators, if the key is not already present, <em class="calibre16">a new element is created and inserted</em> into the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> for that key. The associated value is value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, when we write</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">map &lt;string, size_t&gt; word_count; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">map</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">insert a value-initialized element with key</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Anna</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; then assign</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to its value</span></span></span><br class="calibre6"/>word_count["Anna"] = 1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the following steps take place:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code> is searched for the element whose key is <code class="calibre23"><tt class="calibre23"><span class="calibre24">Anna</span></tt></code>. The element is not found.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A new key-value pair is inserted into <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code>. The key is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code> holding <code class="calibre23"><tt class="calibre23"><span class="calibre24">Anna</span></tt></code>. The value is value initialized, meaning in this case that the value is 0.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The newly inserted element is fetched and is given the value 1.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a/>Because the subscript operator might insert an element, we may use subscript only on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> that is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Subscripting a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> behaves quite differently from subscripting an array or <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector:</span></tt></code> Using a key that is not already present <em class="calibre16">adds</em> an element with that key to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Value Returned from a Subscript Operation</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Another way in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> subscript differs from other subscript operators we&#8217;ve used is its return type. Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. Not so for <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>s: when we subscript a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, we get a <code class="calibre23"><tt class="calibre23"><span class="calibre24">mapped_type</span></tt></code> object; when we dereference a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> iterator, we get a <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code> object (&#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">11.3</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">428</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">In common with other subscripts, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> subscript operator returns an lvalue (&#167; <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>). Because the return is an lvalue, we can read or write the element:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; word_count["Anna"]; // <span><span class="calibre45"><span class="calibre16">fetch the element indexed by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Anna</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>++word_count["Anna"];&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">fetch the element and add</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to it</span></span></span><br class="calibre6"/>cout &lt;&lt; word_count["Anna"]; // <span><span class="calibre45"><span class="calibre16">fetch the element and print it; prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, the type returned by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> subscript operator differs from the type obtained by dereferencing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> iterator.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The fact that the subscript operator adds an element if it is not already in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> allows us to write surprisingly succinct programs such as the loop inside our word-counting program (&#167; <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a>, p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>). On the other hand, sometimes we only want to know whether an element is present and <em class="calibre16">do not</em> want to add the element if it is not. In such cases, we must not use the subscript operator.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2829910" class="calibre37"><span class="calibre5">11.3.5. Accessing Elements</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The associative containers provide various ways to find a given element, which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">Table 11.7</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">438</a>). Which operation to use depends on what problem we are trying to solve. If all we care about is whether a particular element is in the container, it is probably best to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>. For the containers that can hold only unique keys, it probably doesn&#8217;t matter whether we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code>. However, for the containers with multiple keys, <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> has to do more work: If the element is present, it still has to count how many elements have the same key. If we don&#8217;t need the count, it&#8217;s best to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2831111"/>Table 11.7. Operations to Find Elements in an Associative Container</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00086.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2831331"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.3.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.24:</strong> What does the following program do?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>map&lt;int, int&gt; m;<br class="calibre6"/>m[0] = 1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.25:</strong> Contrast the following program with the one in the previous exercise</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>vector&lt;int&gt; v;<br class="calibre6"/>v[0] = 1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.26:</strong> What type can be used to subscript a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>? What type does the subscript operator return? Give a concrete example&#8212;that is, define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and then write the types that can be used to subscript the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and the type that would be returned from the subscript operator.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">set&lt;int&gt; iset = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>iset.find(1);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns an iterator that refers to the element with key</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">== 1</span></span></tt></span><br class="calibre6"/>iset.find(11);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns the iterator</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">== iset.end()</span></span></tt></span><br class="calibre6"/>iset.count(1);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>iset.count(11); // <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find</span></span></tt></span></span></tt></code> Instead of Subscript for <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">map</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">For the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code> types, the subscript operator provides the simplest method of retrieving a value. However, as we&#8217;ve just seen, using a subscript has an important side effect: If that key is not already in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, then subscript inserts an element with that key. Whether this behavior is correct depends on our expectations. Our word-counting programs relied on the fact that using a nonexistent key as a subscript inserts an element with that key and value 0.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Sometimes, we want to know if an element with a given key is present without changing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. We cannot use the subscript operator to determine whether an element is present, because the subscript operator inserts a new element if the key is not already there. In such cases, we should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (word_count.find("foobar") == word_count.end())<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; "foobar is not in the map" &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Finding Elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">multimap</span></span></tt></span></span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">multiset</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Finding an element in an associative container that requires unique keys is a simple matter&#8212;the element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the given key. When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> has multiple elements of a given key, those elements will be adjacent within the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2836897"/>For example, given our map from author to titles, we might want to print all the books by a particular author. We can solve this problem in three different ways. The most obvious way uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string search_item("Alain de Botton"); // <span><span class="calibre45"><span class="calibre16">author we'll look for</span></span></span><br class="calibre6"/>auto entries = authors.count(search_item); // <span><span class="calibre45"><span class="calibre16">number of elements</span></span></span><br class="calibre6"/>auto iter = authors.find(search_item); // <span><span class="calibre45"><span class="calibre16">first entry for this author</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">loop through the number of entries there are for this author</span></span></span><br class="calibre6"/>while(entries) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; iter-&gt;second &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print each title</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++iter;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance to the next title</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;--entries;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">keep track of how many we've printed</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by determining how many entries there are for the author by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> and getting an iterator to the first element with this key by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>. The number of iterations of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop depends on the number returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code>. In particular, if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> was zero, then the loop is never executed.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We are guaranteed that iterating across a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> returns all the elements with a given key in sequence.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Different, Iterator-Oriented Solution</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Alternatively, we can solve our problem using <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code>. Each of these operations take a key and returns an iterator. If the key is in the container, the iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> will refer to the first instance of that key and the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> will refer just after the last instance of the key. If the element is not in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> will return equal iterators; both will refer to the point at which the key can be inserted without disrupting the order. Thus, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> on the same key yields an iterator range (&#167; <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>) that denotes all the elements with that key.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2841351"/>Of course, the iterator returned from these operations might be the off-the-end iterator for the container itself. If the element we&#8217;re looking for has the largest key in the container, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> on that key returns the off-the-end iterator. If the key is not present and is larger than any key in the container, then the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> will also be the off-the-end iterator.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> may or may not refer to an element with the given key. If the key is not in the container, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> refers to the first point at which this key can be inserted while preserving the element order within the container.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Using these operations, we can rewrite our program as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">definitions of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">authors</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">search_item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as above</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">beg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">end</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denote the range of elements for this author</span></span></span><br class="calibre6"/>for (auto beg = authors.lower_bound(search_item),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end = authors.upper_bound(search_item);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;beg != end; ++beg)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; beg-&gt;second &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print each title</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program does the same work as the previous one that used <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> but accomplishes its task more directly. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> positions <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> so that it refers to the first element matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">search_item</span></tt></code> if there is one. If there is no such element, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> refers to the first element with a key larger than <code class="calibre23"><tt class="calibre23"><span class="calibre24">search_item</span></tt></code>, which could be the off-the-end iterator. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> sets <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> to refer to the element just beyond the last element with the given key. These operations say nothing about whether the key is present. The important point is that the return values act like an iterator range (&#167; <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">If there is no element for this key, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> will be equal. Both will refer to the point at which this key can be inserted while maintaining the container order.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Assuming there are elements with this key, <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> will refer to the first such element. We can increment <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> to traverse the elements with this key. The iterator in <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> will signal when we&#8217;ve seen all the elements. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> equals <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, we have seen every element with this key.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because these iterators form a range, we can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop to traverse that range. The loop is executed zero or more times and prints the entries, if any, for the given author. If there are no elements, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> are equal and the loop is never executed. Otherwise, we know that the increment to <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> will eventually reach <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> and that in the process we will print each record associated with this author.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> return the same iterator, then the given key is not in the container.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal_range</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The remaining way to solve this problem is the most direct of the three approaches: Instead of calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code>, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_range</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2848488"/>This function takes a key and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> of iterators. If the key is present, then the first iterator refers to the first instance of the key and the second iterator refers one past the last instance of the key. If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_range</span></tt></code> to modify our program once again:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">definitions of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">authors</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">search_item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as above</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pos</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds iterators that denote the range of elements for this key</span></span></span><br class="calibre6"/>for (auto pos = authors.equal_range(search_item);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;pos.first != pos.second; ++pos.first)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print each title</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program is essentially identical to the previous one that used <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code>. Instead of using local variables, <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, to hold the iterator range, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_range</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> holds the same iterator as <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code> would have returned and <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> holds the iterator <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> would have returned. Thus, in this program <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos.first</span></tt></code> is equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos.second</span></tt></code> is equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.3.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.27:</strong> What kinds of problems would you use <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> to solve? When might you use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> instead?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.28:</strong> Define and initialize a variable to hold the result of calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.29:</strong> What do <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_range</span></tt></code> return when you pass them a key that is not in the container?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.30:</strong> Explain the meaning of the operand <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos.first-&gt;second</span></tt></code> used in the output expression of the final program in this section.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.31:</strong> Write a program that defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> of authors and their works. Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> to find an element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> that element. Be sure your program works correctly if the element you look for is not in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.32:</strong> Using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multimap</span></tt></code> from the previous exercise, write a program to print the list of authors and their works alphabetically.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2854545" class="calibre37"><span class="calibre5">11.3.6. A Word Transformation Map</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;ll close this section with a program to illustrate creating, searching, and iterating across a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. We&#8217;ll write a program that, given one <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, transforms it into another. The input to our program is two files. The first file contains rules that we will use to transform the text in the second file. Each rule consists of a word that might be in the input file and a phrase to use in its place. The idea is that whenever the first word appears in the input, we will replace it with the corresponding phrase. The second file contains the text to transform.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2855442"/>If the contents of the word-transformation file are</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">brb be right back</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">k okay?</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">y why</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">r are</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">u you</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">pic picture</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">thk thanks!</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">l8r later</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">and the text we are given to transform is</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">where r u</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">y dont u send me a pic</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">k thk l8r</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">then the program should generate the following output:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">where are you</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">why dont you send me a picture</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">okay? thanks! later</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Word Transformation Program</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Our solution will use three functions. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_transform</span></tt></code> function will manage the overall processing. It will take two <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> arguments: The first will be bound to the word-transformation file and the second to the file of text we&#8217;re to transform. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">buildMap</span></tt></code> function will read the file of transformation rules and create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> from each word to its transformation. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> function will take a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and return the transformation if there is one.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We&#8217;ll start by defining the <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_transform</span></tt></code> function. The important parts are the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">buildMap</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void word_transform(ifstream &amp;map_file, ifstream &amp;input)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto trans_map = buildMap(map_file); // <span><span class="calibre45"><span class="calibre16">store the transformations</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;string text;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hold each line from the input</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;while (getline(input, text)) {&#160;&#160;// <span><span class="calibre45"><span class="calibre16">read a line of input</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;istringstream stream(text); // <span><span class="calibre45"><span class="calibre16">read each word</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string word;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bool firstword = true;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">controls whether a space is printed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while (stream &gt;&gt; word) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (firstword)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;firstword = false;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; " ";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print a space between words</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">transform</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns its first argument or its transformation</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; transform(word, trans_map); // <span><span class="calibre45"><span class="calibre16">print the output</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">done with this line of input</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2861431"/>The function starts by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">buildMap</span></tt></code> to generate the word-transformation <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. We store the result in <code class="calibre23"><tt class="calibre23"><span class="calibre24">trans_map</span></tt></code>. The rest of the function processes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">input</span></tt></code> file. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> loop uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">getline</span></tt></code> to read the input file a line at a time. We read by line so that our output will have line breaks at the same position as in the input file. To get the words from each line, we use a nested <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> loop that uses an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istringstream</span></tt></code> (&#167; <a href="085-8.3._string_streams.html#filepos2143868">8.3</a>, p. <a href="085-8.3._string_streams.html#filepos2143868">321</a>) to process each word in the current line.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The inner <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> prints the output using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool firstword</span></tt></code> to determine whether to print a space. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> obtains the word to print. The value returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> is either the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> or its corresponding transformation from <code class="calibre23"><tt class="calibre23"><span class="calibre24">trans_map</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Building the Transformation Map</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">buildMap</span></tt></code> function reads its given file and builds the transformation <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">map&lt;string, string&gt; buildMap(ifstream &amp;map_file)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;map&lt;string, string&gt; trans_map;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">holds the transformations</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;string key;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a word to transform</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;string value;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">phrase to use instead</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">read the first word into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">key</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and the rest of the line into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">value</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;while (map_file &gt;&gt; key &amp;&amp; getline(map_file, value))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (value.size() &gt; 1) // <span><span class="calibre45"><span class="calibre16">check that there is a transformation</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;trans_map[key] = value.substr(1); // <span><span class="calibre45"><span class="calibre16">skip leading space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw runtime_error("no rule for " + key);<br class="calibre6"/>&#160;&#160;&#160;&#160;return trans_map;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each line in <code class="calibre23"><tt class="calibre23"><span class="calibre24">map_file</span></tt></code> corresponds to a rule. Each rule is a word followed by a phrase, which might contain multiple words. We use <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> to read the word that we will transform into <code class="calibre23"><tt class="calibre23"><span class="calibre24">key</span></tt></code> and call <code class="calibre23"><tt class="calibre23"><span class="calibre24">getline</span></tt></code> to read the rest of the line into <code class="calibre23"><tt class="calibre23"><span class="calibre24">value</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">getline</span></tt></code> does not skip leading spaces (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">87</a>), we need to skip the space between the word and its corresponding rule. Before we store the transformation, we check that we got more than one character. If so, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">substr</span></tt></code> (&#167; <a href="093-9.5._additional_string_operations.html#filepos2374493">9.5.1</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2374493">361</a>) to skip the space that separated the transformation phrase from its corresponding word and store that substring in <code class="calibre23"><tt class="calibre23"><span class="calibre24">trans_map</span></tt></code>,</p><div class="calibre15">&#160;</div>
<p class="calibre25">Note that we use the subscript operator to add the key&#8211;value pairs. Implicitly, we are ignoring what should happen if a word appears more than once in our transformation file. If a word does appear multiple times, our loops will put the last corresponding phrase into <code class="calibre23"><tt class="calibre23"><span class="calibre24">trans_map</span></tt></code>. When the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> concludes, <code class="calibre23"><tt class="calibre23"><span class="calibre24">trans_map</span></tt></code> contains the data that we need to transform the input.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Generating a Transformation</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> function does the actual transformation. Its parameters are references to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to transform and to the transformation <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. If the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> returns the corresponding transformation. If the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is not in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> returns its argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2868525"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const string &amp;<br class="calibre6"/>transform(const string &amp;s, const map&lt;string, string&gt; &amp;m)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the actual</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">map</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">work; this part is the heart of the program</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto map_it = m.find(s);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if this word is in the transformation map</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (map_it != m.cend())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return map_it-&gt;second; // <span><span class="calibre45"><span class="calibre16">use the replacement word</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">otherwise return the original unchanged</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> to determine whether the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. If it is, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> returns an iterator to the corresponding element. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> returns the off-the-end iterator. If the element is found, we dereference the iterator, obtaining a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> that holds the key and value for that element (&#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">11.3</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">428</a>). We return the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> member, which is the transformation to use in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.3.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.33:</strong> Implement your own version of the word-transformation program.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.34:</strong> What would happen if we used the subscript operator instead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> function?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.35:</strong> In <code class="calibre23"><tt class="calibre23"><span class="calibre24">buildMap</span></tt></code>, what effect, if any, would there be from rewriting</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>&#160;&#160;&#160;&#160;trans_map[key] = value.substr(1);<br class="calibre6"/>as trans_map.insert({key, value.substr(1)})?</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.36:</strong> Our program does no checking on the validity of either input file. In particular, it assumes that the rules in the transformation file are all sensible. What would happen if a line in that file has a key, one space, and then the end of the line? Predict the behavior and then check it against your version of the program.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="108-11.2._overview_of_the_associative_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="110-11.4._the_unordered_containers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
