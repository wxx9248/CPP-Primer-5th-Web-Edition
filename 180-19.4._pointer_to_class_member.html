<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.4. Pointer to Class Member</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="179-19.3._enumerations.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="181-19.5._nested_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5224528" class="calibre29"><span class="bold">19.4. Pointer to Class Member</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos5224670" href="186-defined_terms.html#filepos5406339">pointer to member</a></strong> is a pointer that can point to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member of a class. Normally a pointer points to an object, but a pointer to member identifies a member of a class, not an object of that class. <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> class members are not part of any object, so no special syntax is needed to point to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member. Pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members are ordinary pointers.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The type of a pointer to member embodies both the type of a class and the type of a member of that class. We initialize such pointers to point to a specific member of a class without identifying an object to which that member belongs. When we use a pointer to member, we supply the object whose member we wish to use.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5225785"/>To explain pointers to members, we&#8217;ll use a version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class from &#167; <a href="075-7.3._additional_class_features.html#filepos1852806">7.3.1</a> (p. <a href="075-7.3._additional_class_features.html#filepos1852806">271</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::string::size_type pos;<br class="calibre6"/>&#160;&#160;&#160;&#160;char get_cursor() const { return contents[cursor]; }<br class="calibre6"/>&#160;&#160;&#160;&#160;char get() const;<br class="calibre6"/>&#160;&#160;&#160;&#160;char get(pos ht, pos wd) const;<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string contents;<br class="calibre6"/>&#160;&#160;&#160;&#160;pos cursor;<br class="calibre6"/>&#160;&#160;&#160;&#160;pos height, width;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 id="filepos5226766" class="calibre37"><span class="calibre5">19.4.1. Pointers to Data Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with any pointer, we declare a pointer to member using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> to indicate that the name we&#8217;re declaring is a pointer. Unlike ordinary pointers, a pointer to member also incorporates the class that contains the member. Hence, we must precede the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> with <em class="calibre16">classname</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">::</span></tt></code> to indicate that the pointer we are defining can point to a member of <em class="calibre16">classname</em>. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pdata</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can point to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(or non</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>) <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>const string Screen::*pdata;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">declares that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> is a &#8220;pointer to a member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>.&#8221; The data members in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object are themselves <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. By making our pointer a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code> member, we say that we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> to point to a member of any <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> object, <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or not. In exchange we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> to read, but not write to, the member to which it points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we initialize (or assign to) a pointer to member, we say to which member it points. For example, we can make <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member of an unspecified <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> object as follows:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pdata = &amp;Screen::contents;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we apply the address-of operator not to an object in memory but to a member of the class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Of course, under the new standard, the easiest way to declare a pointer to member is to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto pdata = &amp;Screen::contents;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Pointer to Data Member</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is essential to understand that when we initialize or assign a pointer to member, that pointer does not yet point to any data. It identifies a specific member but not the object that contains that member. We supply the object when we dereference the pointer to member.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos5231349"/>Analogous to the member access operators, <code class="calibre23"><tt class="calibre23"><span class="calibre24">.</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code>, there are two pointer-to-member access operators, <code class="calibre23"><tt class="calibre23"><span class="calibre24">.*</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;*</span></tt></code>, that let us supply an object and dereference the pointer to fetch a member of that object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen, *pScreen = &amp;myScreen;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">.* dereferences</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pdata</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to fetch the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member from the object</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen</span></span></tt></span><br class="calibre6"/>auto s = myScreen.*pdata;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">-&gt;* dereferences</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pdata</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to fetch</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pScreen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>s = pScreen-&gt;*pdata;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Conceptually, these operators perform two actions: They dereference the pointer to member to get the member that we want; then, like the member access operators, they fetch that member from an object (<code class="calibre23"><tt class="calibre23"><span class="calibre24">.*</span></tt></code>) or through a pointer (<code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;*</span></tt></code>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Function Returning a Pointer to Data Member</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Normal access controls apply to pointers to members. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>. As a result, the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> above must have been inside a member or friend of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> or it would be an error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because data members are typically <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, we normally can&#8217;t get a pointer to data member directly. Instead, if a class like <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> wanted to allow access to its <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member, it would define a function to return a pointer to that member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member that returns a pointer to member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;static const std::string Screen::*data()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return &amp;Screen::contents; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve added a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member to class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that returns a pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. The return type of this function is the same type as our original <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> pointer. Reading the return type from right to left, we see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> returns a pointer to a member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. The body of the function applies the address-of operator to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member, so the function returns a pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code>, we get a pointer to member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">data(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">returns a pointer to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of class</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>const string Screen::*pdata = Screen::data();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As before, <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code> points to a member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> but not to actual data. To use <code class="calibre23"><tt class="calibre23"><span class="calibre24">pdata</span></tt></code>, we must bind it to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">fetch the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of the object named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen</span></span></tt></span><br class="calibre6"/>auto s = myScreen.*pdata;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos5239160"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.4.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.11:</strong> What is the difference between an ordinary data pointer and a pointer to a data member?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.12:</strong> Define a pointer to member that can point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cursor</span></tt></code> member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Fetch the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen::cursor</span></tt></code> through that pointer.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.13:</strong> Define the type that can represent a pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos5240360" class="calibre37"><span class="calibre5">19.4.2. Pointers to Member Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We can also define a pointer that can point to a member function of a class. As with pointers to data members, the easiest way to form a pointer to member function is to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to deduce the type for us:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pmf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer that can point to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member function that is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">that returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and takes no arguments</span></span></span><br class="calibre6"/>auto pmf = &amp;Screen::get_cursor;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like a pointer to data member, a pointer to a function member is declared using <em class="calibre16">classname</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">::*</span></tt></code>. Like any other function pointer (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>), a pointer to member function specifies the return type and parameter list of the type of function to which this pointer can point. If the member function is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>) or a reference member (&#167; <a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a>, p. <a href="126-13.6._moving_objects.html#filepos3505762">546</a>), we must include the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference qualifier as well.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with normal function pointers, if the member is overloaded, we must distinguish which function we want by declaring the type explicitly (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">248</a>). For example, we can declare a pointer to the two-parameter version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char (Screen::*pmf2)(Screen::pos, Screen::pos) const;<br class="calibre6"/>pmf2 = &amp;Screen::get;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen::*</span></tt></code> in this declaration are essential due to precedence. Without the parentheses, the compiler treats the following as an (invalid) function declaration:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: nonmember function</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">cannot have a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">qualifier</span></span></span><br class="calibre6"/>char Screen::*p(Screen::pos, Screen::pos) const;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This declaration tries to define an ordinary function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> that returns a pointer to a member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. Because it declares an ordinary function, the declaration can&#8217;t be followed by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualifier.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike ordinary function pointers, there is no automatic conversion between a member function and a pointer to that member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pmf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member that takes no arguments and returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span><br class="calibre6"/>pmf = &amp;Screen::get; // <span><span class="calibre45"><span class="calibre16">must explicitly use the address-of operator</span></span></span><br class="calibre6"/>pmf = Screen::get;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no conversion to pointer for member functions</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5246229"/>Using a Pointer to Member Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As when we use a pointer to a data member, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">.*</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;*</span></tt></code> operators to call a member function through a pointer to member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen,*pScreen = &amp;myScreen;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">call the function to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pmf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points on the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pScreen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>char c1 = (pScreen-&gt;*pmf)();<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">passes the arguments</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0, 0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the two-parameter version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on the object</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen</span></span></tt></span><br class="calibre6"/>char c2 = (myScreen.*pmf2)(0, 0);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">(myScreen-&gt;*pmf)()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">(pScreen.*pmf2)(0,0)</span></tt></code> require the parentheses because the precedence of the call operator is higher than the precedence of the pointer to member operators.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Without the parentheses,</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">myScreen.*pmf()</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">would be interpreted to mean</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">myScreen.*(pmf())</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code says to call the function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">pmf</span></tt></code> and use its return value as the operand of the pointer-to-member operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">.*</span></tt></code>). However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">pmf</span></tt></code> is not a function, so this code is in error.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because of the relative precedence of the call operator, declarations of pointers to member functions and calls through such pointers must use parentheses: <code class="calibre23"><tt class="calibre23"><span class="calibre24">(C::*p)(parms)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">(obj.*p)(args)</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Type Aliases for Member Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Type aliases or <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code>s (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) make pointers to members considerably easier to read. For example, the following type alias defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">Action</span></tt></code> as an alternative name for the type of the two-parameter version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Action</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a type that can point to a member function of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">that returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and takes two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pos</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">arguments</span></span></span><br class="calibre6"/>using Action =<br class="calibre6"/>char (Screen::*)(Screen::pos, Screen::pos) const;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">Action</span></tt></code> is another name for the type &#8220;pointer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> taking two parameters of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> and returning <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>.&#8221; Using this alias, we can simplify the definition of a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Action get = &amp;Screen::get; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">As with any other function pointer, we can use a pointer-to-member function type as the return type or as a parameter type in a function. Like any other parameter, a pointer-to-member parameter can have a default argument:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">action</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">takes a reference to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and a pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member function</span></span></span><br class="calibre6"/>Screen&amp; action(Screen&amp;, Action = &amp;Screen::get);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos5254029"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">action</span></tt></code> is a function taking two parameters, which are a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> object and a pointer to a member function of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> parameters and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. We can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">action</span></tt></code> by passing it either a pointer or the address of an appropriate member function in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">equivalent calls:</span></span></span><br class="calibre6"/>action(myScreen);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the default argument</span></span></span><br class="calibre6"/>action(myScreen, get); // <span><span class="calibre45"><span class="calibre16">uses the variable</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that we previously defined</span></span></span><br class="calibre6"/>action(myScreen, &amp;Screen::get); // <span><span class="calibre45"><span class="calibre16">passes the address explicitly</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Type aliases make code that uses pointers to members much easier to read and write.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer-to-Member Function Tables</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One common use for function pointers and for pointers to member functions is to store them in a function table (&#167; <a href="137-14.8._functioncall_operator.html#filepos3690557">14.8.3</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3690557">577</a>). For a class that has several members of the same type, such a table can be used to select one from the set of these members. Let&#8217;s assume that our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class is extended to contain several member functions, each of which moves the cursor in a particular direction:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other interface and implementation members as before</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; home();&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">cursor movement functions</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; forward();<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; back();<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; up();<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; down();<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each of these new functions takes no parameters and returns a reference to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> on which it was invoked.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We might want to define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> function that can call any one of these functions and perform the indicated action. To support this new function, we&#8217;ll add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> that will be an array of pointers to the cursor movement functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other interface and implementation members as before</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Action</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer that can be assigned any of the cursor movement members</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;using Action = Screen&amp; (Screen::*)();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">specify which direction to move;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">enum</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">see &#167; 19.3 (p. 832)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;enum Directions { HOME, FORWARD, BACK, UP, DOWN };<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; move(Directions);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;static Action Menu[];&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function table</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos5259845"/>The array named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Menu</span></tt></code> will hold pointers to each of the cursor movement functions. Those functions will be stored at the offsets corresponding to the enumerators in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Directions</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> function takes an enumerator and calls the appropriate function:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen&amp; Screen::move(Directions cm)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">run the element indexed by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cm</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">this</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return (this-&gt;*Menu[cm])(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Menu[cm]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a member function</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is evaluated as follows: The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Menu</span></tt></code> element indexed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">cm</span></tt></code> is fetched. That element is a pointer to a member function of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class. We call the member function to which that element points on behalf of the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we pass it an enumerator that indicates which direction to move the cursor:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen;<br class="calibre6"/>myScreen.move(Screen::HOME);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">invokes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen.home</span></span></tt></span><br class="calibre6"/>myScreen.move(Screen::DOWN);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">invokes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen.down</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">What&#8217;s left is to define and initialize the table itself:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen::Action Screen::Menu[] = { &amp;Screen::home,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;Screen::forward,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;Screen::back,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;Screen::up,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;Screen::down,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.4.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.14:</strong> Is the following code legal? If so, what does it do? If not, why?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto pmf = &amp;Screen::get_cursor;<br class="calibre6"/>pmf = &amp;Screen::get;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.15:</strong> What is the difference between an ordinary function pointer and a pointer to a member function?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.16:</strong> Write a type alias that is a synonym for a pointer that can point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">avg_price</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.17:</strong> Define a type alias for each distinct <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> member function type.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos5266018" class="calibre37"><span class="calibre5">19.4.3. Using Member Functions as Callable Objects</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, to make a call through a pointer to member function, we must use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">.*</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;*</span></tt></code> operators to bind the pointer to a specific object. As a result, <a id="filepos5266464"/>unlike ordinary function pointers, a pointer to member is <em class="calibre16">not</em> a callable object; these pointers do not support the function-call operator (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because a pointer to member is not a callable object, we cannot directly pass a pointer to a member function to an algorithm. As an example, if we wanted to find the first empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, the obvious call won&#8217;t work:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto fp = &amp;string::empty;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string empty</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: must use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">.*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-&gt;*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call a pointer to member</span></span></span><br class="calibre6"/>find_if(svec.begin(), svec.end(), fp);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> algorithm expects a callable object, but we&#8217;ve supplied <code class="calibre23"><tt class="calibre23"><span class="calibre24">fp</span></tt></code>, which is a pointer to a member function. This call won&#8217;t compile, because the code inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> executes a statement something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">check whether the given predicate applied to the current element yields</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><br class="calibre6"/>if (fp(*it))&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: must use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-&gt;*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call through a pointer to member</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">which attempts to call the object it was passed.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code> to Generate a Callable</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One way to obtain a callable from a pointer to member function is by using the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> template (&#167; <a href="137-14.8._functioncall_operator.html#filepos3690557">14.8.3</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3690557">577</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty;<br class="calibre6"/>find_if(svec.begin(), svec.end(), fcn);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we tell <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> that <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code> is a function that can be called with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. Ordinarily, the object on which a member function executes is passed to the implicit <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> parameter. When we want to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> to generate a callable for a member function, we have to &#8220;translate&#8221; the code to make that implicit parameter explicit.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> object holds a pointer to a member function, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> class knows that it must use the appropriate pointer-to-member operator to make the call. That is, we can imagine that <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> will have code something like</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">assuming</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the iterator inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">find_if</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, so</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an object in the given range</span></span></span><br class="calibre6"/>if (fcn(*it))&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assuming</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the name of the callable inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">find_if</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">which <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> will execute using the proper pointer-to-member operator. In essence, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> class will transform this call into something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">assuming</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the iterator inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">find_if</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><span class="calibre45"><span class="calibre16">so</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an object in the given range</span></span></span><br class="calibre6"/>if (((*it).*p)()) // <span><span class="calibre45"><span class="calibre16">assuming</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the pointer to member function inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">When we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> object, we must specify the function type that is the signature of the callable objects that object can represent. When the callable is a member function, the signature&#8217;s first parameter must represent the (normally implicit) object on which the member will be run. The signature we give to <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> must specify whether the object will be passed as a pointer or a reference.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code>, we knew that we wanted to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> on a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> objects. Hence, we asked <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> to generate a callable that took <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> objects. Had our <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> held pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we would have told <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> to expect a pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5276101"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string*&gt; pvec;<br class="calibre6"/>function&lt;bool (const string*)&gt; fp = &amp;string::empty;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">takes a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-&gt;*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span><br class="calibre6"/>find_if(pvec.begin(), pvec.end(), fp);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">mem_fn</span></span></tt></span></span></tt></code> to Generate a Callable</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos5277269"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">To use <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>, we must supply the call signature of the member we want to call. We can, instead, let the compiler deduce the member&#8217;s type by using another library facility, <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5277688" href="186-defined_terms.html#filepos5403163">mem_fn</a></span></span></tt></span></span></tt></code>, which, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>, is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">function, mem_fn</span></tt></code> generates a callable object from a pointer to member. Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">function, mem_fn</span></tt></code> will deduce the type of the callable from the type of the pointer to member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">find_if(svec.begin(), svec.end(), mem_fn(&amp;string::empty));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem_fn(&amp;string::empty)</span></tt></code> to generate a callable object that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The callable generated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem_fn</span></tt></code> can be called on either an object or a pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto f = mem_fn(&amp;string::empty); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string*</span></span></tt></span><br class="calibre6"/>f(*svec.begin()); // <span><span class="calibre45"><span class="calibre16">ok: passes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">.*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span><br class="calibre6"/>f(&amp;svec[0]);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: passes a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">.-&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Effectively, we can think of <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem_fn</span></tt></code>
<em class="calibre16">as if</em> it generates a callable with an overloaded function call operator&#8212;one that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string*</span></tt></code> and the other a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bind</span></span></tt></span></span></tt></code> to Generate a Callable</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">For completeness, we can also use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> (&#167; <a href="100-10.3._customizing_operations.html#filepos2586884">10.3.4</a>, p. <a href="100-10.3._customizing_operations.html#filepos2586884">397</a>) to generate a callable from a member function:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bind</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">each</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><span class="calibre45"><span class="calibre16">the range to the implicit first argument to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span><br class="calibre6"/>auto it = find_if(svec.begin(), svec.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind(&amp;string::empty, _1));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>, when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>, we must make explicit the member function&#8217;s normally implicit parameter that represents the object on which the member function will operate. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem_fn</span></tt></code>, the first argument to the callable generated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> can be either a pointer or a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto f =&#160;&#160;bind(&amp;string::empty, _1);<br class="calibre6"/>f(*svec.begin()); // <span><span class="calibre45"><span class="calibre16">ok: argument is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">.*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span><br class="calibre6"/>f(&amp;svec[0]); // <span><span class="calibre45"><span class="calibre16">ok: argument is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">.-&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="179-19.3._enumerations.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="181-19.5._nested_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
