<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>2.3. Compound Types</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="022-2.2._variables.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="024-2.4._const_qualifier.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos394806" class="calibre29"><span class="bold"><a id="filepos394839" class="calibre2"/>2.3. Compound Types</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos395006" href="028-defined_terms.html#filepos614272">compound type</a></strong> is a type that is defined in terms of another type. C++ has several compound types, two of which&#8212;references and pointers&#8212;we&#8217;ll cover in this chapter.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Defining variables of compound type is more complicated than the declarations we&#8217;ve seen so far. In &#167; <a href="022-2.2._variables.html#filepos350076">2.2</a> (p. <a href="022-2.2._variables.html#filepos350076">41</a>) we said that simple declarations consist of a type followed by a list of variable names. More generally, a declaration is a <strong class="calibre5"><a id="filepos395618" href="028-defined_terms.html#filepos613170">base type</a></strong> followed by a list of <strong class="calibre5"><a id="filepos395711" href="028-defined_terms.html#filepos616931">declarators</a></strong>. Each declarator names a variable and gives the variable a type that is related to the base type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The declarations we have seen so far have declarators that are nothing more than variable names. The type of such variables is the base type of the declaration. More complicated declarators specify variables with compound types that are built from the base type of the declaration.</p><div class="calibre22">&#160;</div>
<h4 id="filepos396246" class="calibre37"><span class="calibre5">2.3.1. References</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The new standard introduced a new kind of reference: an &#8220;rvalue reference,&#8221; which we&#8217;ll cover in &#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>). These references are primarily intended for use inside classes. Technically speaking, when we use the term <em class="calibre16">reference</em>, we mean &#8220;lvalue reference.&#8221;</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A <strong class="calibre5"><a id="filepos397128" href="028-defined_terms.html#filepos624587">reference</a></strong> defines an alternative name for an object. A reference type &#8220;refers to&#8221; another type. We define a reference type by writing a declarator of the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;d</span></tt></code>, where <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> is the name being declared:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 1024;<br class="calibre6"/>int &amp;refVal = ival;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">refVal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to (is another name for</span></span></span>) <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><br class="calibre6"/>int &amp;refVal2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: a reference must be initialized</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer&#8217;s value, we <strong class="calibre5"><a id="filepos398552" href="028-defined_terms.html#filepos613589">bind</a></strong> the reference to its initializer. Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference, references <em class="calibre16">must</em> be initialized.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Reference Is an Alias</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A reference is not an object. Instead, a reference is <em class="calibre16">just another name for an already existing object</em>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">After a reference has been defined, <em class="calibre16">all</em> operations on that reference are actually operations on the object to which the reference is bound:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">refVal = 2;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assigns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">refVal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers, i.e., to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><br class="calibre6"/>int ii = refVal; // <span><span class="calibre45"><span class="calibre16">same as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ii = ival</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos400700"/>When we assign to a reference, we are assigning to the object to which the reference is bound. When we fetch the value of a reference, we are really fetching the value of the object to which the reference is bound. Similarly, when we use a reference as an initializer, we are really using the object to which the reference is bound:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">refVal3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound to the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">refVal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound, i.e., to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><br class="calibre6"/>int &amp;refVal3 = refVal;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the value in the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">refVal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound</span></span></span><br class="calibre6"/>int i = refVal; // <span><span class="calibre45"><span class="calibre16">ok: initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the same value as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because references are not objects, we may not define a reference to a reference.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Reference Definitions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can define multiple references in a single definition. Each identifier that is a reference must be preceded by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> symbol:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 1024, i2 = 2048;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int &amp;r = i, r2 = i2;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i; r2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int i3 = 1024, &amp;ri = i3;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int; ri</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i3</span></span></tt></span><br class="calibre6"/>int &amp;r3 = i3, &amp;r4 = i2;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are references</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">With two exceptions that we&#8217;ll cover in &#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a> (p. <a href="024-2.4._const_qualifier.html#filepos476737">61</a>) and &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>), the type of a reference and the object to which the reference refers must match exactly. Moreover, for reasons we&#8217;ll explore in &#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, a reference may be bound only to an object, not to a literal or to the result of a more general expression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int &amp;refVal4 = 10;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: initializer must be an object</span></span></span><br class="calibre6"/>double dval = 3.14;<br class="calibre6"/>int &amp;refVal5 = dval; // <span><span class="calibre45"><span class="calibre16">error: initializer must be an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.15:</strong> Which of the following definitions, if any, are invalid? Why?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int ival = 1.01;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int &amp;rval1 = 1.01;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int &amp;rval2 = ival;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int &amp;rval3;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.16:</strong> Which, if any, of the following assignments are invalid? If they are valid, explain what they do.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, &amp;r1 = i; double d = 0, &amp;r2 = d;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">r2 = 3.14159;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">r2 = r1;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">i = r2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">r1 = d;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.17:</strong> What does the following code print?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i, &amp;ri = i;<br class="calibre6"/>i = 5; ri = 10;<br class="calibre6"/>std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ri &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos409391" class="calibre37"><span class="calibre5"><a id="filepos409424"/>2.3.2. Pointers</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos409586" href="028-defined_terms.html#filepos623318">pointer</a></strong> is a compound type that &#8220;points to&#8221; another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Pointers are often hard to understand. Debugging problems due to pointer errors bedevil even experienced programmers.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">We define a pointer type by writing a declarator of the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">*d</span></tt></code>, where <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> is the name being defined. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> must be repeated for each pointer variable:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *ip1, *ip2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are pointers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>double dp, *dp2; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dp2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Taking the Address of an Object</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A pointer holds the address of another object. We get the address of an object by usin the address-of operator (the <a id="filepos412549" href="028-defined_terms.html#filepos631461"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&amp;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 42;<br class="calibre6"/>int *p = &amp;ival; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds the address of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The second statement defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> as a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> to point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>. Because references are not objects, they don&#8217;t have addresses. Hence, we may not define a pointer to a reference.</p><div class="calibre15">&#160;</div>
<p class="calibre25">With two exceptions, which we cover in &#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a> (p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>) and &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>), the types of the pointer and the object to which it points must match:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double dval;<br class="calibre6"/>double *pd = &amp;dval;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: initializer is the address of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>double *pd2 = pd;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: initializer is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>int *pi = pd;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: types of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pd</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">differ</span></span></span><br class="calibre6"/>pi = &amp;dval;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: assigning the address of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. If a pointer addressed an object of another type, operations performed on the underlying object would fail.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer Value</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The value (i.e., the address) stored in a pointer can be in one of four states:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> It can point to an object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> It can point to the location just immediately past the end of an object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong> It can be a null pointer, indicating that it is not bound to any object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">4.</strong> It can be invalid; values other than the preceding three are invalid.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos417292"/>It is an error to copy or otherwise try to access the value of an invalid pointer. As when we use an uninitialized variable, this error is one that the compiler is unlikely to detect. The result of accessing an invalid pointer is undefined. Therefore, we must always know whether a given pointer is valid.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although pointers in cases 2 and 3 are valid, there are limits on what we can do with such pointers. Because these pointers do not point to any object, we may not use them to access the (supposed) object to which the pointer points. If we do attempt to access an object through such pointers, the behavior is undefined.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Pointer to Access an Object</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a pointer points to an object, we can use the dereference operator (the <a id="filepos418230" href="028-defined_terms.html#filepos631844"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">*</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>) to access that object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 42;<br class="calibre6"/>int *p = &amp;ival; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds the address of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival; p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; *p;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">yields the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points; prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Dereferencing a pointer yields the object to which the pointer points. We can assign to that object by assigning to the result of the dereference:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">*p = 0;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">yields the object; we assign a new value to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; *p; // <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">*p</span></tt></code>, we are assigning to the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We may dereference only a valid pointer that points to an object.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Some Symbols Have Multiple Meanings</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some symbols, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, are used as both an operator in an expression and as part of a declaration. The context in which a symbol is used determines what the symbol means:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int &amp;r = i;&#160;&#160;&#160;// &amp; <span><span class="calibre45"><span class="calibre16">follows a type and is part of a declaration;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference</span></span></span><br class="calibre6"/>int *p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// * <span><span class="calibre45"><span class="calibre16">follows a type and is part of a declaration;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer</span></span></span><br class="calibre6"/>p = &amp;i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// &amp; <span><span class="calibre45"><span class="calibre16">is used in an expression as the address-of operator</span></span></span><br class="calibre6"/>*p = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// * <span><span class="calibre45"><span class="calibre16">is used in an expression as the dereference operator</span></span></span><br class="calibre6"/>int &amp;r2 = *p; // &amp; <span><span class="calibre45"><span class="calibre16">is part of the declaration;</span></span></span> * <span><span class="calibre45"><span class="calibre16">is the dereference operator</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In declarations, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> are used to form compound types. In expressions, these same symbols are used to denote an operator. Because the same symbol is used with very different meanings, it can be helpful to ignore appearances and think of them as if they were different symbols.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Null Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos424173" href="028-defined_terms.html#filepos622390">null pointer</a></strong> does not point to any object. Code can check whether a pointer is null before attempting to use it. There are several ways to obtain a null pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos424456"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p1 = nullptr; // <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int *p1 = 0;</span></span></tt></span><br class="calibre6"/>int *p2 = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">directly initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the literal constant</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">must</span></span></span> #<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">include cstdlib</span></span></tt></span><br class="calibre6"/>int *p3 = NULL;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int *p3 = 0;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos425646"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">The most direct approach is to initialize the pointer using the literal <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos425892" href="028-defined_terms.html#filepos622648">nullptr</a></span></span></tt></span></span></tt></code>, which was introduced by the new standard. <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> is a literal that has a special type that can be converted (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>) to any other pointer type. Alternatively, we can initialize a pointer to the literal <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, as we do in the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Older programs sometimes use a <strong class="calibre5"><a id="filepos426588" href="028-defined_terms.html#filepos624268">preprocessor variable</a></strong> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">NULL</span></tt></code>, which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstdlib</span></tt></code> header defines as <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We&#8217;ll describe the preprocessor in a bit more detail in &#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos600691">2.6.3</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos600691">77</a>). What&#8217;s useful to know now is that the preprocessor is a program that runs before the compiler. Preprocessor variables are managed by the preprocessor, and are not part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace. As a result, we refer to them directly without the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::</span></tt></code> prefix.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we use a preprocessor variable, the preprocessor automatically replaces the variable by its value. Hence, initializing a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">NULL</span></tt></code> is equivalent to initializing it to <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>. ModernC++ programs generally should avoid using <code class="calibre23"><tt class="calibre23"><span class="calibre24">NULL</span></tt></code> and use <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> instead.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is illegal to assign an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> variable to a pointer, even if the variable&#8217;s value happens to be <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int zero = 0;<br class="calibre6"/>pi = zero;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Initialize all Pointers</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Uninitialized pointers are a common source of run-time errors.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As with any other uninitialized variable, what happens when we use an uninitialized pointer is undefined. Using an uninitialized pointer almost always results in a run-time crash. However, debugging the resulting crashes can be surprisingly hard.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Under most compilers, when we use an uninitialized pointer, the bits in the memory in which the pointer resides are used as an address. Using an uninitialized pointer is a request to access a supposed object at that supposed location. There is no way to distinguish a valid address from an invalid one formed from the bits that happen to be in the memory in which the pointer was allocated.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Our recommendation to initialize all variables is particularly important for pointers. If possible, define a pointer only after the object to which it should point has been defined. If there is no object to bind to a pointer, then initialize the pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> or zero. That way, the program can detect that the pointer does not point to an object.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Assignment and Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Both pointers and references give indirect access to other objects. However, there are important differences in how they do so. The most important is that a reference <a id="filepos431057"/>is not an object. Once we have defined a reference, there is no way to make that reference refer to a different object. When we use a reference, we always get the object to which the reference was initially bound.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There is no such identity between a pointer and the address that it holds. As with any other (nonreference) variable, when we assign to a pointer, we give the pointer itself a new value. Assignment makes the pointer point to a different object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int *pi = 0;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is initialized but addresses no object</span></span></span><br class="calibre6"/>int *pi2 = &amp;i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">initialized to hold the address of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>int *pi3;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is defined inside a block,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is uninitialized</span></span></span><br class="calibre6"/>pi3 = pi2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">address the same object, e.g.,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>pi2 = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now addresses no object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">It can be hard to keep straight whether an assignment changes the pointer or the object to which the pointer points. The important thing to keep in mind is that assignment changes its left-hand operand. When we write</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pi = &amp;ival; //&#160;&#160;<span><span class="calibre45"><span class="calibre16">value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is changed;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">we assign a new value to <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi</span></tt></code>, which changes the address that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi</span></tt></code> holds. On the other hand, when we write</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">*pi = 0;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is changed;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">then <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pi</span></tt></code> (i.e., the value to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi</span></tt></code> points) is changed.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Other Pointer Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">So long as the pointer has a valid value, we can use a pointer in a condition. Just as when we use an arithmetic value in a condition (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>), if the pointer is 0, then the condition is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 1024;<br class="calibre6"/>int *pi = 0;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a valid, null pointer</span></span></span><br class="calibre6"/>int *pi2 = &amp;ival; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a valid pointer that holds the address of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><br class="calibre6"/>if (pi)&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has value 0, so condition evaluates as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>if (pi2) // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, so it is not 0; the condition evaluates as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// ...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Any nonzero pointer evaluates as <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre25">Given two valid pointers of the same type, we can compare them using the equality (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>) or inequality (<code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code>) operators. The result of these operators has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. Two pointers are equal if they hold the same address and unequal otherwise. Two pointers hold the same address (i.e., are equal) if they are both null, if they address the same object, or if they are both pointers one past the same object. Note that it is possible for a pointer to an object and a pointer one past the end of a different object to hold the same address. Such pointers will compare equal.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because these operations use the value of the pointer, a pointer used in a condition or in a comparsion must be a valid pointer. Using an invalid pointer as a condition or in a comparison is undefined.</p><div class="calibre22">&#160;</div>
<p class="calibre25">&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a> (p. <a href="034-3.5._arrays.html#filepos881970">117</a>) will cover additional pointer operations.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos439273"/><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">void*</span></span></tt></span></span></tt></code> Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The type <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos439589" href="028-defined_terms.html#filepos630544">void*</a></span></span></tt></span></span></tt></code> is a special pointer type that can hold the address of any object. Like any other pointer, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer holds an address, but the type of the object at that address is unknown:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double obj = 3.14, *pd = &amp;obj;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">void*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can hold the address value of any data pointer type</span></span></span><br class="calibre6"/>void *pv = &amp;obj;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can be an object of any type</span></span></span><br class="calibre6"/>pv = pd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pv</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can hold a pointer to any type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There are only a limited number of things we can do with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer: We can compare it to another pointer, we can pass it to or return it from a function, and we can assign it to another <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer. We cannot use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> to operate on the object it addresses&#8212;we don&#8217;t know that object&#8217;s type, and the type determines what operations we can perform on the object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Generally, we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. We&#8217;ll cover using <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointers in this way in &#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">19.1.1</a> (p. <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">821</a>). &#167; <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a> (p. <a href="049-4.11._type_conversions.html#filepos1189032">163</a>) will show how we can retrieve the address stored in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.18:</strong> Write code to change the value of a pointer. Write code to change the value to which the pointer points.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.19:</strong> Explain the key differences between pointers and references.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.20:</strong> What does the following program do?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int *p1 = &amp;i;<br class="calibre6"/>*p1 = *p1 * *p1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.21:</strong> Explain each of the following definitions. Indicate whether any are illegal and, if so, why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">double* dp = &amp;i;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int *ip = i;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int *p = &amp;i;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.22:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, explain the following code:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (p) // ...<br class="calibre6"/>if (*p) // ...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.23:</strong> Given a pointer <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>, can you determine whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points to a valid object? If so, how? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.24:</strong> Why is the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> legal but that of <code class="calibre23"><tt class="calibre23"><span class="calibre24">lp</span></tt></code> illegal?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span> = 42;&#160;&#160;&#160;&#160;void *p = &amp;i;&#160;&#160;&#160;&#160;&#160;long *lp = &amp;i;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos445809" class="calibre37"><span class="calibre5"><a id="filepos445842"/>2.3.3. Understanding Compound Type Declarations</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, a variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><code class="calibre23"><tt class="calibre23"><span class="calibre24">//</span></tt></code>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>; <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>; <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">int i = 1024, *p = &amp;i, &amp;r = i;</span></tt></code></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Many programmers are confused by the interaction between the base type and the type modification that may be part of a declarator.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining Multiple Variables</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">It is a common misconception to think that the type modifier (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>) applies to all the variables defined in a single statement. Part of the problem arises because we can put whitespace between the type modifier and the name being declared:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int* p;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">legal but might be misleading</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We say that this definition might be misleading because it suggests that <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code> is the type of each variable declared in that statement. Despite appearances, the base type of this declaration is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> modifies the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>. It says nothing about any other objects that might be declared in the same statement:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int* p1, p2; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int; p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">There are two common styles used to define multiple variables with pointer or reference type. The first places the type modifier adjacent to the identifier:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p1, *p2; // <span><span class="calibre45"><span class="calibre16">both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are pointers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This style emphasizes that the variable has the indicated compound type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second places the type modifier with the type but defines only one variable per statement:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int* p1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int* p2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This style emphasizes that the declaration defines a compound type.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">There is no single right way to define pointers or references. The important thing is to choose a style and use it consistently.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">In this book we use the first style and place the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> (or the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>) with the variable name.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointers to Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In general, there are no limits to how many type modifiers can be applied to a declarator. When there is more than one modifier, they combine in ways that are logical but not always obvious. As one example, consider a pointer. A pointer is <a id="filepos453546"/>an object in memory, so like any object it has an address. Therefore, we can store the address of a pointer in another pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We indicate each pointer level by its own <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>. That is, we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">**</span></tt></code> for a pointer to a pointer, <code class="calibre23"><tt class="calibre23"><span class="calibre24">***</span></tt></code> for a pointer to a pointer to a pointer, and so on:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 1024;<br class="calibre6"/>int *pi = &amp;ival;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int **ppi = &amp;pi;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ppi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a pointer to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi</span></tt></code> is a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ppi</span></tt></code> is a pointer to a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. We might represent these objects as</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00021.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Just as dereferencing a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> yields an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, dereferencing a pointer to a pointer yields a pointer. To access the underlying object, we must dereference the original pointer twice:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; "The value of ival\n"<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; "direct value: " &lt;&lt; ival &lt;&lt; "\n"<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; "indirect value: " &lt;&lt; *pi &lt;&lt; "\n"<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; "doubly indirect value: " &lt;&lt; **ppi<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program prints the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code> three different ways: first, directly; then, through the pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi</span></tt></code>; and finally, by dereferencing <code class="calibre23"><tt class="calibre23"><span class="calibre24">ppi</span></tt></code> twice to get to the underlying value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">References to Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int *p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int *&amp;r = p;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to the pointer</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>r = &amp;i; //&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to a pointer; assigning</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">makes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>*r = 0; //&#160;&#160;<span><span class="calibre45"><span class="calibre16">dereferencing</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">yields</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points; changes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The easiest way to understand the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> is to read the definition right to left. The symbol closest to the name of the variable (in this case the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;r</span></tt></code>) is the one that has the most immediate effect on the variable&#8217;s type. Thus, we know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> is a reference. The rest of the declarator determines the type to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> refers. The next symbol, <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> in this case, says that the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> refers to is a pointer type. Finally, the base type of the declaration says that <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> is a reference to a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It can be easier to understand complicated pointer or reference declarations if you read them from right to left.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos461299"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.25:</strong> Determine the types and values of each of the following variables.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int* ip, &amp;r = ip;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int i, *ip = 0;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int* ip, ip2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="022-2.2._variables.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="024-2.4._const_qualifier.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
