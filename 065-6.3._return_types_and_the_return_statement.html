<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>6.3. Return Types and the return Statement</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="064-6.2._argument_passing.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="066-6.4._overloaded_functions.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1548761" class="calibre29"><span class="bold">6.3. Return Types and the <code class="calibre54"><tt class="calibre54"><span class="calibre55"><span class="calibre2"><tt class="calibre54"><span class="calibre56"><span class="bold">return</span></span></tt></span></span></tt></code> Statement</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statements:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">return;<br class="calibre6"/>return <span><span class="calibre45"><span class="calibre16">expression</span></span></span>;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 id="filepos1549598" class="calibre37"><span class="calibre5"><a id="filepos1549631"/>6.3.1. Functions with No Return Value</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> with no value may be used only in a function that has a return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. Functions that return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> are not required to contain a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code>. In a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> function, an implicit <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> takes place after the function&#8217;s last statement.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Typically, <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> functions use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> to exit the function at an intermediate point. This use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> is analogous to the use of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">break</span></tt></code> statement (&#167; <a href="058-5.5._jump_statements.html#filepos1351310">5.5.1</a>, p. <a href="058-5.5._jump_statements.html#filepos1351310">190</a>) to exit a loop. For example, we can write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function that does no work if the values are identical:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void swap(int &amp;v1, int &amp;v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the values are already the same, no need to swap, just return</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 == v2)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if we're here, there's work to do</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int tmp = v2;<br class="calibre6"/>&#160;&#160;&#160;&#160;v2 = v1;<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = tmp;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no explicit return necessary</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This function first checks if the values are equal and, if so, exits the function. If the values are unequal, the function swaps them. An implicit return occurs after the last assignment statement.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A function with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> return type may use the second form of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement only to return the result of calling another function that returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. Returning any other expression from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> function is a compile-time error.</p><div class="calibre22">&#160;</div>
<h4 id="filepos1552941" class="calibre37"><span class="calibre5">6.3.2. Functions That Return a Value</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The second form of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement provides the function&#8217;s result. Every return in a function with a return type other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> must return a value. The value returned must have the same type as the function return type, or it must have a type that can be implicitly converted (&#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a>, p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>) to that type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although C++ cannot guarantee the correctness of a result, it can guarantee that every <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> includes a result of the appropriate type. Although it cannot do so in all cases, the compiler attempts to ensure that functions that return a value are exited only through a valid <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">incorrect return values, this code will not compile</span></span></span><br class="calibre6"/>bool str_subrange(const string &amp;str1, const string &amp;str2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">same sizes: return normal equality test</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (str1.size() == str2.size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return str1 == str2;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">==</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">find the size of the smaller</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; conditional operator, see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 4.7 (p. 151)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto size = (str1.size() &lt; str2.size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;? str1.size() : str2.size();<br class="calibre6"/><a id="filepos1555742"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">look at each element up to the size of the smaller</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (decltype(size) i = 0; i != size; ++i) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (str1[i] != str2[i])<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return; // <span><span class="calibre45"><span class="calibre16">error #1: no return value; compiler should detect this error</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error #2: control might flow off the end of the function without a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">return</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the compiler might not detect this error</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> from within the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop is an error because it fails to return a value. The compiler should detect this error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second error occurs because the function fails to provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> after the loop. If we call this function with one <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that is a subset of the other, execution would fall out of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>. There should be a return to handle this case. The compiler may or may not detect this error. If it does not detect the error, what happens at run time is undefined.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Failing to provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> after a loop that contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> is an error. However, many compilers will not detect such errors.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">How Values Are Returned</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Values are returned in exactly the same way as variables and parameters are initialized: The return value is used to initialize a temporary at the call site, and that temporary is the result of the function call.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is important to keep in mind the initialization rules in functions that return local variables. As an example, we might write a function that, given a counter, a word, and an ending, gives us back the plural version of the word if the counter is greater than 1:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">return the plural version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ctr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is greater than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>string make_plural(size_t ctr, const string &amp;word,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const string &amp;ending)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return (ctr &gt; 1) ? word + ending : word;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The return type of this function is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, which means the return value is copied to the call site. This function returns a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code>, or it returns an unnamed temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that results from adding <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ending</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any other reference, when a function returns a reference, that reference is just another name for the object to which it refers. As an example, consider a function that returns a reference to the shorter of its two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> parameters:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">return a reference to the shorter of two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>const string &amp;shorterString(const string &amp;s1, const string &amp;s2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return s1.size() &lt;= s2.size() ? s1 : s2;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1561797"/>The parameters and return type are references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s are not copied when the function is called or when the result is returned.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Never Return a Reference or Pointer to a Local Object</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a function completes, its storage is freed (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>). After a function terminates, references to local objects refer to memory that is no longer valid:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">disaster: this function returns a reference to a local object</span></span></span><br class="calibre6"/>const string &amp;manip()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;string ret;<br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">transform</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in some way</span></span></span><br class="calibre6"/>&#160;&#160;&#160;if (!ret.empty())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ret;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">WRONG: returning a reference to a local object!</span></span></span><br class="calibre6"/>&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;return "Empty"; // <span><span class="calibre45"><span class="calibre16">WRONG:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"Empty"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a local temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both of these <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statements return an undefined value&#8212;what happens if we try to use the value returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code> is undefined. In the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code>, it should be obvious that the function returns a reference to a local object. In the second case, the string literal is converted to a local temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> object. That object, like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>, is local to <code class="calibre23"><tt class="calibre23"><span class="calibre24">manip</span></tt></code>. The storage in which the temporary resides is freed when the function ends. Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code>s refer to memory that is no longer available.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">One good way to ensure that the return is safe is to ask: To what <em class="calibre16">preexisting</em> object is the reference referring?</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">For the same reasons that it is wrong to return a reference to a local object, it is also wrong to return a pointer to a local object. Once the function completes, the local objects are freed. The pointer would point to a nonexistent object.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Functions That Return Class Types and the Call Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like any operator the call operator has associativity and precedence (&#167; <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>). The call operator has the same precedence as the dot and arrow operators (&#167; <a href="044-4.6._the_member_access_operators.html#filepos1101794">4.6</a>, p. <a href="044-4.6._the_member_access_operators.html#filepos1101794">150</a>). Like those operators, the call operator is left associative. As a result, if a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, we can determine the size of the shorter <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">call the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returned by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shorterString</span></span></tt></span><br class="calibre6"/>auto sz = shorterString(s1, s2).size();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because these operators are left associative, the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shorterString</span></tt></code> is the left-hand operand of the dot operator. That operator fetches the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> member of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. That member is the left-hand operand of the second call operator.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1567946"/>Reference Returns Are Lvalues</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Whether a function call is an lvalue (&#167; <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>) depends on the return type of the function. Calls to functions that return references are lvalues; other return types yield rvalues. A call to a function that returns a reference can be used in the same ways as any other lvalue. In particular, we can assign to the result of a function that returns a reference to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char &amp;get_val(string &amp;str, string::size_type ix)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return str[ix]; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get_val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">assumes the given index is valid</span></span></span><br class="calibre6"/>}<br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;string s("a value");<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; s &lt;&lt; endl;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a value</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;get_val(s, 0) = 'A'; // <span><span class="calibre45"><span class="calibre16">changes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s[0]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; s &lt;&lt; endl;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A value</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved. The return value is a reference, so the call is an lvalue. Like any other lvalue, it may appear as the left-hand operand of the assignment operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If the return type is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, then (as usual) we may not assign to the result of the call:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shorterString("hi", "bye") = "X"; // <span><span class="calibre45"><span class="calibre16">error: return value is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">List Initializing the Return Value</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos1571219"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, functions can return a braced list of values. As in any other return, the list is used to initialize the temporary that represents the function&#8217;s return. If the list is empty, that temporary is value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>). Otherwise, the value of the return depends on the function&#8217;s return type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, recall the <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code> function from &#167; <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a> (p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>). That function took a varying number of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> arguments and printed an error message composed from the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Rather than calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code>, in this function we&#8217;ll return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds the error-message <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; process()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">. . .</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">expected</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">actual</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (expected.empty())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return {};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return an empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else if (expected == actual)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return {"functionX", "okay"}; // <span><span class="calibre45"><span class="calibre16">return list-initialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return {"functionX", expected, actual};<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1574169"/>In the first return statement, we return an empty list. In this case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> returns will be empty. Otherwise, we return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> initialized with two or three elements depending on whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">expected</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">actual</span></tt></code> are equal.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In a function that returns a built-in type, a braced list may contain at most one value, and that value must not require a narrowing conversion (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>). If the function returns a class type, then the class itself defines how the intiailizers are used (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">99</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Return from <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">main</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">There is one exception to the rule that a function with a return type other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> must return a value: The <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function is allowed to terminate without a return. If control reaches the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> and there is no return, then the compiler implicitly inserts a return of 0.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we saw in &#167; <a href="011-1.1._writing_a_simple_cpp_program.html#filepos117760">1.1</a> (p. <a href="011-1.1._writing_a_simple_cpp_program.html#filepos117760">2</a>), the value returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstdlib</span></tt></code> header defines two preprocessor variables (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">54</a>) that we can use to indicate success or failure:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (some_failure)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return EXIT_FAILURE;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defined in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cstdlib</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return EXIT_SUCCESS;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defined in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cstdlib</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because these are preprocessor variables, we must not precede them with <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::</span></tt></code>, nor may we mention them in <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Recursion</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A function that calls itself, either directly or indirectly, is a <strong class="calibre5"><em class="calibre16"><a id="filepos1578009" href="071-defined_terms.html#filepos1739553">recursive function</a></em></strong>. As an example, we can rewrite our factorial function to use recursion:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">calculate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val!</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><span class="calibre45"><span class="calibre16">which is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1 * 2 * 3 <span><span class="calibre45"><span class="calibre16">. . .</span></span></span></span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">* val</span></span></tt></span><br class="calibre6"/>int factorial(int val)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (val &gt; 1)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return factorial(val-1) * val;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 1;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this implementation, we recursively call <code class="calibre23"><tt class="calibre23"><span class="calibre24">factorial</span></tt></code> to compute the factorial of the numbers counting down from the original value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. Once we have reduced <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, we stop the recursion by returning <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse &#8220;forever,&#8221; meaning that the function will continue to call itself until the program stack is exhausted. Such <a id="filepos1580061"/>functions are sometimes described as containing a <strong class="calibre5"><a id="filepos1580127" href="071-defined_terms.html#filepos1739250">recursion loop</a></strong>. In the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">factorial</span></tt></code>, the stopping condition occurs when <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The following table traces the execution of <code class="calibre23"><tt class="calibre23"><span class="calibre24">factorial</span></tt></code> when passed the value 5.</p><div class="calibre22">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00040.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function may <em class="calibre16">not</em> call itself.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.30:</strong> Compile the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">str_subrange</span></tt></code> as presented on page <a href="065-6.3._return_types_and_the_return_statement.html#filepos1549631">223</a> to see what your compiler does with the indicated errors.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.31:</strong> When is it valid to return a reference? A reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.32:</strong> Indicate whether the following function is legal. If so, explain what it does; if not, correct any errors and then explain it.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int &amp;get(int *arry, int index) { return arry[index]; }<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;int ia[10];<br class="calibre6"/>&#160;&#160;&#160;&#160;for (int i = 0; i != 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;get(ia, i) = i;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.33:</strong> Write a recursive function to print the contents of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.34:</strong> What would happen if the stopping condition in <code class="calibre23"><tt class="calibre23"><span class="calibre24">factorial</span></tt></code> were</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (val != 0)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.35:</strong> In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fact</span></tt></code>, why did we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">val - 1</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">val--?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1583824" class="calibre37"><span class="calibre5">6.3.3. Returning a Pointer to an Array</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>). Unfortunately, the syntax used to define functions that return pointers or references to <a id="filepos1584269"/>arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef int arrT[10];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arrT</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a synonym for the type array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>using arrtT = int[10]; // <span><span class="calibre45"><span class="calibre16">equivalent declaration of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arrT</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; see &#167; 2.5.1 (p. 68)</span></span></span><br class="calibre6"/>arrT* func(int i);&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">func</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a pointer to an array of five</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrT</span></tt></code> is a synonym for an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Because we cannot return an array, we define the return type as a pointer to this type. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> is a function that takes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> argument and returns a pointer to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Declaring a Function That Returns a Pointer to an Array</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To declare <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> without using a type alias, we must remember that the dimension of an array follows the name being defined:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int arr[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *p1[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten pointers</span></span></span><br class="calibre6"/>int (*p2)[10] = &amp;arr; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function&#8217;s name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the dimension. Hence, the form of a function that returns a pointer to an array is:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><span class="calibre45"><span class="calibre16">Type</span></span></span> (<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*</span></span></tt></span><span><span class="calibre45"><span class="calibre16">function</span></span></span>(<span><span class="calibre45"><span class="calibre16">parameter_list</span></span></span>))[<span><span class="calibre45"><span class="calibre16">dimension</span></span></span>]</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in any other array declaration, <em class="calibre16">Type</em> is the type of the elements and <em class="calibre16">dimension</em> is the size of the array. The parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*</span></tt></code><em class="calibre16">function</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(</span></tt></code><em class="calibre16">parameter_list</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">))</span></tt></code> are necessary for the same reason that they were required when we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code>. Without them, we would be defining a function that returns an array of pointers.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As a concrete example, the following declares <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> without using a type alias:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int (*func(int i))[10];</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To understand this declaration, it can be helpful to think about it as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">func(int)</span></tt></code> says that we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> with an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> argument.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*func(int))</span></tt></code> says we can dereference the result of that call.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*func(int))[10]</span></tt></code> says that dereferencing the result of a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> yields an array of size ten.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">int (*func(int))[10]</span></tt></code> says the element type in that array is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Trailing Return Type</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos1591534"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, another way to simplify the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> is by using a <strong class="calibre5"><a id="filepos1591778" href="071-defined_terms.html#filepos1740298">trailing return type</a></strong>. Trailing returns can be defined for any function, but are most useful for functions with complicated return types, such as pointers (or references) to arrays. A trailing return type follows the parameter list and is preceded by <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code>. To signal that the return follows the parameter list, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> where the return type ordinarily appears:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1592390"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">takes an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">argument and returns a pointer to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>auto func(int i) -&gt; int(*)[10];</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the return type comes after the parameter list, it is easier to see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> returns a pointer and that that pointer points to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">decltype</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As another alternative, if we know the array(s) to which our function can return a pointer, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to declare the return type. For example, the following function returns a pointer to one of two arrays, depending on the value of its parameter:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int odd[] = {1,3,5,7,9};<br class="calibre6"/>int even[] = {0,2,4,6,8};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">returns a pointer to an array of five</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements</span></span></span><br class="calibre6"/>decltype(odd) *arrPtr(int i)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return (i % 2) ? &amp;odd : &amp;even; // <span><span class="calibre45"><span class="calibre16">returns a pointer to the array</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The return type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrPtr</span></tt></code> uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to say that the function returns a pointer to whatever type <code class="calibre23"><tt class="calibre23"><span class="calibre24">odd</span></tt></code> has. That object is an array, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrPtr</span></tt></code> returns a pointer to an array of five <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. The only tricky part is that we must remember that <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> does not automatically convert an array to its corresponding pointer type. The type returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> is an array type, to which we must add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> to indicate that <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrPtr</span></tt></code> returns a pointer.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.36:</strong> Write the declaration for a function that returns a reference to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, without using either a trailing return, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>, or a type alias.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.37:</strong> Write three additional declarations for the function in the previous exercise. One should use a type alias, one should use a trailing return, and the third should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>. Which form do you prefer and why?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.38:</strong> Revise the <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrPtr</span></tt></code> function on to return a reference to the array.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="064-6.2._argument_passing.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="066-6.4._overloaded_functions.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
