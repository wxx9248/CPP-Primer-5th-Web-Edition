<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>7.6. static Class Members</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="077-7.5._constructors_revisited.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="079-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2028441" class="calibre29"><span class="bold">7.6. <code class="calibre54"><tt class="calibre54"><span class="calibre55"><span class="calibre2"><tt class="calibre54"><span class="calibre56"><span class="bold">static</span></span></tt></span></span></tt></code> Class Members</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we&#8217;d want to associate the rate with the class, not with each individual object. From an efficiency standpoint, there&#8217;d be no reason for each object to store the rate. Much more importantly, if the rate changes, we&#8217;d want each object to use the new value.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Declaring <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We say a member is associated with the class by adding the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> to its declaration. Like any other member, <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members can be <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>. The type of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member can be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, reference, array, class type, and so forth.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2030185"/>As an example, we&#8217;ll define a class to represent an account record at a bank:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Account {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;void calculate() { amount += amount * interestRate; }<br class="calibre6"/>&#160;&#160;&#160;&#160;static double rate() { return interestRate; }<br class="calibre6"/>&#160;&#160;&#160;&#160;static void rate(double);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string owner;<br class="calibre6"/>&#160;&#160;&#160;&#160;double amount;<br class="calibre6"/>&#160;&#160;&#160;&#160;static double interestRate;<br class="calibre6"/>&#160;&#160;&#160;&#160;static double initRate();<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members of a class exist outside any object. Objects do not contain data associated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members. Thus, each <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> object will contain two data members&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">owner</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">amount</span></tt></code>. There is only one <code class="calibre23"><tt class="calibre23"><span class="calibre24">interestRate</span></tt></code> object that will be shared by all the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> objects.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member functions are not bound to any object; they do not have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member functions may not be declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and we may not refer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> in the body of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member. This restriction applies both to explicit uses of <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> and to implicit uses of <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> by calling a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using a Class <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Member</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We can access a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member directly through the scope operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double r;<br class="calibre6"/>r = Account::rate(); // <span><span class="calibre45"><span class="calibre16">access a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member using the scope operator</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Account ac1;<br class="calibre6"/>Account *ac2 = &amp;ac1;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">equivalent ways to call the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rate</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function</span></span></span><br class="calibre6"/>r = ac1.rate();&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">through an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object or reference</span></span></span><br class="calibre6"/>r = ac2-&gt;rate();&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">through a pointer to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Member functions can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members directly, without the scope operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Account {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;void calculate() { amount += amount * interestRate; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;static double interestRate;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos2036267"/>Defining <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with any other member function, we can define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member function inside or outside of the class body. When we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member outside the class, we do not repeat the <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> keyword. The keyword appears only with the declaration inside the class body:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void Account::rate(double newRate)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;interestRate = newRate;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As with any class member, when we refer to a class <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member outside the class body, we must specify the class in which the member is defined. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> keyword, however, is used <em class="calibre16">only</em> on the declaration inside the class body.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class&#8217; constructors. Moreover, in general, we may not initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member inside the class. Instead, we must define and initialize each <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member outside the class body. Like any other object, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member may be defined only once.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Like global objects (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members are defined outside any function. Hence, once they are defined, they continue to exist until the program completes.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member similarly to how we define class member functions outside the class. We name the object&#8217;s type, followed by the name of the class, the scope operator, and the member&#8217;s own name:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">define and initialize a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class member</span></span></span><br class="calibre6"/>double Account::interestRate = initRate();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This statement defines the object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">interestRate</span></tt></code> that is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> and has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. Once the class name is seen, the remainder of the definition is in the scope of the class. As a result, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">initRate</span></tt></code> without qualification as the initializer for <code class="calibre23"><tt class="calibre23"><span class="calibre24">rate</span></tt></code>. Note also that even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">initRate</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, we can use this function to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">interestRate</span></tt></code>. The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">interestRate</span></tt></code>, like any other member definition, has access to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> members of the class.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The best way to ensure that the object is defined exactly once is to put the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members in the same file that contains the definitions of the class noninline member functions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">In-Class Initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Data Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, class <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members may not be initialized in the class body. However, we can provide in-class initializers for <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members that have <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> integral type and must do so for <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>s of literal <a id="filepos2042788"/>type (&#167; <a href="077-7.5._constructors_revisited.html#filepos2019288">7.5.6</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2019288">299</a>). The initializers must be constant expressions. Such members are themselves constant expressions; they can be used where a constant expression is required. For example, we can use an initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member to specify the dimension of an array member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Account {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;static double rate() { return interestRate; }<br class="calibre6"/>&#160;&#160;&#160;&#160;static void rate(double);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;static constexpr int period = 30;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">period</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant expression</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double daily_tbl[period];<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the member is used only in contexts where the compiler can substitute the member&#8217;s value, then an initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr static</span></tt></code> need not be separately defined. However, if we use the member in a context in which the value cannot be substituted, then there must be a definition for that member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, if the only use we make of <code class="calibre23"><tt class="calibre23"><span class="calibre24">period</span></tt></code> is to define the dimension of <code class="calibre23"><tt class="calibre23"><span class="calibre24">daily_tbl</span></tt></code>, there is no need to define <code class="calibre23"><tt class="calibre23"><span class="calibre24">period</span></tt></code> outside of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code>. However, if we omit the definition, it is possible that even seemingly trivial changes to the program might cause the program to fail to compile because of the missing definition. For example, if we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account::period</span></tt></code> to a function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int&amp;</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">period</span></tt></code> must be defined.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If an initializer is provided inside the class, the member&#8217;s definition must not specify an initial value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">definition of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member with no initializer</span></span></span><br class="calibre6"/>constexpr int Account::period; // <span><span class="calibre45"><span class="calibre16">initializer provided in the class definition</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Even if a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const static</span></tt></code> data member is initialized in the class body, that member ordinarily should be defined outside the class definition.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static</span></span></tt></span></span></tt></code> Members Can Be Used in Ways Ordinary Members Can&#8217;t</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members exist independently of any other object. As a result, they can be used in ways that would be illegal for non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members. As one example, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member can have incomplete type (&#167; <a href="075-7.3._additional_class_features.html#filepos1897012">7.3.3</a>, p. <a href="075-7.3._additional_class_features.html#filepos1897012">278</a>). In particular, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member can have the same type as the class type of which it is a member. A non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member is restricted to being declared as a pointer or a reference to an object of its class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Bar {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;static Bar mem1; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member can have incomplete type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bar *mem2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: pointer member can have incomplete type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bar mem3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: data members must have complete type</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2049039"/>Another difference between <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> and ordinary members is that we can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member as a default argument (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bkground</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to the static member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declared later in the class definition</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen&amp; clear(char = bkground);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;static const char bkground;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">A non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member may not be used as a default argument because its value is part of the object of which it is a member. Using a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member as a default argument provides no object from which to obtain the member&#8217;s value and so is an error.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.56:</strong> What is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> class member? What are the advantages of <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> members? How do they differ from ordinary members?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.57:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.58:</strong> Which, if any, of the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member declarations and definitions are errors? Explain why.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">example.h</span></span></span><br class="calibre6"/>class Example {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;static double rate = 6.5;<br class="calibre6"/>&#160;&#160;&#160;&#160;static const int vecSize = 20;<br class="calibre6"/>&#160;&#160;&#160;&#160;static vector&lt;double&gt; vec(vecSize);<br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">example.C</span></span></span><br class="calibre6"/>#include "example.h"<br class="calibre6"/>double Example::rate;<br class="calibre6"/>vector&lt;double&gt; Example::vec;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="077-7.5._constructors_revisited.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="079-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
