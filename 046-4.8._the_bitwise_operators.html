<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.8. The Bitwise Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="045-4.7._the_conditional_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="047-4.9._the_sizeof_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1120642" class="calibre29"><span class="bold">4.8. The Bitwise Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The bitwise operators take operands of integral type that they use as a collection of bits. These operators let us test and set individual bits. As we&#8217;ll see in &#167; <a href="164-17.2._the_bitset_type.html#filepos4603212">17.2</a> (p. <a href="164-17.2._the_bitset_type.html#filepos4603212">723</a>), we can also use these operators on a library type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">bitset</span></tt></code> that represents a flexibly sized collection of bits.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As usual, if an operand is a &#8220;small integer,&#8221; its value is first promoted (&#167; <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">160</a>) to a larger integral type. The operand(s) can be either signed or unsigned.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos1121570"/><a/>Table 4.3. Bitwise Operators (Left Associative)</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00032.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">If the operand is signed and its value is negative, then the way that the &#8220;sign bit&#8221; is handled in a number of the bitwise operations is machine dependent. Moreover, doing a left shift that changes the value of the sign bit is undefined.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because there are no guarantees for how the sign bit is handled, we strongly recommend using <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> types with the bitwise operators.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Bitwise Shift Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We have already used the overloaded versions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> operators that the IO library defines to do input and output. The built-in meaning of these operators is that they perform a bitwise shift on their operands. They yield a value that is a copy of the (possibly promoted) left-hand operand with the bits shifted as directed by the right-hand operand. The right-hand operand must not be negative and must be a value that is strictly less than the number of bits in the result. Otherwise, the operation is undefined. The bits are shifted left (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code>) or right (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code>). Bits that are shifted off the end are discarded:</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00033.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The left-shift operator (the <a id="filepos1123791" href="052-defined_terms.html#filepos1228184"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&lt;&lt;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>) inserts 0-valued bits on the right. The behavior of the right-shift operator (the <a id="filepos1124082" href="052-defined_terms.html#filepos1229053"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&gt;&gt;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>) depends on the type of the left-hand operand: If that operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>, then the operator inserts 0-valued <a id="filepos1124464"/>bits on the left; if it is a signed type, the result is implementation defined&#8212;either copies of the sign bit or 0-valued bits are inserted on the left.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Bitwise <small class="calibre48">NOT</small> Operator</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The bitwise <small class="calibre48">NOT</small> operator (the <a id="filepos1124838" href="052-defined_terms.html#filepos1229657"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">~</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1:</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00034.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Here, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> operand is first promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Promoting a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> leaves the value unchanged but adds 0 bits to the high order positions. Thus, promoting <code class="calibre23"><tt class="calibre23"><span class="calibre24">bits</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> adds 24 high order bits, all of which are 0-valued. The bits in the promoted value are inverted.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Bitwise <small class="calibre48">AND</small>, <small class="calibre48">OR</small>, and <small class="calibre48">XOR</small> Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <small class="calibre48">AND</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>), <small class="calibre48">OR</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code>), and <small class="calibre48">XOR</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">^</span></tt></code>) operators generate new values with the bit pattern composed from its two operands:</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00035.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">For each bit position in the result of the bitwise <small class="calibre48">AND</small> operator (the <a id="filepos1126738" href="052-defined_terms.html#filepos1224608"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&amp;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>) the bit is 1 if both operands contain 1; otherwise, the result is 0. For the <small class="calibre48">OR</small> (inclusive or) operator (the <a id="filepos1127068" href="052-defined_terms.html#filepos1226189"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">|</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>), the bit is 1 if either or both operands contain 1; otherwise, the result is 0. For the <small class="calibre48">XOR</small> (exclusive or) operator (the <a id="filepos1127406" href="052-defined_terms.html#filepos1225089"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">^</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>), the bit is 1 if either but not both operands contain 1; otherwise, the result is 0.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is a common error to confuse the bitwise and logical operators (&#167; <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">4.3</a>, p. <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">141</a>). For example to confuse the bitwise <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> with the logical <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>, the bitwise <code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code> with the logical <code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code>, and the bitwise <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> and the logical <code class="calibre23"><tt class="calibre23"><span class="calibre24">!</span></tt></code>).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using Bitwise Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As an example of using the bitwise operators let&#8217;s assume a teacher has 30 students in a class. Each week the class is given a pass/fail quiz. We&#8217;ll track the results of each quiz using one bit per student to represent the pass or fail grade on a given test. We might represent each quiz in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> integral value:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned long quiz1 = 0; // <span><span class="calibre45"><span class="calibre16">we'll use this value as a collection of bits</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1129722"/>We define <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> will have at least 32 bits on any machine. We explicitly initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> to ensure that the bits start out with well-defined values.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The teacher must be able to set and test individual bits. For example, we&#8217;d like to be able to set the bit corresponding to student number 27 to indicate that this student passed the quiz. We can indicate that student number 27 passed by creating a value that has only bit 27 turned on. If we then bitwise <small class="calibre48">OR</small> that value with <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>, all the bits except bit 27 will remain unchanged.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For the purpose of this example, we will count the bits of <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> by assigning 0 to the low-order bit, 1 to the next bit, and so on.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can obtain a value indicating that student 27 passed by using the left-shift operator and an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code> integer literal 1 (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">38</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">1UL &lt;&lt; 27 // <span><span class="calibre45"><span class="calibre16">generate a value with only bit number 27 set</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">1UL</span></tt></code> has a 1 in the low-order bit and (at least) 31 zero bits. We specified <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code> because <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s are only guaranteed to have 16 bits, and we need at least 17. This expression shifts the 1 bit left 27 positions inserting 0 bits behind it.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Next we <small class="calibre48">OR</small> this value with <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>. Because we want to update the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>, we use a compound assignment (&#167; <a href="042-4.4._assignment_operators.html#filepos1066463">4.4</a>, p. <a href="042-4.4._assignment_operators.html#filepos1066463">147</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">quiz1 |= 1UL &lt;&lt; 27; // <span><span class="calibre45"><span class="calibre16">indicate student number 27 passed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">|=</span></tt></code> operator executes analogously to how <code class="calibre23"><tt class="calibre23"><span class="calibre24">+=</span></tt></code> does. It is equivalent to</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">quiz1 = quiz1 | 1UL &lt;&lt; 27; // <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">quiz1</span></span></tt></span> | = <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1UL &lt;&lt; 27;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Imagine that the teacher reexamined the quiz and discovered that student 27 actually had failed the test. The teacher must now turn off bit 27. This time we need an integer that has bit 27 turned off and all the other bits turned on. We&#8217;ll bitwise <small class="calibre48">AND</small> this value with <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> to turn off just that bit:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">quiz1 &amp;= ~(1UL &lt;&lt; 27); // <span><span class="calibre45"><span class="calibre16">student number 27 failed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We obtain a value with all but bit 27 turned on by inverting our previous value. That value had 0 bits in all but bit 27, which was a 1. Applying the bitwise <small class="calibre48">NOT</small> to that value will turn off bit 27 and turn on all the others. When we bitwise <small class="calibre48">AND</small> this value with <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>, all except bit 27 will remain unchanged.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Finally, we might want to know how the student at position 27 fared:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool status = quiz1 &amp; (1UL &lt;&lt; 27); // <span><span class="calibre45"><span class="calibre16">how did student number 27 do?</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we <small class="calibre48">AND</small> a value that has bit 27 turned on with <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>. The result is nonzero (i.e., true) if bit 27 of <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> is also on; otherwise, it evaluates to zero.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Shift Operators (aka IO Operators) Are Left Associative</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Although many programmers never use the bitwise operators directly, most programmers do use overloaded versions of these operators for IO. An overloaded operator has the same precedence and associativity as the built-in version of that operator. Therefore, programmers need to understand the precedence and associativity of the shift operators even if they never use them with their built-in meaning.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the shift operators are left associative, the expression</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1136915"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; "hi" &lt;&lt; " there" &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">executes as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">( (cout &lt;&lt; "hi") &lt;&lt; " there" ) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this statement, the operand <code class="calibre23"><tt class="calibre23"><span class="calibre24">"hi"</span></tt></code> is grouped with the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> symbol. Its result is grouped with the second, and then that result is grouped with the third.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The shift operators have midlevel precedence: lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. These relative precedence levels mean we usually have to use parentheses to force the correct grouping of operators with lower precedence.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; 42 + 10;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: + has higher precedence, so the sum is printed</span></span></span><br class="calibre6"/>cout &lt;&lt; (10 &lt; 42); // <span><span class="calibre45"><span class="calibre16">ok: parentheses force intended grouping; prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; 10 &lt; 42;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: attempt to compare</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><span><span class="calibre45"><span class="calibre16">!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The last <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> is interpreted as</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">(cout &lt;&lt; 10) &lt; 42;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">which says to &#8220;write <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code> onto <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> and then compare the result of that operation (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>) to <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>.&#8221;</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.8</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.25:</strong> What is the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">~'q' &lt;&lt; 6</span></tt></code> on a machine with 32-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and 8 bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>s, that uses Latin-1 character set in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">'q'</span></tt></code> has the bit pattern <code class="calibre23"><tt class="calibre23"><span class="calibre24">01110001</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.26:</strong> In our grading example in this section, what would happen if we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code> as the type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.27:</strong> What is the result of each of these expressions?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned long ul1 = 3, ul2 = 7;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ul1 &amp; ul2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ul1 | ul2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ul1 &amp;&amp; ul2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ul1 || ul2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="045-4.7._the_conditional_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="047-4.9._the_sizeof_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
