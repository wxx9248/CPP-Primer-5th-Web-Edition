<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.4. Assignment Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="041-4.3._logical_and_relational_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="043-4.5._increment_and_decrement_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1066463" class="calibre29"><span class="bold">4.4. Assignment Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The left-hand operand of an assignment operator must be a modifiable lvalue. For example, given</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, j = 0, k = 0; // <span><span class="calibre45"><span class="calibre16">initializations, not assignment</span></span></span><br class="calibre6"/>const int ci = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initialization, not assignment</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1067326"/>Each of these assignments is illegal:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">1024 = k;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: literals are rvalues</span></span></span><br class="calibre6"/>i + j = k;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: arithmetic expressions are rvalues</span></span></span><br class="calibre6"/>ci = k;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(nonmodifiable) lvalue</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The result of an assignment is its left-hand operand, which is an lvalue. The type of the result is the type of the left-hand operand. If the types of the left and right operands differ, the right-hand operand is converted to the type of the left:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">k = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">result: type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">value 0</span></span></span><br class="calibre6"/>k = 3.14159;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">result: type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">value 3</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Under the new standard, we can use a braced initializer list (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>) on the right-hand side:</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos1069824"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">k = {3.14};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: narrowing conversion</span></span></span><br class="calibre6"/>vector&lt;int&gt; vi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initially empty</span></span></span><br class="calibre6"/>vi = {0,1,2,3,4,5,6,7,8,9}; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now has ten elements, values</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">9</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the left-hand operand is of a built-in type, the initializer list may contain at most one value, and that value must not require a narrowing conversion (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">For class types, what happens depends on the details of the class. In the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> template defines its own version of an assignment operator that can take an initializer list. This operator replaces the elements of the left-hand side with the elements in the list on the right-hand side.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Regardless of the type of the left-hand operand, the initializer list may be empty. In this case, the compiler generates a value-initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) temporary and assigns that value to the left-hand operand.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Assignment Is Right Associative</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Unlike the other binary operators, assignment is right associative:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival, jval;<br class="calibre6"/>ival = jval = 0; // <span><span class="calibre45"><span class="calibre16">ok: each assigned</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because assignment is right associative, the right-most assignment, <code class="calibre23"><tt class="calibre23"><span class="calibre24">jval = 0</span></tt></code>, is the right-hand operand of the left-most assignment operator. Because assignment returns its left-hand operand, the result of the right-most assignment (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">jval</span></tt></code>) is assigned to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each object in a multiple assignment must have the same type as its right-hand neighbor or a type to which that neighbor can be converted (&#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a>, p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival, *pval; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int; pval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>ival = pval = 0; // <span><span class="calibre45"><span class="calibre16">error: cannot assign the value of a pointer to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>string s1, s2;<br class="calibre6"/>s1 = s2 = "OK";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">string literal</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"OK"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first assignment is illegal because <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pval</span></tt></code> have different types and there is no conversion from the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pval</span></tt></code> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code>) to the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>). It is illegal even though zero is a value that can be assigned to either object.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1075562"/>On the other hand, the second assignment is fine. The string literal is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is assigned to <code class="calibre23"><tt class="calibre23"><span class="calibre24">s2</span></tt></code>. The result of that assignment is <code class="calibre23"><tt class="calibre23"><span class="calibre24">s2</span></tt></code>, which has the same type as <code class="calibre23"><tt class="calibre23"><span class="calibre24">s1</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Assignment Has Low Precedence</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Assignments often occur in conditions. Because assignment has relatively low precedence, we usually must parenthesize the assignment for the condition to work properly. To see why assignment in a condition is useful, consider the following loop. We want to call a function until it returns a desired value&#8212;say, 42:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">a verbose and therefore more error-prone way to write this loop</span></span></span><br class="calibre6"/>int i = get_value();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get the first value</span></span></span><br class="calibre6"/>while (i != 42) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do something ...</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;i = get_value();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get remaining values</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we start by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_value</span></tt></code> followed by a loop whose condition uses the value returned from that call. The last statement in this loop makes another call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_value</span></tt></code>, and the loop repeats. We can write this code more directly as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">a better way to write our loop---what the condition does is now clearer</span></span></span><br class="calibre6"/>while ((i = get_value()) != 42) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do something ...</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The condition now more clearly expresses our intent: We want to continue until <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_value</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>. The condition executes by assigning the result returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_value</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and then comparing the result of that assignment with <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Without the parentheses, the operands to <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> would be the value returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_value</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> result of that test would be assigned to <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>&#8212;clearly not what we intended!</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because assignment has lower precedence than the relational operators, parentheses are usually needed around assignments in conditions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Beware of Confusing Equality and Assignment Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that we can use assignment in a condition can have surprising effects:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (i = j)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The condition in this <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> assigns the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and then tests the result of the assignment. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is nonzero, the condition will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The author of this code almost surely intended to test whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> have the same value:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (i == j)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Bugs of this sort are notoriously difficult to find. Some, but not all, compilers are kind enough to warn about code such as this example.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos1081662"/>Compound Assignment Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We often apply an operator to an object and then assign the result to that same object. As an example, consider the sum program from &#167; <a href="014-1.4._flow_of_control.html#filepos180866">1.4.2</a> (p. <a href="014-1.4._flow_of_control.html#filepos180866">13</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int sum = 0;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">sum values from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">10</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inclusive</span></span></span><br class="calibre6"/>for (int val = 1; val &lt;= 10; ++val)<br class="calibre6"/>&#160;&#160;&#160;&#160;sum += val; //&#160;&#160;<span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum = sum + val</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This kind of operation is common not just for addition but for the other arithmetic operators and the bitwise operators, which we cover in &#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a> (p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">152</a>). There are compound assignments for each of these operators:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">&#160;+=&#160;&#160;&#160;-=&#160;&#160;&#160;*=&#160;&#160;&#160;/=&#160;&#160;&#160;%=&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">arithmetic operators</span></span></span><br class="calibre6"/>&lt;&lt;=&#160;&#160;&gt;&gt;=&#160;&#160;&#160;&amp;=&#160;&#160;&#160;^=&#160;&#160;&#160;|=&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">bitwise operators; see &#167; 4.8 (p. 152</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each compound operator is essentially equivalent to</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">a = a <span><span class="calibre45"><span class="calibre16">op</span></span></span> b;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">with the exception that, when we use the compound assignment, the left-hand operand is evaluated only once. If we use an ordinary assignment, that operand is evaluated twice: once in the expression on the right-hand side and again as the operand on the left hand. In many, perhaps most, contexts this difference is immaterial aside from possible performance consequences.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.13:</strong> What are the values of <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> after each assignment?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;&#160;&#160;&#160;double d;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">d = i = 3.5;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">i = d = 3.5;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.14:</strong> Explain what happens in each of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> tests:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (42 = i)&#160;&#160;&#160;//&#160;&#160;...<br class="calibre6"/>if (i = 42)&#160;&#160;&#160;//&#160;&#160;...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.15:</strong> The following assignment is illegal. Why? How would you correct it?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double dval; int ival; int *pi;<br class="calibre6"/>dval = ival = pi = 0;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.16:</strong> Although the following are legal, they probably do not behave as the programmer expects. Why? Rewrite the expressions as you think they should be.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">if (p = getPtr() != 0)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">if (i = 1024)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="041-4.3._logical_and_relational_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="043-4.5._increment_and_decrement_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
