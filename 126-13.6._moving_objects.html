<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>13.6. Moving Objects</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="125-13.5._classes_that_manage_dynamic_memory.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="127-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3426774" class="calibre29"><span class="bold">13.6. Moving Objects</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">One of the major features in the new standard is the ability to move rather than copy an object. As we saw in &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>), copies are made in many circumstances. In some of these circumstances, an object is immediately destroyed after it is copied. In those cases, moving, rather than copying, the object can provide a significant performance boost.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ve just seen, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class is a good example of this kind of superfluous copy. During reallocation, there is no need to copy&#8212;rather than move&#8212;the elements from the old memory to the new. A second reason to move rather than copy occurs in classes such as the IO or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> classes. These classes have a resource (such as a pointer or an IO buffer) that may not be shared. Hence, objects of these types can&#8217;t be copied but can be moved.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3428100"/>Under earlier versions of the language, there was no direct way to move an object. We had to make a copy even if there was no need for the copy. If the objects are large, or if the objects themselves require memory allocation (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s), making a needless copy can be expensive. Similarly, in previous versions of the library, classes stored in a container had to be copyable. Under the new standard, we can use containers on types that cannot be copied so long as they can be moved.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The library containers, <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> classes support move as well as copy. The IO and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> classes can be moved but not copied.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3429349" class="calibre37"><span class="calibre5">13.6.1. Rvalue References</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<div class="calibre28"><a id="filepos3429517"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">To support move operations, the new standard introduced a new kind of reference, an <strong class="calibre5"><a id="filepos3429696" href="128-defined_terms.html#filepos3542858">rvalue reference</a></strong>. An rvalue reference is a reference that must be bound to an rvalue. An rvalue reference is obtained by using <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>. As we&#8217;ll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. As a result, we are free to &#8220;move&#8221; resources from an rvalue reference to another object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Recall that lvalue and rvalue are properties of an expression (&#167; <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>). Some expressions yield or require lvalues; others yield or require rvalues. Generally speaking, an lvalue expression refers to an object&#8217;s identity whereas an rvalue expression refers to an object&#8217;s value.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Like any reference, an rvalue reference is just another name for an object. As we know, we cannot bind regular references&#8212;which we&#8217;ll refer to as <strong class="calibre5"><a id="filepos3430925" href="128-defined_terms.html#filepos3538303">lvalue references</a></strong> when we need to distinguish them from rvalue references&#8212;to expressions that require a conversion, to literals, or to expressions that return an rvalue (&#167; <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">51</a>). Rvalue references have the opposite binding properties: We can bind an rvalue reference to these kinds of expressions, but we cannot directly bind an rvalue reference to an lvalue:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int &amp;r = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>int &amp;&amp;rr = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot bind an rvalue reference to an lvalue</span></span></span><br class="calibre6"/>int &amp;r2 = i * 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i * 42</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an rvalue</span></span></span><br class="calibre6"/>const int &amp;r3 = i * 42; // <span><span class="calibre45"><span class="calibre16">ok: we can bind a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to an rvalue</span></span></span><br class="calibre6"/>int &amp;&amp;rr2 = i * 42;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: bind</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rr2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the result of the multiplication</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Functions that return lvalue references, along with the assignment, subscript, dereference, and prefix increment/decrement operators, are all examples of expressions that return lvalues. We can bind an lvalue reference to the result of any of these expressions.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Functions that return a nonreference type, along with the arithmetic, relational, bitwise, and postfix increment/decrement operators, all yield rvalues. We cannot bind an lvalue reference to these expressions, but we can bind either an lvalue reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or an rvalue reference to such expressions.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3433996"/>Lvalues Persist; Rvalues Are Ephemeral</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Looking at the list of lvalue and rvalue expressions, it should be clear that lvalues and rvalues differ from each other in an important manner: Lvalues have persistent state, whereas rvalues are either literals or temporary objects created in the course of evaluating expressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because rvalue references can only be bound to temporaries, we know that</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The referred-to object is about to be destroyed</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There can be no other users of that object</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">These facts together mean that code that uses an rvalue reference is free to take over resources from the object to which the reference refers.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Rvalue references refer to objects that are about to be destroyed. Hence, we can &#8220;steal&#8221; state from an object bound to an rvalue reference.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Variables Are Lvalues</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although we rarely think about it this way, a variable is an expression with one operand and no operator. Like any other expression, a variable expression has the lvalue/rvalue property. Variable expressions are lvalues. It may be surprising, but as a consequence, we cannot bind an rvalue reference to a variable defined as an rvalue reference type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int &amp;&amp;rr1 = 42;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: literals are rvalues</span></span></span><br class="calibre6"/>int &amp;&amp;rr2 = rr1;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: the expression</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rr1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Given our previous observation that rvalues represent ephemeral objects, it should not be surprising that a variable is an lvalue. After all, a variable persists until it goes out of scope.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A variable is an lvalue; we cannot directly bind an rvalue reference to a variable <em class="calibre16">even if that variable was defined as an rvalue reference type.</em></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">move</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3437715"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Although we cannot directly bind an rvalue reference to an lvalue, we can explicitly cast an lvalue to its corresponding rvalue reference type. We can also obtain an rvalue reference bound to an lvalue by calling a new library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">move</span></span></tt></span></span></tt></code>, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">utility</span></tt></code> header. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> function uses facilities that we&#8217;ll describe in &#167; <a href="155-16.2._template_argument_deduction.html#filepos4403933">16.2.6</a> (p. <a href="155-16.2._template_argument_deduction.html#filepos4403933">690</a>) to return an rvalue reference to its given object.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int &amp;&amp;rr3 = std::move(rr1);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. It is essential to realize that the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> promises that we do not intend to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">rr1</span></tt></code> again except to assign to it or to destroy it. After a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we cannot make any assumptions about the value of the moved-from object.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos3439682"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, differently from how we use most names from the library, we do not provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration (&#167; <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>) for <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>). We call <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> not <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. We&#8217;ll explain the reasons for this usage in &#167; <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Code that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. Doing so avoids potential name collisions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.6.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.45:</strong> Distinguish between an rvalue reference and an lvalue reference.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.46:</strong> Which kind of reference can be bound to the following initializers?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>int f();<br class="calibre6"/>vector&lt;int&gt; vi(100);<br class="calibre6"/>int? r1 = f();<br class="calibre6"/>int? r2 = vi[0];<br class="calibre6"/>int? r3 = r1;<br class="calibre6"/>int? r4 = vi[0] * f();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.47:</strong> Give the copy constructor and copy-assignment operator in your <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code> class from <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3426130">exercise 13.44</a> in &#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a> (p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">531</a>) a statement that prints a message each time the function is executed.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos3442777"/><strong class="calibre5">Exercise 13.48:</strong> Define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;String&gt;</span></tt></code> and call <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> several times on that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Run your program and see how often <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code>s are copied.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3443291" class="calibre37"><span class="calibre5">13.6.2. Move Constructor and Move Assignment</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class (and other library classes), our own classes can benefit from being able to be moved as well as copied. To enable move operations for our own types, we define a move constructor and a move-assignment operator. These members are similar to the corresponding copy operations, but they &#8220;steal&#8221; resources from their given object rather than copy them.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos3443986"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. As in the copy constructor, any additional parameters must all have default arguments.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In addition to moving resources, the move constructor must ensure that the moved-from object is left in a state such that destroying that object will be harmless. In particular, once its resources are moved, the original object must no longer point to those moved resources&#8212;responsibility for those resources has been assumed by the newly created object.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3444873"/>As an example, we&#8217;ll define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> move constructor to move rather than copy the elements from one <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> to another:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec::StrVec(StrVec &amp;&amp;s) noexcept&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move won't throw any exceptions</span></span></span><br class="calibre6"/>&#160;&#160;// <span><span class="calibre45"><span class="calibre16">member initializers take over the resources in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><br class="calibre6"/>&#160;&#160;: elements(s.elements), first_free(s.first_free), cap(s.cap)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">leave</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in a state in which it is safe to run the destructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;s.elements = s.first_free = s.cap = nullptr;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We&#8217;ll explain the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> (which signals that our constructor does not throw any exceptions) shortly, but let&#8217;s first look at what this constructor does.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike the copy constructor, the move constructor does not allocate any new memory; it takes over the memory in the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. Having taken over the memory from its argument, the constructor body sets the pointers in the given object to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code>. After an object is moved from, that object continues to exist. Eventually, the moved-from object will be destroyed, meaning that the destructor will be run on that object. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> destructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code>. If we neglected to change <code class="calibre23"><tt class="calibre23"><span class="calibre24">s.first_free</span></tt></code>, then destroying the moved-from object would delete the memory we just moved.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Move Operations, Library Containers, and Exceptions</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Because a move operation executes by &#8220;stealing&#8221; resources, it ordinarily does not itself allocate any resources. As a result, move operations ordinarily will not throw any exceptions. When we write a move operation that cannot throw, we should inform the library of that fact. As we&#8217;ll see, unless the library knows that our move constructor won&#8217;t throw, it will do extra work to cater to the possibliity that moving an object of our class type might throw.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos3448327"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">One way inform the library is to specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> on our constructor. We&#8217;ll cover <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code>, which was introduced by the new standard, in more detail in &#167; <a href="171-18.1._exception_handling.html#filepos4896504">18.1.4</a> (p. <a href="171-18.1._exception_handling.html#filepos4896504">779</a>). For now what&#8217;s important to know is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> is a way for us to promise that a function does not throw any exceptions. We specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> on a function after its parameter list. In a constructor, <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> appears between the parameter list and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">:</span></tt></code> that begins the constructor initializer list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrVec {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;StrVec(StrVec&amp;&amp;) noexcept;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>StrVec::StrVec(StrVec &amp;&amp;s) noexcept : /* <span><span class="calibre45"><span class="calibre16">member initializers</span></span></span> */<br class="calibre6"/>{ /* <span><span class="calibre45"><span class="calibre16">constructor body</span></span></span>&#160;&#160;&#160;*/ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We must specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> on both the declaration in the class header and on the definition if that definition appears outside the class.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Move constructors and move assignment operators that cannot throw exceptions should be marked as <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos3451030"/>Understanding why <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> is needed can help deepen our understanding of how the library interacts with objects of the types we write. We need to indicate that a move operation doesn&#8217;t throw because of two interrelated facts: First, although move operations usually don&#8217;t throw exceptions, they are permitted to do so. Second, the library containers provide guarantees as to what they do if an exception happens. As one example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> guarantees that if an exception happens when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> itself will be left unchanged.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Now let&#8217;s think about what happens inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>. Like the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> operation (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">527</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> might require that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> be reallocated. When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is reallocated, it moves the elements from its old space to new memory, just as we did in <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">As we&#8217;ve just seen, moving an object generally changes the value of the moved-from object. If reallocation uses a move constructor and that constructor throws an exception after moving some but not all of the elements, there would be a problem. The moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> would be unable to meet its requirement that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is left unchanged.</p><div class="calibre22">&#160;</div>
<p class="calibre25">On the other hand, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> uses the copy constructor and an exception happens, it can easily meet this requirement. In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. If an exception happens, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> can free the space it allocated (but could not successfully construct) and return. The original <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> elements still exist.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To avoid this potential problem, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> must use a copy constructor instead of a move constructor during reallocation <em class="calibre16">unless it knows</em> that the element type&#8217;s move constructor cannot throw an exception. If we want objects of our type to be moved rather than copied in circumstances such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> reallocation, we must explicity tell the library that our move constructor is safe to use. We do so by marking the move constructor (and move-assignment operator) <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Move-Assignment Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The move-assignment operator does the same work as the destructor and the move constructor. As with the move constructor, if our move-assignment operator won&#8217;t throw any exceptions, we should make it <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code>. Like a copy-assignment operator, a move-assignment operator must guard against self-assignment:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs) noexcept<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">direct test for self-assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (this != &amp;rhs) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;free();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free existing elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elements = rhs.elements; // <span><span class="calibre45"><span class="calibre16">take over resources from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;first_free = rhs.first_free;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cap = rhs.cap;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">leave</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in a destructible state</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rhs.elements = rhs.first_free = rhs.cap = nullptr;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3457066"/>In this case we check directly whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer and the address of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> are the same. If they are, the right- and left-hand operands refer to the same object and there is no work to do. Otherwise, we free the memory that the left-hand operand had used, and then take over the memory from the given object. As in the move constructor, we set the pointers in <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It may seem surprising that we bother to check for self-assignment. After all, move assignment requires an rvalue for the right-hand operand. We do the check because that rvalue could be the result of calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. As in any other assignment operator, it is crucial that we not free the left-hand resources before using those (possibly same) resources from the right-hand operand.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Moved-from Object Must Be Destructible</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Moving from an object does not destroy that object: Sometime after the move operation completes, the moved-from object will be destroyed. Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in which the destructor can be run. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> move operations meet this requirement by setting the pointer members of the moved-from object to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In addition to leaving the moved-from object in a state that is safe to destroy, move operations must guarantee that the object remains valid. In general, a valid object is one that can safely be given a new value or used in other ways that do not depend on its current value. On the other hand, move operations have no requirements as to the value that remains in the moved-from object. As a result, our programs should never depend on the value of a moved-from object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, when we move from a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or container object, we know that the moved-from object remains valid. As a result, we can run operations such as as <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> on moved-from objects. However, we don&#8217;t know what result we&#8217;ll get. We might expect a moved-from object to be empty, but that is not guaranteed.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> move operations leave the moved-from object in the same state as a default-initialized object. Therefore, all the operations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> will continue to run the same way as they do for any other default-initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. Other classes, with more complicated internal structure, may behave differently.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">After a move operation, the &#8220;moved-from&#8221; object must remain a valid, destructible object but users may make no assumptions about its value.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Synthesized Move Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As it does for the copy constructor and copy-assignment operator, the compiler will synthesize the move constructor and move-assignment operator. However, the conditions under which it synthesizes a move operation are quite different from those in which it synthesizes a copy operation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Recall that if we do not declare our own copy constructor or copy-assignment operator the compiler <em class="calibre16">always</em> synthesizes these operations (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a> and &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">13.1.2</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">500</a>). The copy operations are defined either to memberwise copy or assign the object or they are defined as deleted functions.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3462137"/>Differently from the copy operations, for some classes the compiler does not synthesize the move operations <em class="calibre16">at all.</em> In particular, if a class defines its own copy constructor, copy-assignment operator, or destructor, the move constructor and move-assignment operator are not synthesized. As a result, some classes do not have a move constructor or a move-assignment operator. As we&#8217;ll see on page <a href="126-13.6._moving_objects.html#filepos3473849">540</a>, when a class doesn&#8217;t have a move operation, the corresponding copy operation is used in place of move through normal function matching.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The compiler will synthesize a move constructor or a move-assignment operator <em class="calibre16">only</em> if the class doesn&#8217;t define any of its own copy-control members and if every non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member of the class can be moved. The compiler can move members of built-in type. It can also move members of a class type if the member&#8217;s class has the corresponding move operation:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the compiler will synthesize the move operations for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">X</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hasX</span></span></tt></span><br class="calibre6"/>struct X {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">built-in types can be moved</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string s; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">defines its own move operations</span></span></span><br class="calibre6"/>};<br class="calibre6"/>struct hasX {<br class="calibre6"/>&#160;&#160;&#160;&#160;X mem;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">X</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has synthesized move operations</span></span></span><br class="calibre6"/>};<br class="calibre6"/>X x, x2 = std::move(x);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the synthesized move constructor</span></span></span><br class="calibre6"/>hasX hx, hx2 = std::move(hx); // <span><span class="calibre45"><span class="calibre16">uses the synthesized move constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The compiler synthesizes the move constructor and move assignment only if a class does not define any of its own copy-control members and only if all the data members can be moved constructed and move assigned, respectively.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Unlike the copy operations, a move operation is never implicitly defined as a deleted function. However, if we explicitly ask the compiler to generate a move operation by using <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>), and the compiler is unable to move all the members, then the move operation will be defined as deleted. With one important exception, the rules for when a synthesized move operation is defined as deleted are analogous to those for the copy operations (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>):</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Unlike the copy constructor, the move constructor is defined as deleted if the class has a member that defines its own copy constructor but does not also define a move constructor, or if the class has a member that doesn&#8217;t define its own copy operations and for which the compiler is unable to synthesize a move constructor. Similarly for move-assignment.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The move constructor or move-assignment operator is defined as deleted if the class has a member whose own move constructor or move-assignment operator is deleted or inaccessible.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference member.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos3467413"/>For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">Y</span></tt></code> is a class that defines its own copy constructor but does not also define its own move constructor:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">assume <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Y</span></span></tt></span> is a class that defines its own copy constructor but not a move constructor</span></span></span><br class="calibre6"/>struct hasY {<br class="calibre6"/>&#160;&#160;&#160;&#160;hasY() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;hasY(hasY&amp;&amp;) = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;Y mem; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hasY</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will have a deleted move constructor</span></span></span><br class="calibre6"/>};<br class="calibre6"/>hasY hy, hy2 = std::move(hy); // <span><span class="calibre45"><span class="calibre16">error: move constructor is deleted</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The compiler can copy objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Y</span></tt></code> but cannot move them. Class <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasY</span></tt></code> explicitly requested a move constructor, which the compiler is unable to generate. Hence, <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasY</span></tt></code> will get a deleted move constructor. Had <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasY</span></tt></code> omitted the declaration of its move constructor, then the compiler would not synthesize the <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasY</span></tt></code> move constructor at all. The move operations are not synthesized if they would otherwise be defined as deleted.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There is one final interaction between move operations and the synthesized copy-control members: Whether a class defines its own move operations has an impact on how the copy operations are synthesized. If the class defines either a move constructor and/or a move-assignment operator, then the synthesized copy constructor and copy-assignment operator for that class will be defined as deleted.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Classes that define a move constructor or move-assignment operator must also define their own copy operations. Otherwise, those members are deleted by default.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Rvalues Are Moved, Lvalues Are Copied ...</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a class has both a move constructor and a copy constructor, the compiler uses ordinary function matching to determine which constructor to use (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>). Similarly for assignment. For example, in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class the copy versions take a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const StrVec</span></tt></code>. As a result, they can be used on any type that can be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. The move versions take a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec&amp;&amp;</span></tt></code> and can be used only when the argument is a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) rvalue:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec v1, v2;<br class="calibre6"/>v1 = v2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue; copy assignment</span></span></span><br class="calibre6"/>StrVec getVec(istream &amp;); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">getVec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns an rvalue</span></span></span><br class="calibre6"/>v2 = getVec(cin);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">getVec(cin</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is an rvalue; move assignment</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first assignment, we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> to the assignment operator. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> and the expression, <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>, is an lvalue. The move version of assignment is not viable (&#167; <a href="068-6.6._function_matching.html#filepos1674559">6.6</a>, p. <a href="068-6.6._function_matching.html#filepos1674559">243</a>), because we cannot implicitly bind an rvalue reference to an lvalue. Hence, this assignment uses the copy-assignment operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the second assignment, we assign from the result of a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">getVec</span></tt></code>. That expression is an rvalue. In this case, both assignment operators are viable&#8212;we can bind the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">getVec</span></tt></code> to either operator&#8217;s parameter. Calling the copy-assignment operator requires a conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, whereas <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec&amp;&amp;</span></tt></code> is an exact match. Hence, the second assignment uses the move-assignment operator.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3473849"/>...But Rvalues Are Copied If There Is No Move Constructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">What if a class has a copy constructor but does not define a move constructor? In this case, the compiler will not synthesize the move constructor, which means the class has a copy constructor but no move constructor. If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo(const Foo&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members, but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">does not define a move constructor</span></span></span><br class="calibre6"/>};<br class="calibre6"/>Foo x;<br class="calibre6"/>Foo y(x);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">x</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue</span></span></span><br class="calibre6"/>Foo z(std::move(x)); // <span><span class="calibre45"><span class="calibre16">copy constructor, because there is no move constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move(x)</span></tt></code> in the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">z</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&amp;&amp;</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code>. The copy constructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> is viable because we can convert a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&amp;&amp;</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const Foo&amp;</span></tt></code>. Thus, the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">z</span></tt></code> uses the copy constructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that using the copy constructor in place of a move constructor is almost surely safe (and similarly for the assignment operators). Ordinarily, the copy constructor will meet the requirements of the corresponding move constructor: It will copy the given object and leave that original object in a valid state. Indeed, the copy constructor won&#8217;t even change the value of the original object.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a class has a usable copy constructor and no move constructor, objects will be &#8220;moved&#8221; by the copy constructor. Similarly for the copy-assignment operator and move-assignment.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Copy-and-Swap Assignment Operators and Move</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The version of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class that defined a copy-and-swap assignment operator (&#167; <a href="123-13.3._swap.html#filepos3315883">13.3</a>, p. <a href="123-13.3._swap.html#filepos3315883">518</a>) is a good illustration of the interaction between function matching and move operations. If we add a move constructor to this class, it will effectively get a move assignment operator as well:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class HasPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">added move constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(HasPtr &amp;&amp;p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assignment operator is both the move- and copy-assignment operator</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr&amp; operator=(HasPtr rhs)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ swap(*this, rhs); return *this; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in &#167; 13.2.1 (p. 511)</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this version of the class, we&#8217;ve added a move constructor that takes over the values from its given argument. The constructor body sets the pointer member of <a id="filepos3479414"/>the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> to zero to ensure that it is safe to destroy the moved-from object. Nothing this function does can throw an exception so we mark it as <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> (&#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">535</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Now let&#8217;s look at the assignment operator. That operator has a nonreference parameter, which means the parameter is copy initialized (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>). Depending on the type of the argument, copy initialization uses either the copy constructor or the move constructor; lvalues are copied and rvalues are moved. As a result, this single assignment operator acts as both the copy-assignment and move-assignment operator.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, assuming both <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp2</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> objects:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">hp = hp2; //&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hp2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue; copy constructor used to copy</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hp2</span></span></tt></span><br class="calibre6"/>hp = std::move(hp2); // <span><span class="calibre45"><span class="calibre16">move constructor moves</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hp2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first assignment, the right-hand operand is an lvalue, so the move constructor is not viable. The copy constructor will be used to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code>. The copy constructor will allocate a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and copy the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp2</span></tt></code> points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the second assignment, we invoke <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> to bind an rvalue reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp2</span></tt></code>. In this case, both the copy constructor and the move constructor are viable. However, because the argument is an rvalue reference, it is an exact match for the move constructor. The move constructor copies the pointer from <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp2</span></tt></code>. It does not allocate any memory.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Regardless of whether the copy or move constructor was used, the body of the assignment operator <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>s the state of the two operands. Swapping a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> exchanges the pointer (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>) members of the two objects. After the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap, rhs</span></tt></code> will hold a pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that had been owned by the left-hand side. That <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> will be destroyed when <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> goes out of scope.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Updating the Rule of Three</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">All five copy-control members should be thought of as a unit: Ordinarily, if a class defines any of these operations, it usually should define them all. As we&#8217;ve seen, some classes <em class="calibre16">must</em> define the copy constructor, copy-assignment operator, and destructor to work correctly (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>). Such classes typically have a resource that the copy members must copy. Ordinarily, copying a resource entails some amount of overhead. Classes that define the move constructor and move-assignment operator can avoid this overhead in those circumstances where a copy isn&#8217;t necessary.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Move Operations for the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Message</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Classes that define their own copy constructor and copy-assignment operator generally also benefit by defining the move operations. For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code> classes (&#167; <a href="124-13.4._a_copycontrol_example.html#filepos3341274">13.4</a>, p. <a href="124-13.4._a_copycontrol_example.html#filepos3341274">519</a>) should define move operations. By defining move operations, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> class can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> move operations to avoid the overhead of copying the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code> members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, in addition to moving the <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code> member, we must also update each <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code> that points to the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code>. We must remove pointers to the old <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> and add a pointer to the new one.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3486198"/>Both the move constructor and move-assignment operator need to update the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code> pointers, so we&#8217;ll start by defining an operation to do this common work:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">move the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointers from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">m</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Message</span></span></tt></span><br class="calibre6"/>void Message::move_Folders(Message *m)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;folders = std::move(m-&gt;folders); // <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">move assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (auto f : folders) {&#160;&#160;// <span><span class="calibre45"><span class="calibre16">for each</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f-&gt;remMsg(m);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remove the old</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Message</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f-&gt;addMsg(this); // <span><span class="calibre45"><span class="calibre16">add this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Message</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;m-&gt;folders.clear();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ensure that destroying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">m</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is harmless</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This function begins by moving the <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code> set. By calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> move assignment rather than its copy assignment. Had we omitted the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, the code would still work, but the copy is unnecessary. The function then iterates through those <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code>s, removing the pointer to the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> and adding a pointer to the new <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that inserting an element to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> might throw an exception&#8212;adding an element to a container requires memory to be allocated, which means that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code> exception might be thrown (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>). As a result, unlike our <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> move operations, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> move constructor and move-assignment operators might throw exceptions. We will not mark them as <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> (&#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">535</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">The function ends by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">m.folders</span></tt></code>. After the <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">m.folders</span></tt></code> is valid but have no idea what its contents are. Because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> destructor iterates through <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code>, we want to be certain that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> is empty.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> move constructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to move the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> and default initializes its <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code> member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Message::Message(Message &amp;&amp;m): contents(std::move(m.contents))<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;move_Folders(&amp;m); // <span><span class="calibre45"><span class="calibre16">moves</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">folders</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and updates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointers</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the body of the constructor, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move_Folders</span></tt></code> to remove the pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">m</span></tt></code> and insert pointers to this <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The move-assignment operator does a direct check for self-assignment:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Message&amp; Message::operator=(Message &amp;&amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (this != &amp;rhs) {&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">direct check for self-assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;remove_from_Folders();<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;contents = std::move(rhs.contents); // <span><span class="calibre45"><span class="calibre16">move assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;move_Folders(&amp;rhs); // <span><span class="calibre45"><span class="calibre16">reset the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Folder</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s to point to this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Message</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3494424"/>As with any assignment operator, the move-assignment operator must destroy the old state of the left-hand operand. In this case, destroying the left-hand operand requires that we remove pointers to this <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> from the existing <code class="calibre23"><tt class="calibre23"><span class="calibre24">folders</span></tt></code>, which we do in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_from_Folders</span></tt></code>. Having removed itself from its <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code>s, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to move the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> object. What remains is to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move_Messages</span></tt></code> to update the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Folder</span></tt></code> pointers.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Move Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>) used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> to copy the elements from the old memory to the new. As an alternative to writing that loop, it would be easier if we could call <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> to construct the newly allocated space. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> does what it says: It copies the elements. There is no analogous library function to &#8220;move&#8221; objects into unconstructed memory.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Instead, the new library defines a <strong class="calibre5"><a id="filepos3496642" href="128-defined_terms.html#filepos3540653">move iterator</a></strong> adaptor (&#167; <a href="101-10.4._revisiting_iterators.html#filepos2617947">10.4</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2617947">401</a>). A move iterator adapts its given iterator by changing the behavior of the iterator&#8217;s dereference operator. Ordinarily, an iterator dereference operator returns an lvalue reference to the element. Unlike other iterators, the dereference operator of a move iterator yields an rvalue reference.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3497138"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">We transform an ordinary iterator to a move iterator by calling the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_move_iterator</span></tt></code> function. This function takes an iterator and returns a move iterator.</p><div class="calibre22">&#160;</div>
<p class="calibre25">All of the original iterator&#8217;s other operations work as usual. Because these iterators support normal iterator operations, we can pass a pair of move iterators to an algorithm. In particular, we can pass move iterators to <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void StrVec::reallocate()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate space for twice as many elements as the current size</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto newcapacity = size() ? 2 * size() : 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;auto first = alloc.allocate(newcapacity);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto last = uninitialized_copy(make_move_iterator(begin()),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;make_move_iterator(end()),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;first);<br class="calibre6"/>&#160;&#160;&#160;&#160;free();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free the old space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;elements = first;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">update the pointers</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;first_free = last;<br class="calibre6"/>&#160;&#160;&#160;&#160;cap = elements + newcapacity;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> on each element in the input sequence to &#8220;copy&#8221; that element into the destination. That algorithm uses the iterator dereference operator to fetch elements from the input sequence. Because we passed move iterators, the dereference operator yields an rvalue reference, which means <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> will use the move constructor to construct the elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that standard library makes no guarantees about which algorithms can be used with move iterators and which cannot. Because moving an <a id="filepos3500429"/>object can obliterate the source, you should pass move iterators to algorithms only when you are <em class="calibre16">confident</em> that the algorithm does not access an element after it has assigned to that element or passed that element to a user-defined function.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Don&#8217;t Be Too Quick to Move</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because a moved-from object has indeterminate state, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> on an object is a dangerous operation. When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we must be absolutely certain that there can be no other users of the moved-from object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Judiciously used inside class code, <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> can offer significant performance benefits. Casually used in ordinary user code (as opposed to class implementation code), moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.</p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Outside of class implementation code such as move constructors or move-assignment operators, use <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> only when you <em class="calibre16">are certain</em> that you need to do a move and that the move is guaranteed to be safe.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.6.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.49:</strong> Add a move constructor and move-assignment operator to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Message</span></tt></code> classes.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.50:</strong> Put print statements in the move operations in your <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code> class and rerun the program from <a href="126-13.6._moving_objects.html#filepos3442777">exercise 13.48</a> in &#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">534</a>) that used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;String&gt;</span></tt></code> to see when the copies are avoided.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.51:</strong> Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>s cannot be copied, in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>) we wrote a <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> function that returned a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> by value. Explain why that function is legal and how it works.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.52:</strong> Explain in detail what happens in the assignments of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> objects on page <a href="126-13.6._moving_objects.html#filepos3479414">541</a>. In particular, describe step by step what happens to values of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp2</span></tt></code>, and of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> parameter in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> assignment operator.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.53:</strong> As a matter of low-level efficiency, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> assignment operator is not ideal. Explain why. Implement a copy-assignment and move-assignment operator for <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> and compare the operations executed in your new move-assignment operator versus the copy-and-swap version.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.54:</strong> What would happen if we defined a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> move-assignment operator but did not change the copy-and-swap operator? Write code to test your answer.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3505762" class="calibre37"><span class="calibre5">13.6.3. Rvalue References and Member Functions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Member functions other than constructors and assignment can benefit from providing both copy and move versions. Such move-enabled members typically use <a id="filepos3506122"/>the same parameter pattern as the copy/move constructor and the assignment operators&#8212;one version takes an lvalue reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and the second takes an rvalue reference to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, the library containers that define <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> provide two versions: one that has an rvalue reference parameter and the other a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> lvalue reference. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> is the element type, these containers define:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void push_back(const X&amp;); // <span><span class="calibre45"><span class="calibre16">copy: binds to any kind of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">X</span></span></tt></span><br class="calibre6"/>void push_back(X&amp;&amp;);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move: binds only to modifiable rvalues of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">X</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can pass any object that can be converted to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> to the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>. This version copies data from its parameter. We can pass only an rvalue that is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to the second version. This version is an exact match (and a better match) for non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> rvalues and will be run when we pass a modifiable rvalue (&#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">539</a>). This version is free to steal resources from its parameter.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Ordinarily, there is no need to define versions of the operation that take a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const X&amp;&amp;</span></tt></code> or a (plain) <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;</span></tt></code>. Usually, we pass an rvalue reference when we want to &#8220;steal&#8221; from the argument. In order to do so, the argument must not be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Similarly, copying from an object should not change the object being copied. As a result, there is usually no need to define a version that take a (plain) <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;</span></tt></code> parameter.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Overloaded functions that distinguish between moving and copying a parameter typically have one version that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code> and one that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">As a more concrete example, we&#8217;ll give our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class a second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrVec {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(const std::string&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(std::string&amp;&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">unchanged from the original version in &#167; 13.5 (p. 527)</span></span></span><br class="calibre6"/>void StrVec::push_back(const string&amp; s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;chk_n_alloc(); // <span><span class="calibre45"><span class="calibre16">ensure that there is room for another element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">construct a copy of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the element to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">first_free</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.construct(first_free++, s);<br class="calibre6"/>}<br class="calibre6"/>void StrVec::push_back(string &amp;&amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;chk_n_alloc(); // <span><span class="calibre45"><span class="calibre16">reallocates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrVec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if necessary</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.construct(first_free++, std::move(s));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These members are nearly identical. The difference is that the rvalue reference version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to pass its parameter to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code>. As we&#8217;ve seen, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> function uses the type of its second and subsequent arguments to determine which constructor to use. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> returns an rvalue reference, the <a id="filepos3512820"/>type of the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>. Therefore, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor will be used to construct a new last element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> the type of the argument determines whether the new element is copied or moved into the container:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec vec;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrVec</span></span></tt></span><br class="calibre6"/>string s = "some string or another";<br class="calibre6"/>vec.push_back(s);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_back(const string&amp;)</span></span></tt></span><br class="calibre6"/>vec.push_back("done"); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_back(string&amp;&amp;</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These calls differ as to whether the argument is an lvalue (<code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>) or an rvalue (the temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> created from <code class="calibre23"><tt class="calibre23"><span class="calibre24">"done")</span></tt></code>. The calls are resolved accordingly.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Rvalue and Lvalue Reference Member Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, we can call a member function on an object, regardless of whether that object is an lvalue or an rvalue. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s1 = "a value", s2 = "another";<br class="calibre6"/>auto n = (s1 + s2).find('a');</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we called the <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> member (&#167; <a href="093-9.5._additional_string_operations.html#filepos2401949">9.5.3</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2401949">364</a>) on the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> rvalue that results from adding two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Sometimes such usage can be surprising:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">s1 + s2 = "wow!";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we assign to the rvalue result of concatentating these <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Prior to the new standard, there was no way to prevent such usage. In order to maintain backward compatability, the library classes continue to allow assignment to rvalues, However, we might want to prevent such usage in our own classes. In this case, we&#8217;d like to force the left-hand operand (i.e., the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> points) to be an lvalue.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3516732"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">We indicate the lvalue/rvalue property of <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> in the same way that we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member functions (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>); we place a <strong class="calibre5"><a id="filepos3517146" href="128-defined_terms.html#filepos3541971">reference qualifier</a></strong> after the parameter list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo &amp;operator=(const Foo&amp;) &amp;; // <span><span class="calibre45"><span class="calibre16">may assign only to modifiable lvalues</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>};<br class="calibre6"/>Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp;<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do whatever is needed to assign</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to this object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The reference qualifier can be either <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>, indicating that <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> may point to an rvalue or lvalue, respectively. Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualifier, a reference qualifier may appear only on a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>) member function and must appear in both the declaration and definition of the function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We may run a function qualified by <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> only on an lvalue and may run a function qualified by <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code> only on an rvalue:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3519362"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Foo &amp;retFoo();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns a reference; a call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retFoo</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue</span></span></span><br class="calibre6"/>Foo retVal();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns by value; a call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retVal</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an rvalue</span></span></span><br class="calibre6"/>Foo i, j;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are lvalues</span></span></span><br class="calibre6"/>i = j;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an lvalue</span></span></span><br class="calibre6"/>retFoo() = j;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retFoo(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">returns an lvalue</span></span></span><br class="calibre6"/>retVal() = j;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retVal(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">returns an rvalue</span></span></span><br class="calibre6"/>i = retVal();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: we can pass an rvalue as the right-hand operand to assignment</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A function can be both <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and reference qualified. In such cases, the reference qualifier must follow the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualifier:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo someMem() &amp; const;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">qualifier must come first</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Foo anotherMem() const &amp;; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">qualifier comes first</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading and Reference Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as we can overload a member function based on whether it is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="075-7.3._additional_class_features.html#filepos1876631">7.3.2</a>, p. <a href="075-7.3._additional_class_features.html#filepos1876631">276</a>), we can also overload a function based on its reference qualifier. Moreover, we may overload a function by its reference qualifier and by whether it is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member. As an example, we&#8217;ll give <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> member and a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> that returns a copy of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> object in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is sorted:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted() &amp;&amp;;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">may run on modifiable rvalues</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted() const &amp;;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">may run on any kind of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;int&gt; data;<br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this object is an rvalue, so we can sort in place</span></span></span><br class="calibre6"/>Foo Foo::sorted() &amp;&amp;<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;sort(data.begin(), data.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this object is either</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or it is an lvalue; either way we can't sort in place</span></span></span><br class="calibre6"/>Foo Foo::sorted() const &amp; {<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo ret(*this);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">make a copy</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;sort(ret.data.begin(), ret.data.end()); // <span><span class="calibre45"><span class="calibre16">sort the copy</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return the copy</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we run <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> on an rvalue, it is safe to sort the <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member directly. The object is an rvalue, which means it has no other users, so we can change the object itself. When we run <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> rvalue or on an lvalue, we can&#8217;t change this object, so we copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> before sorting it.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Overload resolution uses the lvalue/rvalue property of the object that calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> to determine which version is used:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3527078"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">retVal().sorted(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retVal(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is an rvalue, calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo::sorted() &amp;&amp;</span></span></tt></span><br class="calibre6"/>retFoo().sorted(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">retFoo(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is an lvalue, calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo::sorted() const &amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">When we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> memeber functions, we can define two versions that differ only in that one is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualified and the other is not. There is no similar default for reference qualified functions. When we define two or more members that have the same name and the same parameter list, we must provide a reference qualifier on all or none of those functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted() &amp;&amp;;<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted() const; // <span><span class="calibre45"><span class="calibre16">error: must have reference qualifier</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">Comp is type alias for the function type (see &#167; 6.7 (p. 249))</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">that can be used to compare</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">values</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;using Comp = bool(const int&amp;, const int&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted(Comp*);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: different parameter list</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Foo sorted(Comp*) const;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: neither version is reference qualified</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here the declaration of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> that has no parameters is an error. There is a second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> that has no parameters and that function has a reference qualifier, so the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of that function must have a reference qualifier as well. On the other hand, the versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> that take a pointer to a comparison operation are fine, because neither function has a qualifier.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a member function has a reference qualifier, all the versions of that member with the same parameter list must have reference qualifiers.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.6.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.55:</strong> Add an rvalue reference version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.56:</strong> What would happen if we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> as:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>Foo Foo::sorted() const &amp; {<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo ret(*this);<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret.sorted();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.57:</strong> What if we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> as:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>Foo Foo::sorted() const &amp; { return Foo(*this).sorted(); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.58:</strong> Write versions of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> with print statements in their <code class="calibre23"><tt class="calibre23"><span class="calibre24">sorted</span></tt></code> functions to test your answers to the previous two exercises.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="125-13.5._classes_that_manage_dynamic_memory.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="127-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
