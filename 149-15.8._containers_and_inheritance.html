<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.8. Containers and Inheritance</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="148-15.7._constructors_and_copy_control.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="150-15.9._text_queries_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4017857" class="calibre29"><span class="bold"><a id="filepos4017890" class="calibre2"/>15.8. Containers and Inheritance</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">When we use a container to store objects from an inheritance hierarchy, we generally must store those objects indirectly. We cannot put objects of types related by inheritance directly into a container, because there is no way to define a container that holds elements of differing types.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, assume we want to define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to hold several books that a customer wants to buy. It should be easy to see that we can&#8217;t use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> objects. We can&#8217;t convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">602</a>), so we wouldn&#8217;t be able to put <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects into that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It may be somewhat less obvious that we also can&#8217;t use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>. In this case, we can put <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> objects into the container. However, those objects would no longer be <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> objects:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;Quote&gt; basket;<br class="calibre6"/>basket.push_back(Quote("0-201-82470-1", 50));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok, but copies only the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">part of the object into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">basket</span></span></tt></span><br class="calibre6"/>basket.push_back(Bulk_quote("0-201-54848-8", 50, 10, .25));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">calls version defined by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">750,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">i.e., 15 * $50</span></span></span><br class="calibre6"/>cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">basket</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects. When we add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> its derived part is ignored (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because derived objects are &#8220;sliced down&#8221; when assigned to a base-type object, containers and types related by inheritance do not mix well.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Put (Smart) Pointers, Not Objects, in Containers</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we need a container that holds objects related by inheritance, we typically define the container to hold pointers (preferably smart pointers (&#167;<a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">12.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">450</a>)) to the base class. As usual, the dynamic type of the object to which those pointers point might be the base-class type or a type derived from that base:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;<br class="calibre6"/>basket.push_back(make_shared&lt;Quote&gt;("0-201-82470-1", 50));<br class="calibre6"/>basket.push_back(<br class="calibre6"/>&#160;&#160;&#160;&#160;make_shared&lt;Bulk_quote&gt;("0-201-54848-8", 50, 10, .25));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">calls the version defined by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">562.5,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">i.e., 15 * $50 less the discount</span></span></span><br class="calibre6"/>cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">basket</span></tt></code> holds <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s, we must dereference the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">basket.back()</span></tt></code> to get the object on which to run <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>. We do so by using <code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code> in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>. As usual, the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> that is called depends on the dynamic type of the object to which that pointer points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">basket</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Quote&gt;</span></tt></code>, yet in the second <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> we passed a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object. Just as we can convert an ordinary pointer to a derived type to a pointer to an base-class type (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), we can also convert a smart pointer to a derived type to a <a id="filepos4025113"/>smart pointer to an base-class type. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared&lt;Bulk_quote&gt;</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Bulk_quote&gt;</span></tt></code> object, which is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Quote&gt;</span></tt></code> when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>. As a result, despite appearances, all of the elements of <code class="calibre23"><tt class="calibre23"><span class="calibre24">basket</span></tt></code> have the same type.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.8</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.28:</strong> Define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects but put <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> objects into that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Compute the total <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> of all the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.29:</strong> Repeat your program, but this time store <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s to objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>. Explain any discrepancy in the sum generated by the this version and the previous program. If there is no discrepancy, explain why there isn&#8217;t one.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4027082" class="calibre37"><span class="calibre5">15.8.1. Writing a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Basket</span></span></tt></span></span></tt></code> Class</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">One of the ironies of object-oriented programming in C++ is that we cannot use objects directly to support it. Instead, we must use pointers and references. Because pointers impose complexity on our programs, we often define auxiliary classes to help manage that complexity. We&#8217;ll start by defining a class to represent a basket:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Basket {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Basket</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses synthesized default constructor and copy-control members</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void add_item(const std::shared_ptr&lt;Quote&gt; &amp;sale)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ items.insert(sale); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints the total price for each book and the overall total for all items in the basket</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double total_receipt(std::ostream&amp;) const;<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function to compare</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s needed by the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">multiset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;static bool compare(const std::shared_ptr&lt;Quote&gt; &amp;lhs,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::shared_ptr&lt;Quote&gt; &amp;rhs)<br class="calibre6"/>&#160;&#160;&#160;&#160;{ return lhs-&gt;isbn() &lt; rhs-&gt;isbn(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">multiset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to hold multiple quotes, ordered by the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items{compare};<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our class uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> (&#167;<a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">423</a>) to hold the transactions, so that we can store multiple transactions for the same book, and so that all the transactions for a given book will be kept together (&#167;<a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">424</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">The elements in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s and there is no less-than operator for <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. As a result, we must provide our own comparison operation to order the elements (&#167;<a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). Here, we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private static</span></tt></code> member, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>, that compares the <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code>s of the objects to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s point. We initialize our <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> to use this comparison function through an in-class initializer (&#167;<a href="075-7.3._additional_class_features.html#filepos1852806">7.3.1</a>, p. <a href="075-7.3._additional_class_features.html#filepos1852806">274</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4031746"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">multiset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to hold multiple quotes, ordered by the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span><br class="calibre6"/>std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;items{compare};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This declaration can be hard to read, but reading from left to right, we see that we are defining a <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> will use a function with the same type as our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> member to order the elements. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> member is named <code class="calibre23"><tt class="calibre23"><span class="calibre24">items</span></tt></code>, and we&#8217;re initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">items</span></tt></code> to use our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining the Members of <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Basket</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Basket</span></tt></code> class defines only two operations. We defined the <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> member inside the class. That member takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a dynamically allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> and puts that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> into the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code>. The second member, <code class="calibre23"><tt class="calibre23"><span class="calibre24">total_receipt</span></tt></code>, prints an itemized bill for the contents of the basket and returns the price for all the items in the basket:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double Basket::total_receipt(ostream &amp;os) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;double sum = 0.0;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">holds the running total</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to the first element in a batch of elements with the same</span></span></span>
<span><span class="calibre50">ISBN</span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">upper_bound</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns an iterator to the element just past the end of that batch</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (auto iter = items.cbegin();<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter != items.cend();<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter = items.upper_bound(*iter)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we know there's at least one element with this key in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Basket</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the line item for this book</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += print_total(os, **iter, items.count(*iter));<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;os &lt;&lt; "Total Sale: " &lt;&lt; sum &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print the final overall total</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return sum;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop starts by defining and initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> to refer to the first element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code>. The condition checks whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">items.cend()</span></tt></code>. If so, we&#8217;ve processed all the purchases and we drop out of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>. Otherwise, we process the next book.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The interesting bit is the &#8220;increment&#8221; expression in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>. Rather than the usual loop that reads each element, we advance <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> to refer to the next key. We skip over all the elements that match the current key by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> (&#167;<a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">438</a>). The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> returns the iterator that refers to the element just past the last one with the same key as in <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code>. The iterator we get back denotes either the end of the set or the next book.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> (&#167;<a href="142-15.1._oop_an_overview.html#filepos3782427">15.1</a>, p. <a href="142-15.1._oop_an_overview.html#filepos3782427">593</a>) to print the details for each book in the basket:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">sum += print_total(os, **iter, items.count(*iter));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> are an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> on which to write, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object to process, and a count. When we dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code>, we get a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>
<a id="filepos4039452"/>that points to the object we want to print. To get that object, we must dereference that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">**iter</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object (or an object of a type derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>). We use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset count</span></tt></code> member (&#167;<a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">436</a>) to determine how many elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">multiset</span></tt></code> have the same key (i.e., the same <small class="calibre48">ISBN</small>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> makes a virtual call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>, so the resulting price depends on the dynamic type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">**iter</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> function prints the total for the given book and returns the total price that it calculated. We add that result into <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code>, which we print after we complete the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Hiding the Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Basket</span></tt></code> still have to deal with dynamic memory, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. As a result, users have to write code such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Basket bsk;<br class="calibre6"/>bsk.add_item(make_shared&lt;Quote&gt;("123", 45));<br class="calibre6"/>bsk.add_item(make_shared&lt;Bulk_quote&gt;("345", 45, 3, .15));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our next step will be to redefine <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> so that it takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object instead of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. This new version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> will handle the memory allocation so that our users no longer need to do so. We&#8217;ll define two versions, one that will copy its given object and the other that will move from it (&#167;<a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a>, p. <a href="126-13.6._moving_objects.html#filepos3505762">544</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void add_item(const Quote&amp; sale);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the given object</span></span></span><br class="calibre6"/>void add_item(Quote&amp;&amp; sale);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the given object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The only problem is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> doesn&#8217;t know what type to allocate. When it does its memory allocation, <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> will copy (or move) its <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code> parameter. Somewhere there will be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression such as:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">new Quote(sale)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Unfortunately, this expression won&#8217;t do the right thing: <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> allocates an object of the type we request. This expression allocates an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> and copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> portion of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code>. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code> might refer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object, in which case, that object will be sliced down.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Simulating Virtual Copy</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">We&#8217;ll solve this problem by giving our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> classes a virtual member that allocates a copy of itself.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">virtual function to return a dynamically allocated copy of itself</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">these members use reference qualifiers; see &#167;13.6.3 (p. 546)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual Quote* clone() const &amp; {return new Quote(*this);}<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual Quote* clone() &amp;&amp;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{return new Quote(std::move(*this));}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>class Bulk_quote : public Quote {<br class="calibre6"/>&#160;&#160;&#160;&#160;Bulk_quote* clone() const &amp; {return new Bulk_quote(*this);}<br class="calibre6"/>&#160;&#160;&#160;&#160;Bulk_quote* clone() &amp;&amp;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{return new Bulk_quote(std::move(*this));}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a/>Because we have a copy and a move version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code>, we defined lvalue and rvalue versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> (&#167;<a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a>, p. <a href="126-13.6._moving_objects.html#filepos3505762">546</a>). Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> function allocates a new object of its own type. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> lvalue reference member copies itself into that newly allocated object; the rvalue reference member moves its own data.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code>, it is easy to write our new versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Basket {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;void add_item(const Quote&amp; sale) // <span><span class="calibre45"><span class="calibre16">copy the given object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;{ items.insert(std::shared_ptr&lt;Quote&gt;(sale.clone())); }<br class="calibre6"/>&#160;&#160;&#160;&#160;void add_item(Quote&amp;&amp; sale)&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the given object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;{ items.insert(<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::shared_ptr&lt;Quote&gt;(std::move(sale).clone())); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> itself, <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> is overloaded based on whether it is called on an lvalue or an rvalue. Thus, the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">add_item</span></tt></code> calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> lvalue version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code>, and the second version calls the rvalue reference version. Note that in the rvalue version, although the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code> is an rvalue reference type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code> (like any other variable) is an lvalue (&#167;<a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>). Therefore, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to bind an rvalue reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> function is also virtual. Whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> function is run, depends (as usual) on the dynamic type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sale</span></tt></code>. Regardless of whether we copy or move the data, <code class="calibre23"><tt class="calibre23"><span class="calibre24">clone</span></tt></code> returns a pointer to a newly allocated object, of its own type. We bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to that object and call <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> to add this newly allocated object to <code class="calibre23"><tt class="calibre23"><span class="calibre24">items</span></tt></code>. Note that because <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> supports the derived-to-base conversion (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), we can bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Quote</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote*</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.8.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.30:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Basket</span></tt></code> class and use it to compute prices for the same transactions as you used in the previous exercises.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="148-15.7._constructors_and_copy_control.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="150-15.9._text_queries_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
