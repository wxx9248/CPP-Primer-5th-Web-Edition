<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Defined Terms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="117-chapter_summary.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="119-part_iii_tools_for_class_authors.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3186257" class="calibre29"><span class="bold">Defined Terms</span></h3><div class="calibre12">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3186396" href="115-12.2._dynamic_arrays.html#filepos3124364"><strong class="calibre5">allocator</strong></a> Library class that allocates unconstructed memory.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3186618" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2993303"><strong class="calibre5">dangling pointer</strong></a> A pointer that refers to memory that once had an object but no longer does. Program errors due to dangling pointers are notoriously difficult to debug.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3186948" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2905384"><strong class="calibre5">delete</strong></a> Frees memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete p</span></tt></code> frees the object and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete [] p</span></tt></code> frees the array to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points. <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> may be null or point to memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3187653" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3034110"><strong class="calibre5">deleter</strong></a> Function passed to a smart pointer to use in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> when destroying the object to which the pointer is bound.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3188004" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2924901"><strong class="calibre5">destructor</strong></a> Special member function that cleans up an object when the object goes out of scope or is deleted.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3188274" href="113-chapter_12._dynamic_memory.html#filepos2904080"><strong class="calibre5">dynamically allocated</strong></a> Object that is allocated on the free store. Objects allocated on the free store exist until they are explicitly deleted or the program terminates.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3188604" href="113-chapter_12._dynamic_memory.html#filepos2903894"><strong class="calibre5">free store</strong></a> Memory pool available to a program to hold dynamically allocated objects.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3188850" href="113-chapter_12._dynamic_memory.html#filepos2903969"><strong class="calibre5">heap</strong></a> Synonym for free store.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3189040" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2905091"><strong class="calibre5">new</strong></a> Allocates memory from the free store. <code class="calibre23"><tt class="calibre23"><span class="calibre24">new T</span></tt></code> allocates and constructs an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> and returns a pointer to that object; if <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is an array type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> returns a pointer to the first element in the array. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new [<span><span class="calibre45"><span class="calibre16">n</span></span></span>] T</span></tt></code> allocates <em class="calibre16">n</em> objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> and returns a pointer to the first element in the array. By default, the allocated object is default initialized. We may also provide optional initializers.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3190070" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2976074"><strong class="calibre5">placement new</strong></a> Form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> that takes additional arguments passed in parentheses following the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>; for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new (nothrow) int</span></tt></code> tells <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> that it should not throw an exception.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3190670" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2919362"><strong class="calibre5">reference count</strong></a> Counter that tracks how many users share a common object. Used by smart pointers to know when it is safe to delete memory to which the pointers point.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3190998" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906648"><strong class="calibre5">shared_ptr</strong></a> Smart pointer that provides shared ownership: The object is deleted when the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> pointing to that object is destroyed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3191364" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906215"><strong class="calibre5">smart pointer</strong></a> Library type that acts like a pointer but can be checked to see whether it is safe to use. The type takes care of deleting memory when appropriate.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3191687" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906897"><strong class="calibre5">unique_ptr</strong></a> Smart pointer that provides single ownership: The object is deleted when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> pointing to that object is destroyed. <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>s cannot be directly copied or assigned.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos3192162" href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907187"><strong class="calibre5">weak_ptr</strong></a> Smart pointer that points to an object managed by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> does not count <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>s when deciding whether to delete its object.</p></blockquote><div class="calibre15">&#160;</div>  <div class="mbppagebreak" id="calibre_pb_51"/><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="117-chapter_summary.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="119-part_iii_tools_for_class_authors.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
