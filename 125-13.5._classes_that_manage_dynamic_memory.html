<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>13.5. Classes That Manage Dynamic Memory</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="124-13.4._a_copycontrol_example.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="126-13.6._moving_objects.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3380687" class="calibre29"><span class="bold">13.5. Classes That Manage Dynamic Memory</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Some classes need to allocate a varying amount of storage at run time. Such classes often can (and if they can, generally should) use a library container to hold their data. For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to manage the underlying storage for its elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, this strategy does not work for every class; some classes need to do their own allocation. Such classes generally must define their own copy-control members to manage the memory they allocate.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3381616"/>As an example, we&#8217;ll implement a simplification of the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> class. Among the simplifications we&#8217;ll make is that our class will not be a template. Instead, our class will hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Thus, we&#8217;ll call our class <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrVec</span></span></tt></span></span></tt></code> Class Design</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Recall that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> class stores its elements in contiguous storage. To obtain acceptable performance, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> preallocates enough storage to hold more elements than are needed (&#167; <a href="092-9.4._how_a_vector_grows.html#filepos2347166">9.4</a>, p. <a href="092-9.4._how_a_vector_grows.html#filepos2347166">355</a>). Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> member that adds elements checks whether there is space available for another element. If so, the member constructs an object in the next available spot. If there isn&#8217;t space left, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is reallocated: The <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> obtains new space, moves the existing elements into that space, frees the old space, and adds the new element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We&#8217;ll use a similar strategy in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class. We&#8217;ll use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> to obtain raw memory (&#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">481</a>). Because the memory an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> allocates is unconstructed, we&#8217;ll use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> member to create objects in that space when we need to add an element. Similarly, when we remove an element, we&#8217;ll use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> member to destroy the element.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> will have three pointers into the space it uses for its elements:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">elements</span></tt></code>, which points to the first element in the allocated memory</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code>, which points just after the last actual element</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">cap</span></tt></code>, which points just past the end of the allocated memory</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25"><a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3385235">Figure 13.2</a> illustrates the meaning of these pointers.</p><div class="calibre22">&#160;</div>
<div class="calibre52"><a id="filepos3385235"/><img alt="Image" src="images/00098.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 13.2. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrVec</span></span></tt></span></span></tt></code> Memory Allocation Strategy</span></p><div class="calibre12">&#160;</div>
<p class="calibre25">In addition to these pointers, <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> will have a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc</span></tt></code> that is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator&lt;string&gt;</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc</span></tt></code> member will allocate the memory used by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. Our class will also have four utility functions:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> will allocate space and copy a given range of elements.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> will destroy the constructed elements and deallocate the space.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> will ensure that there is room to add at least one more element to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. If there isn&#8217;t room for another element, <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> to get more space.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> will reallocate the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> when it runs out of space.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Although our focus is on the implementation, we&#8217;ll also define a few members from <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s interface.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos3387712"/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrVec</span></span></tt></span></span></tt></code> Class Definition</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Having sketched the implementation, we can now define our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">simplified implementation of the memory allocation strategy for a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>-<span><span class="calibre45"><span class="calibre16">like class</span></span></span><br class="calibre6"/>class StrVec {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;StrVec(): // <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">allocator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member is default initialized</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;elements(nullptr), first_free(nullptr), cap(nullptr) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;StrVec(const StrVec&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;StrVec &amp;operator=(const StrVec&amp;); // <span><span class="calibre45"><span class="calibre16">copy assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~StrVec();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(const std::string&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;size_t size() const { return first_free - elements; }<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t capacity() const { return cap - elements; }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *begin() const { return elements; }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *end() const { return first_free; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::allocator&lt;std::string&gt; alloc; // <span><span class="calibre45"><span class="calibre16">allocates the elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">used by the functions that add elements to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrVec</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void chk_n_alloc()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ if (size() == capacity()) reallocate(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">utilities used by the copy constructor, assignment operator, and destructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::pair&lt;std::string*, std::string*&gt; alloc_n_copy<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(const std::string*, const std::string*);<br class="calibre6"/>&#160;&#160;&#160;&#160;void free();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroy the elements and free the space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void reallocate();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get more space and copy the existing elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *elements;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">pointer to the first element in the array</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *first_free; // <span><span class="calibre45"><span class="calibre16">pointer to the first free element in the array</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *cap;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">pointer to one past the end of the array</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The class body defines several of its members:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The default constructor (implicitly) default initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc</span></tt></code> and (explicitly) initializes the pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code>, indicating that there are no elements.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> member returns the number of elements actually in use, which is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free - elements</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> member returns the number of elements that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> can hold, which is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cap - elements</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> causes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> to be reallocated when there is no room to add another element, which happens when <code class="calibre23"><tt class="calibre23"><span class="calibre24">cap == first_free</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members return pointers to the first (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">elements</span></tt></code>) and one past the last constructed element (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free)</span></tt></code>, respectively.</p></blockquote><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">construct</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> function calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> to ensure that there is room for an element. If necessary, <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code>
<a id="filepos3394973"/>returns, <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> knows that there is room for the new element. It asks its <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> member to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> a new last element:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void StrVec::push_back(const string&amp; s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;chk_n_alloc(); // <span><span class="calibre45"><span class="calibre16">ensure that there is room for another element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">construct a copy of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the element to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">first_free</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.construct(first_free++, s);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> to allocate memory, we must remember that the memory is <em class="calibre16">unconstructed</em> (&#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">482</a>). To use this raw memory we must call <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code>, which will construct an object in that memory. The first argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> must be a pointer to unconstructed space allocated by a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code>. The remaining arguments determine which constructor to use to construct the object that will go in that space. In this case, there is only one additional argument. That argument has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, so this call uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> copy constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> also increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code> to indicate that a new element has been constructed. It uses the postfix increment (&#167; <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">4.5</a>, p. <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">147</a>), so this call constructs an object in the current value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code> and increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code> to point to the next, unconstructed element.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">alloc_n_copy</span></span></tt></span></span></tt></code> Member</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> member is called when we copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, will have valuelike behavior (&#167; <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">13.2.1</a>, p. <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">511</a>); when we copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>, we have to allocate independent memory and copy the elements from the original to the new <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> member will allocate enough storage to hold its given range of elements, and will copy those elements into the newly allocated space. This function returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) of pointers, pointing to the beginning of the new space and just past the last element it copied:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pair&lt;string*, string*&gt;<br class="calibre6"/>StrVec::alloc_n_copy(const string *b, const string *e)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate space to hold as many elements as are in the range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto data = alloc.allocate(e - b);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initialize and return a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructed from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the value returned by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">uninitialized_copy</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return {data, uninitialized_copy(b, e, data)};<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> calculates how much space to allocate by subtracting the pointer to the first element from the pointer one past the last. Having allocated memory, the function next has to construct copies of the given elements in that space.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It does the copy in the return statement, which list initializes the return value (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">226</a>). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member of the returned <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> points to the start of the allocated memory; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> is the value returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code>
<a id="filepos3401856"/>(&#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">483</a>). That value will be pointer positioned one element past the last constructed element.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">free</span></span></tt></span></span></tt></code> Member</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> member has two responsibilities: It must <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> the elements and then deallocate the space that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> itself allocated. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> member <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> in reverse order, starting with the last constructed element and finishing with the first:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void StrVec::free()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">may not pass</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">deallocate</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">a 0 pointer; if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">elements</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is 0, there's no work to do</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (elements) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroy the old elements in reverse order</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (auto p = first_free; p != elements; /* <span><span class="calibre45"><span class="calibre16">empty</span></span></span> */)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alloc.destroy(--p);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alloc.deallocate(elements, cap - elements);<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> function runs the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor frees whatever storage was allocated by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s themselves.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Once the elements have been destroyed, we free the space that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> allocated by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code>. The pointer we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code> must be one that was previously generated by a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code>. Therefore, we first check that <code class="calibre23"><tt class="calibre23"><span class="calibre24">elements</span></tt></code> is not null before calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Copy-Control Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Given our <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> members, the copy-control members of our class are straightforward. The copy constructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec::StrVec(const StrVec &amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alloc_n_copy</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to allocate exactly as many elements as in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto newdata = alloc_n_copy(s.begin(), s.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;elements = newdata.first;<br class="calibre6"/>&#160;&#160;&#160;&#160;first_free = cap = newdata.second;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">and assigns the results from that call to the data members. The return value from <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> of pointers. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> pointer points to the first constructed element and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> points just past the last constructed element. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> allocates space for exactly as many elements as it is given, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cap</span></tt></code> also points just past the last constructed element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The destructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec::~StrVec() { free(); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The copy-assignment operator calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> before freeing its existing elements. By doing so it protects against self-assignment:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3408459"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec &amp;StrVec::operator=(const StrVec &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alloc_n_copy</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to allocate exactly as many elements as in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto data = alloc_n_copy(rhs.begin(), rhs.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;free();<br class="calibre6"/>&#160;&#160;&#160;&#160;elements = data.first;<br class="calibre6"/>&#160;&#160;&#160;&#160;first_free = cap = data.second;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like the copy constructor, the copy-assignment operator uses the values returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc_n_copy</span></tt></code> to initialize its pointers.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Moving, Not Copying, Elements during Reallocation</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Before we write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> member, we should think a bit about what it must do. This function will</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Allocate memory for a new, larger array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Construct the first part of that space to hold the existing elements</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Destroy the elements in the existing memory and deallocate that memory</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">Looking at this list of steps, we can see that reallocating a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> entails copying each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> from the old <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> memory to the new. Although we don&#8217;t know the details of how <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is implemented, we do know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s have valuelike behavior. When we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, the new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> are independent from each other. Changes made to the original don&#8217;t affect the copy, and vice versa.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s act like values, we can conclude that each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> must have its own copy of the characters that make up that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> must allocate memory for those characters, and destroying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> must free the memory used by that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> copies the data because ordinarily after we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, there are two users of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. However, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>, there will be only one user of these <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s after the copy. As soon as we copy the elements from the old space to the new, we will immediately destroy the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Copying the data in these <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s is unnecessary. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>&#8217;s performance will be <em class="calibre16">much</em> better if we can avoid the overhead of allocating and deallocating the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s themselves each time we reallocate.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Move Constructors and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::move</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3413925"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">We can avoid copying the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s by using two facilities introduced by the new library. First, several of the library classes, including <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, define so-called &#8220;move constructors.&#8221; The details of how the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor works&#8212;like any other detail about the implementation&#8212;are not disclosed. However, we do know that move constructors typically operate by &#8220;moving&#8221; resources from <a id="filepos3414627"/>the given object to the object being constructed. We also know that the library guarantees that the &#8220;moved-from&#8221; <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> remains in a valid, destructible state. For <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we can imagine that each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> has a pointer to an array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. Presumably the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor copies the pointer rather than allocating space for and copying the characters themselves.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second facility we&#8217;ll use is a library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos3415546" href="128-defined_terms.html#filepos3539390">move</a></span></span></tt></span></span></tt></code>, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">utility</span></tt></code> header. For now, there are two important points to know about <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. First, for reasons we&#8217;ll explain in &#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>), when <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> constructs the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s in the new memory it must call <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to signal that it wants to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor. If it omits the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> the copy constructor will be used. Second, for reasons we&#8217;ll cover in &#167; <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>), we usually do not provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration (&#167; <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>) for <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">reallocate</span></span></tt></span></span></tt></code> Member</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Using this information, we can now write our <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code> member. We&#8217;ll start by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code> to allocate new space. We&#8217;ll double the capacity of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> each time we reallocate. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> is empty, we allocate room for one element:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void StrVec::reallocate()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we'll allocate space for twice as many elements as the current size</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;auto newcapacity = size() ? 2 * size() : 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate new memory</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;auto newdata = alloc.allocate(newcapacity);<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the data from the old memory to the new</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;auto dest = newdata;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">points to the next free position in the new array</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;auto elem = elements; // <span><span class="calibre45"><span class="calibre16">points to the next element in the old array</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;for (size_t i = 0; i != size(); ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;alloc.construct(dest++, std::move(*elem++));<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;free();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free the old space once we've moved the elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">update our data structure to point to the new elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;elements = newdata;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;first_free = dest;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;cap = elements + newcapacity;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop iterates through the existing elements and <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code>s a corresponding element in the new space. We use <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> to point to the memory in which to construct the new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and use <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem</span></tt></code> to point to an element in the original array. We use postfix increment to move the <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem</span></tt></code>) pointers one element at a time through these two arrays.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second argument in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> (i.e., the one that determines which constructor to use (&#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">482</a>)) is the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> returns a result that causes <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor. Because we&#8217;re using the move constructor, the memory managed by those <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s will not be copied. Instead, each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> we construct will take over ownership of the memory from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem</span></tt></code> points.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3421969"/>After moving the elements, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> to destroy the old elements and free the memory that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> was using before the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reallocate</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s themselves no longer manage the memory to which they had pointed; responsibility for their data has been moved to the elements in the new <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> memory. We don&#8217;t know what value the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s in the old <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> memory have, but we are guaranteed that it is safe to run the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor on these objects.</p><div class="calibre22">&#160;</div>
<p class="calibre25">What remains is to update the pointers to address the newly allocated and initialized array. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cap</span></tt></code> pointers are set to denote one past the last constructed element and one past the end of the allocated space, respectively.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.39:</strong> Write your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>, including versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> (&#167; <a href="092-9.4._how_a_vector_grows.html#filepos2347166">9.4</a>, p. <a href="092-9.4._how_a_vector_grows.html#filepos2347166">356</a>), and <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2327136">9.3.5</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2327136">352</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.40:</strong> Add a constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;string&gt;</span></tt></code> to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.41:</strong> Why did we use postfix increment in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>? What would happen if it used the prefix increment?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.42:</strong> Test your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class by using it in place of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt;</span></tt></code> in your <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> classes (&#167; <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a>, p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.43:</strong> Rewrite the <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> member to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> and a lambda (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) in place of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop to <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> the elements. Which implementation do you prefer, and why?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos3426130"/><strong class="calibre5">Exercise 13.44:</strong> Write a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code> that is a simplified version of the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class. Your class should have at least a default constructor and a constructor that takes a pointer to a C-style string. Use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> to allocate memory that your <code class="calibre23"><tt class="calibre23"><span class="calibre24">String</span></tt></code> class uses.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="124-13.4._a_copycontrol_example.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="126-13.6._moving_objects.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
