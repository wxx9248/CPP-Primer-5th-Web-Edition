<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>10.1. Overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="097-chapter_10._generic_algorithms.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="099-10.2._a_first_look_at_the_algorithms.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2458324" class="calibre29"><span class="bold">10.1. Overview</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Most of the algorithms are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">algorithm</span></tt></code> header. The library also defines a set of generic numeric algorithms that are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">numeric</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In general, the algorithms do not work directly on a container. Instead, they operate by traversing a range of elements bounded by two iterators (&#167; <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>). Typically, as the algorithm traverses the range, it does something with each element. For example, suppose we have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and we want to know if that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> holds a particular value. The easiest way to answer this question is to call the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> algorithm:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int val = 42; // <span><span class="calibre45"><span class="calibre16">value we'll look for</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">result</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will denote the element we want if it's in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec.cend(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">if not</span></span></span><br class="calibre6"/>auto result = find(vec.cbegin(), vec.cend(), val);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">report the result</span></span></span><br class="calibre6"/>cout &lt;&lt; "The value " &lt;&lt; val<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; (result == vec.cend()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;? " is not present" : " is present") &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first two arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> are iterators denoting a range of elements, and the third argument is a value. <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> compares each element in the given range to the given value. It returns an iterator to the first element that is equal to that value. If there is no match, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> returns its second iterator to indicate failure. Thus, we can determine whether the element was found by comparing the return value with the second iterator argument. We do this test in the output statement, which uses the conditional operator (&#167; <a href="045-4.7._the_conditional_operator.html#filepos1107527">4.7</a>, p. <a href="045-4.7._the_conditional_operator.html#filepos1107527">151</a>) to report whether the value was found.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> operates in terms of iterators, we can use the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> function to look for values in any type of container. For example, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> to look for a value in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string val = "a value";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">value we'll look for</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">find</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">looks through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements in a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list</span></span></tt></span><br class="calibre6"/>auto result = find(1st.cbegin(), 1st.cend(), val);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Similarly, because pointers act like iterators on built-in arrays, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> to look in an array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2463522"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {27, 210, 12, 47, 109, 83};<br class="calibre6"/>int val = 83;<br class="calibre6"/>int* result = find(begin(ia), end(ia), val);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> functions (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) to pass a pointer to the first and one past the last elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can also look in a subrange of the sequence by passing iterators (or pointers) to the first and one past the last element of that subrange. For example, this call looks for a match in the elements <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia[1], ia[2]</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia[3]</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">search the elements starting from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[1]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">up to but not including</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[4]</span></span></tt></span><br class="calibre6"/>auto result = find(ia + 1, ia + 4, val);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">How the Algorithms Work</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">To see how the algorithms can be used on varying types of containers, let&#8217;s look a bit more closely at <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>. Its job is to find a particular element in an unsorted sequence of elements. Conceptually, we can list the steps <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> must take:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> It accesses the first element in the sequence.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> It compares that element to the value we want.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong> If this element matches the one we want, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> returns a value that identifies this element.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">4.</strong> Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> advances to the next element and repeats steps 2 and 3.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">5.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> must stop when it has reached the end of the sequence.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">6.</strong> If <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> gets to the end of the sequence, it needs to return a value indicating that the element was not found. This value and the one returned from step 3 must have compatible types.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">None of these operations depends on the type of the container that holds the elements. So long as there is an iterator that can be used to access the elements, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> doesn&#8217;t depend in any way on the container type (or even whether the elements are stored in a container).</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Iterators Make the Algorithms Container Independent, ...</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">All but the second step in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> function can be handled by iterator operations: The iterator dereference operator gives access to an element&#8217;s value; if a matching element is found, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> can return an iterator to that element; the iterator increment operator moves to the next element; the &#8220;off-the-end&#8221; iterator will indicate when <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> has reached the end of its given sequence; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> can return the off-the-end iterator (&#167; <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>) to indicate that the given value wasn&#8217;t found.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">...But Algorithms Do Depend on Element-Type Operations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Although iterators make the algorithms container independent, most of the algorithms use one (or more) operation(s) on the element type. For example, step 2, uses the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator to compare each element to the given value.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2469289"/>Other algorithms require that the element type have the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. However, as we&#8217;ll see, most algorithms provide a way for us to supply our own operation to use in place of the default operator.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.1:</strong> The <code class="calibre23"><tt class="calibre23"><span class="calibre24">algorithm</span></tt></code> header defines a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> that, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>, takes a pair of iterators and a value. <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> returns a count of how often that value appears. Read a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and print the <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> of how many elements have a given value.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.2:</strong> Repeat the previous program, but read values into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Algorithms Never Execute Container Operations</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As we&#8217;ll see in &#167; <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>), there is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. When we assign to these iterators, they execute insert operations on the underlying container. When an algorithm operates on one of these iterators, the <em class="calibre16">iterator</em> may have the effect of adding elements to the container. The <em class="calibre16">algorithm</em> itself, however, never does so.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="097-chapter_10._generic_algorithms.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="099-10.2._a_first_look_at_the_algorithms.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
