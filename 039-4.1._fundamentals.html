<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.1. Fundamentals</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="038-chapter_4._expressions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="040-4.2._arithmetic_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos999302" class="calibre29"><span class="bold">4.1. Fundamentals</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">There are a few fundamental concepts that affect how expressions are evaluated. We start by briefly discussing the concepts that apply to most (if not all) expressions. Subsequent sections will cover these topics in more detail.</p><div class="calibre15">&#160;</div>
<h4 id="filepos999677" class="calibre37"><span class="calibre5">4.1.1. Basic Concepts</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">There are both <em class="calibre16"><strong class="calibre5"><a id="filepos999887" href="052-defined_terms.html#filepos1222172">unary operators</a></strong></em> and <em class="calibre16"><strong class="calibre5"><a id="filepos999977" href="052-defined_terms.html#filepos1214419">binary operators</a></strong></em>. Unary operators, such as address-of (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>) and dereference (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>), act on one operand. Binary operators, such as equality (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>) and multiplication (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>), act on two operands. There is also one ternary operator that takes three operands, and one operator, function call, that takes an unlimited number of operands.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Some symbols, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, are used as both a unary (dereference) and a binary (multiplication) operator. The context in which a symbol is used determines whether the symbol represents a unary or binary operator. The uses of such symbols are independent; it can be helpful to think of them as two different symbols.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Grouping Operators and Operands</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Understanding expressions with multiple operators requires understanding the <em class="calibre16"><strong class="calibre5"><a id="filepos1001303" href="052-defined_terms.html#filepos1219802">precedence</a></strong></em> and <em class="calibre16"><strong class="calibre5"><a id="filepos1001388" href="052-defined_terms.html#filepos1214032">associativity</a></strong></em> of the operators and may depend on the <em class="calibre16"><strong class="calibre5"><a id="filepos1001511" href="052-defined_terms.html#filepos1218751">order of evaluation</a></strong></em> of the operands. For example, the result of the following expression depends on how the operands are grouped to the operators:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">5 + 10 * 20/2;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The operands to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> operator could be <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">20</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">20/2</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">15</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">20</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">15</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">20/2</span></tt></code>. Understanding such expressions is the topic of the next section.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Operand Conversions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As part of evaluating an expression, operands are often converted from one type to another. For example, the binary operators usually expect operands with the same type. These operators can be used on operands with differing types so long as the operands can be converted (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>) to a common type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although the rules are somewhat complicated, for the most part conversions happen in unsurprising ways. For example, we can convert an integer to floating-point, and vice versa, but we cannot convert a pointer type to floating-point. What may be a bit surprising is that small integral type operands (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, etc.) are generally <strong class="calibre5"><a id="filepos1003780" href="052-defined_terms.html#filepos1220155">promoted</a></strong> to a larger integral type, typically <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. We&#8217;ll look in detail at conversions in &#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a> (p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1004129"/>Overloaded Operators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The language defines what the operators mean when applied to built-in and compound types. We can also define what most operators mean when applied to class types. Because such definitions give an alternative meaning to an existing operator symbol, we refer to them as <strong class="calibre5"><a id="filepos1004502" href="052-defined_terms.html#filepos1219449">overloaded operators</a></strong>. The IO library <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> operators and the operators we used with <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s, and iterators are all overloaded operators.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we use an overloaded operator, the meaning of the operator&#8212;including the type of its operand(s) and the result&#8212;depend on how the operator is defined. However, the number of operands and the precedence and the associativity of the operator cannot be changed.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Lvalues and Rvalues</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Every expression in C++ is either an <strong class="calibre5"><a id="filepos1005560" href="052-defined_terms.html#filepos1220854">rvalue</a></strong> (pronounced &#8220;are-value&#8221;) or an <strong class="calibre5"><a id="filepos1005671" href="052-defined_terms.html#filepos1217583">lvalue</a></strong> (pronounced &#8220;ell-value&#8221;). These names are inherited from C and originally had a simple mnemonic purpose: lvalues could stand on the left-hand side of an assignment whereas rvalues could not.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In C++, the distinction is less simple. In C++, an lvalue expression yields an object or a function. However, some lvalues, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> objects, may not be the left-hand operand of an assignment. Moreover, some expressions yield objects but return them as rvalues, not lvalues. Roughly speaking, when we use an object as an rvalue, we use the object&#8217;s value (its contents). When we use an object as an lvalue, we use the object&#8217;s identity (its location in memory).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Operators differ as to whether they require lvalue or rvalue operands and as to whether they return lvalues or rvalues. The important point is that (with one exception that we&#8217;ll cover in &#167; <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>)) we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required. When we use an lvalue in place of an rvalue, the object&#8217;s contents (its value) are used. We have already used several operators that involve lvalues.</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Assignment requires a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) lvalue as its left-hand operand and yields its left-hand operand as an lvalue.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The address-of operator (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>) requires an lvalue operand and returns a pointer to its operand as an rvalue.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The built-in dereference and subscript operators (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>, and &#167; <a href="034-3.5._arrays.html#filepos873638">3.5.2</a>, p. <a href="034-3.5._arrays.html#filepos873638">116</a>) and the iterator dereference and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> subscript operators (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>, &#167; <a href="031-3.2._library_string_type.html#filepos697807">3.2.3</a>, p. <a href="031-3.2._library_string_type.html#filepos697807">93</a>, and &#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos778112">102</a>) all yield lvalues.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The built-in and iterator increment and decrement operators (&#167; <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a>, p. <a href="014-1.4._flow_of_control.html#filepos166704">12</a>, and &#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">107</a>) require lvalue operands and the prefix versions (which are the ones we have used so far) also yield lvalues.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">As we present the operators, we will note whether an operand must be an lvalue and whether the operator returns an lvalue.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Lvalues and rvalues also differ when used with <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>). When we apply <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to an expression (other than a variable), the result is <a id="filepos1009485"/>a reference type if the expression yields an lvalue. As an example, assume <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code>. Because dereference yields an lvalue, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(*p)</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. On the other hand, because the address-of operator yields an rvalue, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(&amp;p)</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int**</span></tt></code>, that is, a pointer to a pointer to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 id="filepos1010254" class="calibre37"><span class="calibre5">4.1.2. Precedence and Associativity</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">An expression with two or more operators is a <strong class="calibre5"><a id="filepos1010505" href="052-defined_terms.html#filepos1214821">compound expression</a></strong>. Evaluating a compound expression involves grouping the operands to the operators. Precedence and associativity determine how the operands are grouped. That is, they determine which parts of the expression are the operands for each of the operators in the expression. Programmers can override these rules by parenthesizing compound expressions to force a particular grouping.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In general, the value of an expression depends on how the subexpressions are grouped. Operands of operators with higher precedence group more tightly than operands of operators at lower precedence. Associativity determines how to group operands with the same precedence. For example, multiplication and division have the same precedence as each other, but they have higher precedence than addition. Therefore, operands to multiplication and division group before operands to addition and subtraction. The arithmetic operators are left associative, which means operators at the same precdence group left to right:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Because of precedence, the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">3+4*5</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">23</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">35</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Because of associativity, the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">20-15-3</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">2</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">8</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">As a more complicated example, a left-to-right evaluation of the following expression yields 20:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">6 + 3 * 4 / 2 + 2</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Other imaginable results include 9, 14, and 36. In C++, the result is 14, because this expression is equivalent to</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">parentheses in this expression match default precedence and associativity</span></span></span><br class="calibre6"/>((6 + ((3 * 4) / 2)) + 2)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Parentheses Override Precedence and Associativity</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can override the normal grouping with parentheses. Parenthesized expressions are evaluated by treating each parenthesized subexpression as a unit and otherwise applying the normal precedence rules. For example, we can parenthesize the expression above to force the result to be any of the four possible values:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">parentheses result in alternative groupings</span></span></span><br class="calibre6"/>cout &lt;&lt; (6 + 3) *&#160;&#160;(4 / 2 + 2) &lt;&lt; endl;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints 36</span></span></span><br class="calibre6"/>cout &lt;&lt; ((6 + 3) *&#160;&#160;4) / 2 + 2 &lt;&lt; endl;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints 20</span></span></span><br class="calibre6"/>cout &lt;&lt; 6 + 3 * 4&#160;&#160;/ (2 + 2) &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints 9</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1014726"/>When Precedence and Associativity Matter</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">We have already seen examples where precedence affects the correctness of our programs. For example, consider the discussion in &#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a> (p. <a href="034-3.5._arrays.html#filepos881970">120</a>) about dereference and pointer arithmetic:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,2,4,6,8}; // <span><span class="calibre45"><span class="calibre16">array with five elements of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int last = *(ia + 4);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">last</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">8</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia [4]</span></span></tt></span><br class="calibre6"/>last = *ia + 4;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">last = 4</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia [0] + 4</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we want to access the element at the location <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia+4</span></tt></code>, then the parentheses around the addition are essential. Without parentheses, <code class="calibre23"><tt class="calibre23"><span class="calibre24">*ia</span></tt></code> is grouped first and <code class="calibre23"><tt class="calibre23"><span class="calibre24">4</span></tt></code> is added to the value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">*ia</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The most common case that we&#8217;ve seen in which associativity matters is in input and output expressions. As we&#8217;ll see in &#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a> (p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">155</a>), the operators used for IO are left associative. This associativity means we can combine several IO operations in a single expression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cin &gt;&gt; v1 &gt;&gt; v2; // <span><span class="calibre45"><span class="calibre16">read into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and then into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Table 4.12 (p. <a href="050-4.12._operator_precedence_table.html#filepos1211317">166</a>) lists all the operators organized into segments separated by double lines. Operators in each segment have the same precedence, and have higher precedence than operators in subsequent segments. For example, the prefix increment and dereference operators share the same precedence, which is higher than that of the arithmetic operators. The table includes a page reference to each operator&#8217;s description. We have seen some of these operators already and will cover most of the rest in this chapter. However, there are a few operators that we will not cover until later.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.1:</strong> What is the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">5 + 10 * 20/2</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.2:</strong> Using Table 4.12 (p. <a href="050-4.12._operator_precedence_table.html#filepos1211317">166</a>), parenthesize the following expressions to indicate the order in which the operands are grouped:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">* vec.begin()</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">* vec.begin() + 1</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1019764" class="calibre37"><span class="calibre5">4.1.3. Order of Evaluation</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Precedence specifies how the operands are grouped. It says nothing about the order in which the operands are evaluated. In most cases, the order is largely unspecified. In the following expression</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = f1() * f2();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">we know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> must be called before the multiplication can be done. After all, it is their results that are multiplied. However, we have no way of knowing whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> will be called before <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> or vice versa.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1020899"/>For operators that do not specify evaluation order, it is an error for an expression to <em class="calibre16">refer to and change</em> the same object. Expressions that do so have undefined behavior (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">36</a>). As a simple example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> operator makes no guarantees about when or how its operands are evaluated. As a result, the following output expression is undefined:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0;<br class="calibre6"/>cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ++i &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">undefined</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because this program is undefined, we cannot draw any conclusions about how it might behave. The compiler might evaluate <code class="calibre23"><tt class="calibre23"><span class="calibre24">++i</span></tt></code> before evaluating <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>, in which case the output will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">1 1</span></tt></code>. Or the compiler might evaluate <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> first, in which case the output will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">0 1</span></tt></code>. <em class="calibre16">Or the compiler might do something else entirely.</em> Because this expression has undefined behavior, the program is in error, regardless of what code the compiler generates.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There are four operators that do guarantee the order in which operands are evaluated. We saw in &#167; <a href="031-3.2._library_string_type.html#filepos697807">3.2.3</a> (p. <a href="031-3.2._library_string_type.html#filepos697807">94</a>) that the logical <small class="calibre48">AND</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>) operator guarantees that its left-hand operand is evaluated first. Moreover, we are also guaranteed that the right-hand operand is evaluated only if the left-hand operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The only other operators that guarantee the order in which operands are evaluated are the logical <small class="calibre48">OR</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code>) operator (&#167; <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">4.3</a>, p. <a href="041-4.3._logical_and_relational_operators.html#filepos1044115">141</a>), the conditional (<code class="calibre23"><tt class="calibre23"><span class="calibre24">? :</span></tt></code>) operator (&#167; <a href="045-4.7._the_conditional_operator.html#filepos1107527">4.7</a>, p. <a href="045-4.7._the_conditional_operator.html#filepos1107527">151</a>), and the comma (<code class="calibre23"><tt class="calibre23"><span class="calibre24">,</span></tt></code>) operator (&#167; <a href="048-4.10._comma_operator.html#filepos1151213">4.10</a>, p. <a href="048-4.10._comma_operator.html#filepos1151213">157</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Order of Evaluation, Precedence, and Associativity</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Order of operand evaluation is independent of precedence and associativity. In an expression such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">f() + g() * h() + j()</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Precedence guarantees that the results of <code class="calibre23"><tt class="calibre23"><span class="calibre24">g()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">h()</span></tt></code> are multiplied.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Associativity guarantees that the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f()</span></tt></code> is added to the product of <code class="calibre23"><tt class="calibre23"><span class="calibre24">g()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">h()</span></tt></code> and that the result of that addition is added to the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j()</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There are no guarantees as to the order in which these functions are called.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> are independent functions that do not affect the state of the same objects or perform IO, then the order in which the functions are called is irrelevant. If any of these functions do affect the same object, then the expression is in error and has undefined behavior.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.3:</strong> Order of evaluation for most of the binary operators is left undefined to give the compiler opportunities for optimization. This strategy presents a trade-off between efficient code generation and potential pitfalls in the use of the language by the programmer. Do you consider that an acceptable trade-off? Why or why not?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos1026600"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Managing Compound Expressions</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When you write compound expressions, two rules of thumb can be helpful:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> When in doubt, parenthesize expressions to force the grouping that the logic of your program requires.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> If you change the value of an operand, don&#8217;t use that operand elsewhere in the same expresion.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An important exception to the second rule occurs when the subexpression that changes the operand is itself the operand of another subexpression. For example, in <code class="calibre23"><tt class="calibre23"><span class="calibre24">*++iter</span></tt></code>, the increment changes the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code>. The (now changed) value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> is the operand to the dereference operator. In this (and similar) expressions, order of evaluation isn&#8217;t an issue. The increment (i.e., the subexpression that changes the operand) must be evaluated before the dereference can be evaluated. Such usage poses no problems and is quite common.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="038-chapter_4._expressions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="040-4.2._arithmetic_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
