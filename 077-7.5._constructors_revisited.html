<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>7.5. Constructors Revisited</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="076-7.4._class_scope.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="078-7.6._static_class_members.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1952599" class="calibre29"><span class="bold"><a id="filepos1952632" class="calibre2"/>7.5. Constructors Revisited</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Constructors are a crucial part of any C++ class. We covered the basics of constructors in &#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>). In this section we&#8217;ll cover some additional capabilities of constructors, and deepen our coverage of the material introduced earlier.</p><div class="calibre15">&#160;</div>
<h4 id="filepos1953073" class="calibre37"><span class="calibre5">7.5.1. Constructor Initializer List</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">When we define variables, we typically initialize them immediately rather than defining them and then assigning to them:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string foo = "Hello World!"; // <span><span class="calibre45"><span class="calibre16">define and initialize</span></span></span><br class="calibre6"/>string bar;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default initialized to the empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>bar = "Hello World!";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign a new value to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bar</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Exactly the same distinction between initialization and assignment applies to the data members of objects. If we do not explicitly initialize a member in the constructor initializer list, that member is default initialized before the constructor body starts executing. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">legal but sloppier way to write the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor: no constructor initializers</span></span></span><br class="calibre6"/>Sales_data::Sales_data(const string &amp;s,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned cnt, double price)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;bookNo = s;<br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold = cnt;<br class="calibre6"/>&#160;&#160;&#160;&#160;revenue = cnt * price;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version and our original definition on page <a href="073-7.1._defining_abstract_data_types.html#filepos1810987">264</a> have the same effect: When the constructor finishes, the data members will hold the same values. The difference is that the original version <em class="calibre16">initializes</em> its data members, whereas this version <em class="calibre16">assigns</em> values to the data members. How significant this distinction is depends on the type of the data member.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Constructor Initializers Are Sometimes Required</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can often, <em class="calibre16">but not always</em>, ignore the distinction between whether a member is initialized or assigned. Members that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or references must be initialized. Similarly, members that are of a class type that does not define a default constructor also must be initialized. For example:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class ConstRef {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;ConstRef(int ii);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>&#160;&#160;&#160;&#160;const int ci;<br class="calibre6"/>&#160;&#160;&#160;&#160;int &amp;ri;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1957023"/>Like any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object or reference, the members <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> must be initialized. As a result, omitting a constructor initializer for these members is an error:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ri</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must be initialized</span></span></span><br class="calibre6"/>ConstRef::ConstRef(int ii)<br class="calibre6"/>{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assignments:</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;i = ii;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;ci = ii;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;ri = i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ri</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">was never initialized</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference data members is in the constructor initializer. The correct way to write this constructor is</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: explicitly initialize reference and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members</span></span></span><br class="calibre6"/>ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {&#160;&#160;}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We <em class="calibre16">must</em> use the constructor initializer list to provide values for members that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, reference, or of a class type that does not have a default constructor.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Use Constructor Initializers</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In many classes, the distinction between initialization and assignment is strictly a matter of low-level efficiency: A data member is initialized and then assigned when it could have been initialized directly.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">More important than the efficiency issue is the fact that some data members must be initialized. By routinely using constructor initializers, you can avoid being surprised by compile-time errors when you have a class with a member that requires a constructor initializer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Order of Member Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Not surprisingly, each member may be named only once in the constructor initializer. After all, what might it mean to give a member two initial values?</p><div class="calibre15">&#160;</div>
<p class="calibre25">What may be more surprising is that the constructor initializer list specifies only the values used to initialize the members, not the order in which those initializations are performed.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Members are initialized in the order in which they appear in the class definition: The first member is initialized first, then the next, and so on. The order in which initializers appear in the constructor initializer list does not change the order of initialization.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The order of initialization often doesn&#8217;t matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, consider the following class:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1962666"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class X {<br class="calibre6"/>&#160;&#160;&#160;&#160;int i;<br class="calibre6"/>&#160;&#160;&#160;&#160;int j;<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">undefined:</span></span></span>&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is initialized before</span></span></span>&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;X(int val): j(val), i(j) { }<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, the constructor initializer makes it <em class="calibre16">appear</em> as if <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is initialized with <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> and then <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is used to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is initialized first. The effect of this initializer is to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> with the undefined value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>!</p><div class="calibre15">&#160;</div>
<p class="calibre25">Some compilers are kind enough to generate a warning if the data members are listed in the constructor initializer in a different order from the order in which the members are declared.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">If possible, it is a good idea write member initializers to use the constructor&#8217;s parameters rather than another data member from the same object. That way we don&#8217;t even have to think about the order of member initialization. For example, it would be better to write the constructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">X(int val): i(val), j(val) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this version, the order in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> are initialized doesn&#8217;t matter.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Default Arguments and Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The actions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> default constructor are similar to those of the constructor that takes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. The only difference is that the constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument uses that argument to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code>. The default constructor (implicitly) uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> default constructor to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code>. We can rewrite these constructors as a single constructor with a default argument (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defines the default constructor as well as one that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">argument</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::string s = ""): bookNo(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining constructors unchanged</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::string s, unsigned cnt, double rev):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bookNo(s), units_sold(cnt), revenue(rev*cnt) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::istream &amp;is) { read(is, *this); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version of our class provides the same interface as our original on page <a href="073-7.1._defining_abstract_data_types.html#filepos1810987">264</a>. Both versions create the same object when given no arguments or when given a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. Because we can call this constructor with no arguments, this constructor defines a default constructor for our class.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos1968741"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A constructor that supplies default arguments for all its parameters also defines the default constructor.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">It is worth noting that we probably should not use default arguments with the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructor that takes three arguments. If a user supplies a nonzero count for the number of books sold, we want to ensure that the user also supplies the price at which those books were sold.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.36:</strong> The following initializer is in error. Identify and fix the problem.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct X {<br class="calibre6"/>&#160;&#160;&#160;&#160;X (int i, int j): base(i), rem(base % j) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;int rem, base;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.37:</strong> Using the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> from this section, determine which constructor is used to initialize each of the following variables and list the values of the data members in each object:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data first_item(cin);<br class="calibre6"/><br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data next;<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data last("9-999-99999-9");<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.38:</strong> We might want to supply <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> as a default argument to the constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream&amp;</span></tt></code>. Write the constructor declaration that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> as a default argument.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.39:</strong> Would it be legal for both the constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and the one that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream&amp;</span></tt></code> to have default arguments? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos1972067"/><strong class="calibre5">Exercise 7.40:</strong> Choose one of the following abstractions (or an abstraction of your own choosing). Determine what data are needed in the class. Provide an appropriate set of constructors. Explain your decisions.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Book</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Date</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Employee</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Vehicle</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Object</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Tree</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1973473" class="calibre37"><span class="calibre5">7.5.2. Delegating Constructors</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos1973586"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">The new standard extends the use of constructor initializers to let us define so-called <strong class="calibre5"><a id="filepos1973769" href="080-defined_terms.html#filepos2059857">delegating constructors</a></strong>. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to &#8220;delegate&#8221; some (or all) of its work to this other constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like any other constructor, a delegating constructor has a member initializer <a id="filepos1974179"/>list and a function body. In a delegating constructor, the member initializer list has a single entry that is the name of the class itself. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must match another constructor in the class.</p><div class="calibre22">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll rewrite the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class to use delegating constructors as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">nondelegating constructor initializes members from corresponding arguments</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::string s, unsigned cnt, double price):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bookNo(s), units_sold(cnt), revenue(cnt*price) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining constructors all delegate to another constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(): Sales_data("", 0, 0) {}<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::string s): Sales_data(s, 0,0) {}<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(std::istream &amp;is): Sales_data()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ read(is, *this); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>, all but one of the constructors delegate their work. The first constructor takes three arguments, uses those arguments to initialize the data members, and does no further work. In this version of the class, we define the default constructor to use the three-argument constructor to do its initialization. It too has no additional work, as indicated by the empty constructor body. The constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> also delegates to the three-argument version.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream&amp;</span></tt></code> also delegates. It delegates to the default constructor, which in turn delegates to the three-argument constructor. Once those constructors complete their work, the body of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream&amp;</span></tt></code> constructor is run. Its constructor body calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">read</span></tt></code> to read the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When a constructor delegates to another constructor, the constructor initializer list and function body of the delegated-to constructor are both executed. In <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>, the function bodies of the delegated-to constructors happen to be empty. Had the function bodies contained code, that code would be run before control returned to the function body of the delegating constructor.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.41:</strong> Rewrite your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class to use delegating constructors. Add a statement to the body of each of the constructors that prints a message whenever it is executed. Write declarations to construct a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object in every way possible. Study the output until you are certain you understand the order of execution among delegating constructors.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.42:</strong> For the class you wrote for <a href="077-7.5._constructors_revisited.html#filepos1972067">exercise 7.40</a> in &#167; <a href="077-7.5._constructors_revisited.html#filepos1953073">7.5.1</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1953073">291</a>), decide whether any of the constructors might use delegation. If so, write the delegating constructor(s) for your class. If not, look at the list of abstractions and choose one that you think would use a delegating constructor. Write the class definition for that abstraction.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1979405" class="calibre37"><span class="calibre5"><a id="filepos1979438"/>7.5.3. The Role of the Default Constructor</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The default constructor is used automatically whenever an object is default or value initialized. Default initialization happens</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we define non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> variables (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>) or arrays (&#167;<a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>) at block scope without initializers</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When a class that itself has members of class type uses the synthesized default constructor (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When members of class type are not explicitly initialized in a constructor initializer list (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">265</a>)</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Value initialization happens</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; During array initialization when we provide fewer initializers than the size of the array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we define a local static object without an initializer (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we explicitly request value initialization by writing an expressions of the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">T()</span></tt></code> where <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is the name of a type (The <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> constructor that takes a single argument to specify the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s size (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) uses an argument of this kind to value initialize its element initializer.)</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Classes must have a default constructor in order to be used in these contexts. Most of these contexts should be fairly obvious.</p><div class="calibre15">&#160;</div>
<p class="calibre25">What may be less obvious is the impact on classes that have data members that do not have a default constructor:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class NoDefault {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;NoDefault(const std::string&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">additional members follow, but no other constructors</span></span></span><br class="calibre6"/>};<br class="calibre6"/>struct A {&#160;&#160;// <span><span class="calibre45"><span class="calibre16">my_mem is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">public</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by default; see &#167; 7.2 (p. 268)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;NoDefault my_mem;<br class="calibre6"/>};<br class="calibre6"/>A a;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">error: cannot synthesize a constructor for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><br class="calibre6"/>struct B {<br class="calibre6"/>&#160;&#160;&#160;&#160;B() {} //&#160;&#160;<span><span class="calibre45"><span class="calibre16">error: no initializer for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b_member</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;NoDefault b_member;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In practice, it is almost always right to provide a default constructor if other constructors are being defined.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Default Constructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The following declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code> compiles without complaint. However, when we try to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data obj();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but defines a function, not an object</span></span></span><br class="calibre6"/>if (obj.isbn() == Primer_5th_ed.isbn())&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1985345"/>the compiler complains that we cannot apply member access notation to a function. The problem is that, although we intended to declare a default-initialized object, <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code> actually declares a function taking no parameters and returning an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The correct way to define an object that uses the default constructor for initialization is to leave off the trailing, empty parentheses:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a default-initialized object</span></span></span><br class="calibre6"/>Sales_data obj;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is a common mistake among programmers new to C++ to try to declare an object initialized with the default constructor as follows:</p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data obj(); // <span><span class="calibre45"><span class="calibre16">oops! declares a function, not an object</span></span></span><br class="calibre6"/>Sales_data obj2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an object, not a function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.43:</strong> Assume we have a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">NoDefault</span></tt></code> that has a constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, but has no default constructor. Define a class <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code> that has a member of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">NoDefault</span></tt></code>. Define the default constructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.44:</strong> Is the following declaration legal? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;NoDefault&gt; vec(10);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.45:</strong> What if we defined the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in the previous execercise to hold objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">C</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.46:</strong> Which, if any, of the following statements are untrue? Why?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong> A class must provide at least one constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong> A default constructor is a constructor with an empty parameter list.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong> If there are no meaningful default values for a class, the class should not provide a default constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong> If a class does not define a default constructor, the compiler generates one that initializes each data member to the default value of its associated type.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1990205" class="calibre37"><span class="calibre5">7.5.4. Implicit Class-Type Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we saw in &#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a> (p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>), the language defines several automatic conversions among the built-in types. We also noted that classes can define implicit conversions as well. Every constructor that can be called with a single argument defines an implicit conversion <em class="calibre16">to</em> a class type. Such constructors are sometimes referred to as <a id="filepos1990805"/><strong class="calibre5"><a id="filepos1990821" href="080-defined_terms.html#filepos2058739">converting constructors</a></strong>. We&#8217;ll see in &#167; <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">14.9</a> (p. <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">579</a>) how to define conversions <em class="calibre16">from</em> a class type to another type.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A constructor that can be called with a single argument defines an implicit conversion from the constructor&#8217;s parameter type to the class type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructors that take a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and that take an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> both define implicit conversions from those types to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>. That is, we can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> where an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> is expected:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string null_book = "9-999-99999-9";<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">constructs a temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">units_sold</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><span class="calibre45"><span class="calibre16">revenue</span></span></span>
<span><span class="calibre45"><span class="calibre16">equal to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bookNo</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">equal to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">null_book</span></span></tt></span><br class="calibre6"/>item.combine(null_book);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we call the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data combine</span></tt></code> member function with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. This call is perfectly legal; the compiler automatically creates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object from the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. That newly generated (temporary) <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> is passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">combine</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">combine</span></tt></code>&#8217;s parameter is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we can pass a temporary to that parameter.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Only One Class-Type Conversion Is Allowed</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a> (p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>) we noted that the compiler will automatically apply only one class-type conversion. For example, the following code is in error because it implicitly uses two conversions:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: requires two user-defined conversions:</span></span></span><br class="calibre6"/>//&#160;&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">(1) convert</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"9-999-99999-9"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>//&#160;&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">(2) convert that (temporary</span></span></span>) <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>item.combine("9-999-99999-9");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we wanted to make this call, we can do so by explicitly converting the character string to either a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: explicit conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">implicit conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>item.combine(string("9-999-99999-9"));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: implicit conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">explicit conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>item.combine(Sales_data("9-999-99999-9"));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Class-Type Conversions Are Not Always Useful</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Whether the conversion of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> is desired depends on how we think our users will use the conversion. In this case, it might be okay. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">null_book</span></tt></code> probably represents a nonexistent <small class="calibre48">ISBN</small>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">More problematic is the conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">istream</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor to build an object to pass to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">combine</span></span></tt></span><br class="calibre6"/>item.combine(cin);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code implicitly converts <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>. This conversion executes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code>. That constructor creates a (temporary) <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object by reading the standard input. That object is then passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">combine</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1999723"/>This <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object is a temporary (&#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, p. <a href="024-2.4._const_qualifier.html#filepos476737">62</a>). We have no access to it once <code class="calibre23"><tt class="calibre23"><span class="calibre24">combine</span></tt></code> finishes. Effectively, we have constructed an object that is discarded after we add its value into <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Suppressing Implicit Conversions Defined by Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">explicit</span></span></tt></span></span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(const std::string &amp;s, unsigned n, double p):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bookNo(s), units_sold(n), revenue(p*n) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;explicit Sales_data(const std::string &amp;s): bookNo(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;explicit Sales_data(std::istream&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Now, neither constructor can be used to implicitly create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object. Neither of our previous uses will compile:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">item.combine(null_book);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span><br class="calibre6"/>item.combine(cin);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">istream</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> keyword is meaningful only on constructors that can be called with a single argument. Constructors that require more arguments are not used to perform an implicit conversion, so there is no need to designate such constructors as <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> keyword is used only on the constructor declaration inside the class. It is not repeated on a definition made outside the class body:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">allowed only on a constructor declaration in a class header</span></span></span><br class="calibre6"/>explicit Sales_data::Sales_data(istream&amp; is)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;read(is, *this);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">explicit</span></span></tt></span></span></tt></code> Constructors Can Be Used Only for Direct Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One context in which implicit conversions happen is when we use the copy form of initialization (with an <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>) (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>). We cannot use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor with this form of initialization; we must use direct initialization:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data item1 (null_book);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: direct initialization</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: cannot use the copy form of initialization with an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor</span></span></span><br class="calibre6"/>Sales_data item2 = null_book;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When a constructor is declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>, it can be used only with the direct form of initialization (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>). Moroever, the compiler will <em class="calibre16">not</em> use this constructor in an automatic conversion.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a/>Explicitly Using Constructors for Conversions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although the compiler will not use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor for an implicit conversion, we can use such constructors explicitly to force a conversion:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: the argument is an explicitly constructed</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>item.combine(Sales_data(null_book));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static_cast</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can use an explicit constructor</span></span></span><br class="calibre6"/>item.combine(static_cast&lt;Sales_data&gt;(cin));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first call, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructor directly. This call constructs a temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. In the second call, we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> (&#167; <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a>, p. <a href="049-4.11._type_conversions.html#filepos1189032">163</a>) to perform an explicit, rather than an implicit, conversion. In this call, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> constructor to construct a temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Library Classes with <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">explicit</span></span></tt></span></span></tt></code> Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Some of the library classes that we&#8217;ve used have single-parameter constructors:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> constructor that takes a single parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code> (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> constructor that takes a size (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) is <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.47:</strong> Explain whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>. What are the benefits of making the constructor <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>? What are the drawbacks?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.48:</strong> Assuming the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructors are not <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>, what operations happen during the following definitions</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string null_isbn("9-999-99999-9");<br class="calibre6"/>Sales_data item1(null_isbn);<br class="calibre6"/>Sales_data item2("9-999-99999-9");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44">What happens if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> constructors are <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.49:</strong> For each of the three following declarations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">combine</span></tt></code>, explain what happens if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">i.combine(s)</span></tt></code>, where <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data &amp;combine(Sales_data);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data &amp;combine(Sales_data&amp;);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data &amp;combine(const Sales_data&amp;) const;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.50:</strong> Determine whether any of your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Person</span></tt></code> class constructors should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.51:</strong> Why do you think <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> defines its single-argument constructor as <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> does not?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2013562" class="calibre37"><span class="calibre5"><a id="filepos2013595"/>7.5.5. Aggregate Classes</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">An <strong class="calibre5"><a id="filepos2013767" href="080-defined_terms.html#filepos2055402">aggregate class</a></strong> gives users direct access to its members and has special initialization syntax. A class is an aggregate if</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; All of its data members are <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It does not define any constructors</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It has no in-class initializers (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It has no base classes or <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> functions, which are class-related features that we&#8217;ll cover in <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">For example, the following class is an aggregate:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct Data {<br class="calibre6"/>&#160;&#160;&#160;&#160;int ival;<br class="calibre6"/>&#160;&#160;&#160;&#160;string s;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can initialize the data members of an aggregate class by providing a braced list of member initializers:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val1.ival = 0; val1.s = string("Anna")</span></span></tt></span><br class="calibre6"/>Data val1 = { 0, "Anna" };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The initializers must appear in declaration order of the data members. That is, the initializer for the first member is first, for the second is next, and so on. The following, for example, is an error:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: can't use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"Anna"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1024</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><br class="calibre6"/>Data val2 = { "Anna", 1024 };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with initialization of array elements (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), if the list of initializers has fewer elements than the class has members, the trailing members are value initialized (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>). The list of initializers must not contain more elements than the class has members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that there are three significant drawbacks to explicitly initializing the members of an object of class type:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It requires that all the data members of the class be <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It puts the burden on the user of the class (rather than on the class author) to correctly initialize every member of every object. Such initialization is tedious and error-prone because it is easy to forget an initializer or to supply an inappropriate initializer.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If a member is added or removed, all initializations have to be updated.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2018383"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.52:</strong> Using our first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> from &#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">72</a>), explain the following initialization. Identify and fix any problems.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data item = {"978-0590353403", 25, 15.99};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2019288" class="calibre37"><span class="calibre5">7.5.6. Literal Classes</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In &#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a> (p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">239</a>) we noted that the parameters and return type of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> function must be literal types. In addition to the arithmetic types, references, and pointers, certain classes are also literal types. Unlike other classes, classes that are literal types may have function members that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>. Such members must meet all the requirements of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> function. These member functions are implicitly <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">An aggregate class (&#167; <a href="077-7.5._constructors_revisited.html#filepos2013562">7.5.5</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2013562">298</a>) whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The data members all must have literal type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The class must have at least one <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>), or if the member has class type, the initializer must use the member&#8217;s own <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The class must use default definition for its destructor, which is the member that destroys objects of the class type (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>).</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">constexpr</span></span></tt></span></span></tt></code> Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although constructors can&#8217;t be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>), constructors in a literal class can be <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">239</a>) functions. Indeed, a literal class must provide at least one <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2022572"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor can be declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>) (or as a deleted function, which we cover in &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">507</a>)). Otherwise, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor must meet the requirements of a constructor&#8212;meaning it can have no <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement&#8212;and of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> function&#8212;meaning the only executable statement it can have is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">239</a>). As a result, the body of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor is typically empty. We define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor by preceding its declaration with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Debug {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;constexpr Debug(bool b = true): hw(b), io(b), other(b) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;constexpr Debug(bool h, bool i, bool o):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hw(h), io(i), other(o) { }<br class="calibre6"/><a id="filepos2024656"/>&#160;&#160;&#160;&#160;constexpr bool any() { return hw || io || other; }<br class="calibre6"/>&#160;&#160;&#160;&#160;void set_io(bool b) { io = b; }<br class="calibre6"/>&#160;&#160;&#160;&#160;void set_hw(bool b) { hw = b; }<br class="calibre6"/>&#160;&#160;&#160;&#160;void set_other(bool b) { hw = b; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;bool hw;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hardware errors other than IO errors</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;bool io;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">IO errors</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;bool other; // <span><span class="calibre45"><span class="calibre16">other errors</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor must initialize every data member. The initializers must either use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor or be a constant expression.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> constructor is used to generate objects that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> and for parameters or return types in <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr Debug io_sub(false, true, false);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">debugging IO</span></span></span><br class="calibre6"/>if (io_sub.any())&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">if(true)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cerr &lt;&lt; "print appropriate error messages" &lt;&lt; endl;<br class="calibre6"/>constexpr Debug prod(false); // <span><span class="calibre45"><span class="calibre16">no debugging during production</span></span></span><br class="calibre6"/>if (prod.any())&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">if(false)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cerr &lt;&lt; "print an error message" &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.5.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.53:</strong> Define your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Debug</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.54:</strong> Should the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Debug</span></tt></code> that begin with <code class="calibre23"><tt class="calibre23"><span class="calibre24">set_</span></tt></code> be declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.55:</strong> Is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Data</span></tt></code> class from &#167; <a href="077-7.5._constructors_revisited.html#filepos2013562">7.5.5</a> (p. <a href="077-7.5._constructors_revisited.html#filepos2013562">298</a>) a literal class? If not, why not? If so, explain why it is literal.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="076-7.4._class_scope.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="078-7.6._static_class_members.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
