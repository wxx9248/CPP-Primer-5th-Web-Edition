<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.8. Inherently Nonportable Features</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="183-19.7._local_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="185-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5354776" class="calibre29"><span class="bold">19.8. Inherently Nonportable Features</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">To support low-level programming, C++ defines some features that are inherently <strong class="calibre5"><a id="filepos5355004" href="186-defined_terms.html#filepos5404175">nonportable</a></strong>. A nonportable feature is one that is machine specific. Programs that use nonportable features often require reprogramming when they are moved from one machine to another. The fact that the sizes of the arithmetic types vary across machines (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">32</a>) is one such nonportable feature that we have already used.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this section we&#8217;ll cover two additional nonportable features that C++ inherits from C: bit-fields and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> qualifier. We&#8217;ll also cover linkage directives, which is a nonportable feature that C++ adds to those that it inherits from C.</p><div class="calibre22">&#160;</div>
<h4 id="filepos5355857" class="calibre37"><span class="calibre5">19.8.1. Bit-fields</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A class can define a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>) data member as a <strong class="calibre5"><a id="filepos5356098" href="186-defined_terms.html#filepos5399176">bit-field</a></strong>. A bit-field holds a specified number of bits. Bit-fields are normally used when a program needs to pass binary data to another program or to a hardware device.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The memory layout of a bit-field is machine dependent.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos5356771"/>A bit-field must have integral or enumeration type (&#167; <a href="179-19.3._enumerations.html#filepos5202480">19.3</a>, p. <a href="179-19.3._enumerations.html#filepos5202480">832</a>). Ordinarily, we use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> type to hold a bit-field, because the behavior of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed</span></tt></code> bit-field is implementation defined. We indicate that a member is a bit-field by following the member name with a colon and a constant expression specifying the number of bits:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef unsigned int Bit;<br class="calibre6"/>class File {<br class="calibre6"/>&#160;&#160;&#160;&#160;Bit mode: 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">mode</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bits</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bit modified: 1;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">modified</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bit</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bit prot_owner: 3; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">prot_owner</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bits</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bit prot_group: 3; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">prot_group</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bits</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Bit prot_world: 3; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">prot_world</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bits</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">operations and data members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">File</span></span></tt></span><br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">file modes specified as octal literals; see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 2.1.3 (p. 38)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;enum modes { READ = 01, WRITE = 02, EXECUTE = 03 };<br class="calibre6"/>&#160;&#160;&#160;&#160;File &amp;open(modes);<br class="calibre6"/>&#160;&#160;&#160;&#160;void close();<br class="calibre6"/>&#160;&#160;&#160;&#160;void write();<br class="calibre6"/>&#160;&#160;&#160;&#160;bool isRead() const;<br class="calibre6"/>&#160;&#160;&#160;&#160;void setWrite();<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">mode</span></tt></code> bit-field has two bits, <code class="calibre23"><tt class="calibre23"><span class="calibre24">modified</span></tt></code> only one, and the other members each have three bits. Bit-fields defined in consecutive order within the class body are, if possible, packed within adjacent bits of the same integer, thereby providing for storage compaction. For example, in the preceding declaration, the five bit-fields will (probably) be stored in a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>. Whether and how the bits are packed into the integer is machine dependent.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The address-of operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>) cannot be applied to a bit-field, so there can be no pointers referring to class bit-fields.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily it is best to make a bit-field an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> type. The behavior of bit-fields stored in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed</span></tt></code> type is implementation defined.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Bit-fields</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A bit-field is accessed in much the same way as the other data members of a class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void File::write()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;modified = 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">. . .</span></span></span><br class="calibre6"/>}<br class="calibre6"/>void File::close()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (modified)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">. . . save contents</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5362615"/>Bit-fields with more than one bit are usually manipulated using the built-in bitwise operators (&#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a>, p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">152</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">File &amp;File::open(File::modes m)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;mode |= READ;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">set the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">READ</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bit by default</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other processing</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (m &amp; WRITE) // <span><span class="calibre45"><span class="calibre16">if opening</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">READ</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">WRITE</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">processing to open the file in read/write mode</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Classes that define bit-field members also usually define a set of inline member functions to test and set the value of the bit-field:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">inline bool File::isRead() const { return mode &amp; READ; }<br class="calibre6"/>inline void File::setWrite() { mode |= WRITE; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 id="filepos5364677" class="calibre37"><span class="calibre5">19.8.2. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">volatile</span></span></tt></span></span></tt></code> Qualifier</span></h4><div class="calibre38">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The precise meaning of <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> is inherently machine dependent and can be understood only by reading the compiler documentation. Programs that use <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> usually must be changed when they are moved to new machines or compilers.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Programs that deal directly with hardware often have data elements whose value is controlled by processes outside the direct control of the program itself. For example, a program might contain a variable updated by the system clock. An object should be declared <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5365974" href="186-defined_terms.html#filepos5411539">volatile</a></span></span></tt></span></span></tt></code> when its value might be changed in ways outside the control or detection of the program. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> keyword is a directive to the compiler that it should not perform optimizations on such objects.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> qualifier is used in much the same way as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualifier. It is an additional modifier to a type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">volatile int display_register; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">value that might change</span></span></span><br class="calibre6"/>volatile&#160;Task *curr_task;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curr_task points</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>volatile&#160;int iax[max_size]; // <span><span class="calibre45"><span class="calibre16">each element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iax</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span><br class="calibre6"/>volatile&#160;Screen bitmapBuf; // <span><span class="calibre45"><span class="calibre16">each member of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bitmapBuf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There is no interaction between the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> type qualifiers. A type can be both <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>, in which case it has the properties of both.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the same way that a class may define <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member functions, it can also define member functions as <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>. Only <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> member functions may be called on <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> objects.</p><div class="calibre22">&#160;</div>
<p class="calibre25">&#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a> (p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>) described the interactions between the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualifier and pointers. The same interactions exist between the <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> qualifier and pointers. We can declare pointers that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>, pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> objects, and pointers that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> that point to <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> objects:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5369975"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">volatile int v;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile int</span></span></tt></span><br class="calibre6"/>int *volatile vip;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>volatile int *ivp;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ivp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile int</span></span></tt></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vivp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile int</span></span></tt></span><br class="calibre6"/>volatile int *volatile vivp;<br class="calibre6"/>int *ip = &amp;v;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: must use a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span><br class="calibre6"/>*ivp = &amp;v;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ivp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span><br class="calibre6"/>vivp = &amp;v;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vivp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we may assign the address of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> object (or copy a pointer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> type) only to a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>. We may use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> object to initialize a reference only if the reference is <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Synthesized Copy Does Not Apply to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">volatile</span></span></tt></span></span></tt></code> Objects</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One important difference between the treatment of <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> is that the synthesized copy/move and assignment operators cannot be used to initialize or assign from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> object. The synthesized members take parameters that are references to (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and we cannot bind a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If a class wants to allow <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> objects to be copied, moved, or assigned, it must define its own versions of the copy or move operation. As one example, we might write the parameters as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const volatile</span></tt></code> references, in which case we can copy or assign from any kind of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo(const volatile Foo&amp;); // <span><span class="calibre45"><span class="calibre16">copy from a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign from a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to a non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Foo&amp; operator=(volatile const Foo&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign from a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">volatile</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Foo&amp; operator=(volatile const Foo&amp;) volatile;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remainder of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">class Foo</span></span></tt></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although we can define copy and assignment for <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> objects, a deeper question is whether it makes any sense to copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> object. The answer to that question depends intimately on the reason for using <code class="calibre23"><tt class="calibre23"><span class="calibre24">volatile</span></tt></code> in any particular program.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5377152" class="calibre37"><span class="calibre5">19.8.3. Linkage Directives: <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">extern "C"</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">C++ programs sometimes need to call functions written in another programming language. Most often, that other language is C. Like any name, the name of a function written in another language must be declared. As with any function, that declaration must specify the return type and parameter list. The compiler checks calls to functions written in another language in the same way that it handles ordinary C++ functions. However, the compiler typically must generate different <a id="filepos5377897"/>code to call functions written in other languages. C++ uses <strong class="calibre5"><a id="filepos5377973" href="186-defined_terms.html#filepos5401528">linkage directives</a></strong> to indicate the language used for any non-C++ function.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Mixing C++ with code written in any other language, including C, requires access to a compiler for that language that is compatible with your C++ compiler.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Declaring a Non-C++ Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A linkage directive can have one of two forms: single or compound. Linkage directives may not appear inside a class or function definition. The same linkage directive must appear on every declaration of a function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, the following declarations shows how some of the C functions in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstring</span></tt></code> header might be declared:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">illustrative linkage directives that might appear in the C++ header</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;cstring&gt;</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">single-statement linkage directive</span></span></span><br class="calibre6"/>extern "C" size_t strlen(const char *);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">compound-statement linkage directive</span></span></span><br class="calibre6"/>extern "C" {<br class="calibre6"/>&#160;&#160;&#160;&#160;int strcmp(const char*, const char*);<br class="calibre6"/>&#160;&#160;&#160;&#160;char *strcat(char*, const char*);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first form of a linkage directive consists of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> keyword followed by a string literal, followed by an &#8220;ordinary&#8221; function declaration.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The string literal indicates the language in which the function is written. A compiler is required to support linkage directives for C. A compiler may provide linkage specifications for other languages, for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern "Ada", extern "FORTRAN"</span></tt></code>, and so on.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Linkage Directives and Headers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can give the same linkage to several functions at once by enclosing their declarations inside curly braces following the linkage directive. These braces serve to group the declarations to which the linkage directive applies. The braces are otherwise ignored, and the names of functions declared within the braces are visible as if the functions were declared outside the braces.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The multiple-declaration form can be applied to an entire header file. For example, the C++ <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstring</span></tt></code> header might look like</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">compound-statement linkage directive</span></span></span><br class="calibre6"/>extern "C" {<br class="calibre6"/>#include &lt;string.h&gt;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">C functions that manipulate C-style strings</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">#include</span></tt></code> directive is enclosed in the braces of a compound-linkage directive, all ordinary function declarations in the header file are assumed to be functions written in the language of the linkage directive. Linkage directives can be <a id="filepos5382520"/>nested, so if a header contains a function with its own linkage directive, the linkage of that function is unaffected.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The functions that C++ inherits from the C library are permitted to be defined as C functions but are not required to be C functions&#8212;it&#8217;s up to each C++ implementation to decide whether to implement the C library functions in C or C++.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">extern "C"</span></span></tt></span></span></tt></code> Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The language in which a function is written is part of its type. Hence, every declaration of a function defined with a linkage directive must use the same linkage directive. Moreover, pointers to functions written in other languages must be declared with the same linkage directive as the function itself:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a C</span></span></span>
<span><span class="calibre45"><span class="calibre16">function that returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">void</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and takes an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>extern "C" void (*pf)(int);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> is used to call a function, the function call is compiled assuming that the call is to a C function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A pointer to a C function does not have the same type as a pointer to a C++ function. A pointer to a C function cannot be initialized or be assigned to point to a C++ function (and vice versa). As with any other type mismatch, it is an error to try to assign two pointers with different linkage directives:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void (*pf1)(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">points to a C++ function</span></span></span><br class="calibre6"/>extern "C" void (*pf2)(int);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">points to a C function</span></span></span><br class="calibre6"/>pf1 = pf2; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have different types</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some C++ compilers may accept the preceding assignment as a language extension, even though, strictly speaking, it is illegal.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Linkage Directives Apply to the Entire Declaration</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we use a linkage directive, it applies to the function and any function pointers used as the return type or as a parameter type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a C function; its parameter is a pointer to a C function</span></span></span><br class="calibre6"/>extern "C" void f1(void(*)(int));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This declaration says that <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> is a C function that doesn&#8217;t return a value. It has one parameter, which is a pointer to a function that returns nothing and takes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter. The linkage directive applies to the function pointer as well as to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code>. When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code>, we must pass it the name of a C function or a pointer to a C function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because a linkage directive applies to all the functions in a declaration, we must use a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) if we wish to pass a pointer to a C function to a C++ function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5388525"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">FC</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to a C function</span></span></span><br class="calibre6"/>extern "C" typedef void FC(int);<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a C++ function with a parameter that is a pointer to a C function</span></span></span><br class="calibre6"/>void f2(FC *);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Exporting Our C++ Functions to Other Languages</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By using the linkage directive on a function definition, we can make a C++ function available to a program written in another language:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">calc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function can be called from C programs</span></span></span><br class="calibre6"/>extern "C" double calc(double dparm) { /* <span><span class="calibre45"><span class="calibre16">...</span></span></span>&#160;&#160;&#160;&#160;*/ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler generates code for this function, it will generate code appropriate to the indicated language.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that the parameter and return types in functions that are shared across languages are often constrained. For example, we can almost surely not write a function that passes objects of a (nontrivial) C++ class to a C program. The C program won&#8217;t know about the constructors, destructors, or other class-specific operations.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Preprocessor Support for Linking to C</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">To allow the same source file to be compiled under either C or C++, the preprocessor defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">_ _cplusplus</span></tt></code> (two underscores) when we compile C++. Using this variable, we can conditionally include code when we are compiling C++:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">#ifdef __cplusplus<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: we're compiling C++</span></span></span><br class="calibre6"/>extern "C"<br class="calibre6"/>#endif<br class="calibre6"/>int strcmp(const char*, const char*);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloaded Functions and Linkage Directives</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The interaction between linkage directives and function overloading depends on the target language. If the language supports overloaded functions, then it is likely that a compiler that implements linkage directives for that language would also support overloading of these functions from C++.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The C language does not support function overloading, so it should not be a surprise that a C linkage directive can be specified for only one function in a set of overloaded functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">extern "C"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">functions with the same name</span></span></span><br class="calibre6"/>extern "C" void print(const char*);<br class="calibre6"/>extern "C" void print(int);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">If one function among a set of overloaded functions is a C function, the other functions must all be C++ functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5393443"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SmallInt { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;&#160;*/ };<br class="calibre6"/>class BigNum { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;&#160;*/ };<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the C function can be called from C and C++ programs</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the C++ functions overload that function and are callable from C++</span></span></span><br class="calibre6"/>extern "C" double calc(double);<br class="calibre6"/>extern SmallInt calc(const SmallInt&amp;);<br class="calibre6"/>extern BigNum calc(const BigNum&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The C version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">calc</span></tt></code> can be called from C programs and from C++ programs. The additional functions are C++ functions with class parameters that can be called only from C++ programs. The order of the declarations is not significant.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.8.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.26:</strong> Explain these declarations and indicate whether they are legal:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">extern "C" int compute(int *, int);<br class="calibre6"/>extern "C" double compute(double *, double);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="183-19.7._local_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="185-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
