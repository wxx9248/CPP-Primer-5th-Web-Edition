<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>2.5. Dealing with Types</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="024-2.4._const_qualifier.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="026-2.6._defining_our_own_data_structures.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos535463" class="calibre29"><span class="bold">2.5. Dealing with Types</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">As our programs get more complicated, we&#8217;ll see that the types we use also get more complicated. Complications in using types arise in two different ways. Some types are hard to &#8220;spell.&#8221; That is, they have forms that are tedious and error-prone to write. Moreover, the form of a complicated type can obscure its purpose or meaning. The other source of complication is that sometimes it is hard to determine the exact type we need. Doing so can require us to look back into the context of the program.</p><div class="calibre15">&#160;</div>
<h4 id="filepos536134" class="calibre37"><span class="calibre5">2.5.1. Type Aliases</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos536265" href="028-defined_terms.html#filepos628113">type alias</a></strong> is a name that is a synonym for another type. Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can define a type alias in one of two ways. Traditionally, we use a <strong class="calibre5"><a id="filepos536684" href="028-defined_terms.html#filepos628979">typedef</a></strong>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef double wages;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">wages</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a synonym for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>typedef wages base, *p; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a synonym for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double*</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos537903"/>The keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> may appear as part of the base type of a declaration (&#167; <a href="023-2.3._compound_types.html#filepos394806">2.3</a>, p. <a href="023-2.3._compound_types.html#filepos394806">50</a>). Declarations that include <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> define type aliases rather than variables. As in any other declaration, the declarators can include type modifiers that define compound types built from the base type of the definition.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos538451"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">The new standard introduced a second way to define a type alias, via an <strong class="calibre5"><a id="filepos538618" href="028-defined_terms.html#filepos611960">alias declaration</a></strong>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using SI = Sales_item;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">SI</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a synonym for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_item</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">An alias declaration starts with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> followed by the alias name and an <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>. The alias declaration defines the name on the left-hand side of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> as an alias for the type that appears on the right-hand side.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A type alias is a type name and can appear wherever a type name can appear:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">wages hourly, weekly;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">same as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double hourly, weekly;</span></span></tt></span><br class="calibre6"/>SI item;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">same as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_item item</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointers, <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code>, and Type Aliases</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Declarations that use type aliases that represent compound types and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> can yield surprising results. For example, the following declarations use the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">pstring</span></tt></code>, which is an alias for the the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef char *pstring;<br class="calibre6"/>const pstring cstr = 0; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cstr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span><br class="calibre6"/>const pstring *ps;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to a constant pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The base type in these declarations is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const pstring</span></tt></code>. As usual, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> that appears in the base type modifies the given type. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pstring</span></tt></code> is &#8220;pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>.&#8221; So, <code class="calibre23"><tt class="calibre23"><span class="calibre24">const pstring</span></tt></code> is a constant pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>&#8212;not a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It can be tempting, albeit incorrect, to interpret a declaration that uses a type alias by conceptually replacing the alias with its corresponding type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char *cstr = 0; // <span><span class="calibre45"><span class="calibre16">wrong interpretation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const pstring cstr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, this interpretation is wrong. When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">pstring</span></tt></code> in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code>, the base type is <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> is part of the declarator. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code> is the base type. This rewrite declares <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstr</span></tt></code> as a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code> rather than as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos544751" class="calibre37"><span class="calibre5">2.5.2. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">auto</span></span></tt></span></span></tt></code> Type Specifier</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<div class="calibre28"><a id="filepos545053"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">It is not uncommon to want to store the value of an expression in a variable. To declare the variable, we have to know the type of that expression. When we write a program, it can be surprisingly difficult&#8212;and sometimes even impossible&#8212;to determine the type of an expression. Under the new standard, we can let the compiler figure out the type for us by using the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos545603" href="028-defined_terms.html#filepos612931">auto</a></span></span></tt></span></span></tt></code> type specifier. Unlike type specifiers, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, that name a specific type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> tells the compiler to deduce <a id="filepos545937"/>the type from the initializer. By implication, a variable that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> as its type specifier must have an initializer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is deduced from the type of the result of adding</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val2</span></span></tt></span><br class="calibre6"/>auto item = val1 + val2; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">initialized to the result of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val1 + val2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here the compiler will deduce the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> from the type returned by applying <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">val1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">val2</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">val1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">val2</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_item</span></tt></code> objects (&#167; <a href="015-1.5._introducing_classes.html#filepos219539">1.5</a>, p. <a href="015-1.5._introducing_classes.html#filepos219539">19</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> will have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_item</span></tt></code>. If those variables are type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, and so on.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any other type specifier, we can define multiple variables using <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto i = 0, *p = &amp;i;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>auto sz = 0, pi = 3.14;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: inconsistent types for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sz</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Compound Types, <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">auto</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The type that the compiler infers for <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> is not always exactly the same as the initializer&#8217;s type. Instead, the compiler adjusts the type to conform to normal initialization rules.</p><div class="calibre15">&#160;</div>
<p class="calibre25">First, as we&#8217;ve seen, when we use a reference, we are really using the object to which the reference refers. In particular, when we use a reference as an initializer, the initializer is the corresponding object. The compiler uses that object&#8217;s type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>&#8217;s type deduction:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, &amp;r = i;<br class="calibre6"/>auto a = r;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an alias for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, which has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int)</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Second, <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> ordinarily ignores top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>). As usual in initializations, low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s, such as when an initializer is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, are kept:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int ci = i, &amp;cr = ci;<br class="calibre6"/>auto b = ci;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(top-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is dropped)</span></span></span><br class="calibre6"/>auto c = cr;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an alias for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level)</span></span></span><br class="calibre6"/>auto d = &amp;i;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">d</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span><span><span class="calibre45"><span class="calibre16">(</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span><span><span class="calibre45"><span class="calibre16">)</span></span></span><br class="calibre6"/>auto e = &amp;ci; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int*</span></span></tt></span><span><span class="calibre45"><span class="calibre16">(</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object is low-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we want the deduced type to have a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we must say so explicitly:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const auto f = ci; // <span><span class="calibre45"><span class="calibre16">deduced type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can also specify that we want a reference to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>-deduced type. Normal initialization rules still apply:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto &amp;g = ci;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">g</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that is bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><br class="calibre6"/>auto &amp;h = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: we can't bind a plain reference to a literal</span></span></span><br class="calibre6"/>const auto &amp;j = 42; // <span><span class="calibre45"><span class="calibre16">ok: we can bind a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference to a literal</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos558223"/>When we ask for a reference to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>-deduced type, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s in the initializer are not ignored. As usual, <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are not top-level when we bind a reference to an initializer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we define several variables in the same statement, it is important to remember that a reference or pointer is part of a particular declarator and not part of the base type for the declaration. As usual, the initializers must provide consistent <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>-deduced types:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto k = ci, &amp;l = i;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">l</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><br class="calibre6"/>auto &amp;m = ci, *p = &amp;ci; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">m</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;;p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: type deduced from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; type deduced from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>auto &amp;n = i, *p2 = &amp;ci;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.5.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.33:</strong> Using the variable definitions from this section, determine what happens in each of these assignments:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">a = 42;&#160;&#160;&#160;b = 42;&#160;&#160;&#160;c = 42;<br class="calibre6"/>d = 42;&#160;&#160;&#160;e = 42;&#160;&#160;&#160;g = 42;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.34:</strong> Write a program containing the variables and assignments from the previous exercise. Print the variables before and after the assignments to check whether your predictions in the previous exercise were correct. If not, study the examples until you can convince yourself you know what led you to the wrong conclusion.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.35:</strong> Determine the types deduced in each of the following definitions. Once you&#8217;ve figured out the types, write a program to see whether you were correct.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int i = 42;<br class="calibre6"/>auto j = i; const auto &amp;k = i; auto *p = &amp;i;<br class="calibre6"/>const auto j2 = i, &amp;k2 = i;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos562878" class="calibre37"><span class="calibre5">2.5.3. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">decltype</span></span></tt></span></span></tt></code> Type Specifier</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos563522" href="028-defined_terms.html#filepos617197">decltype</a></span></span></tt></span></span></tt></code>, which returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression:</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos563798"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">decltype(f()) sum = x; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has whatever type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, the compiler does not call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, but it uses the type that such a call would return as the type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code>. That is, the compiler gives <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> the same type as the type that would be returned if we were to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The way <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> handles top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and references differs subtly from the way <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> does. When the expression to which we apply <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> is a variable, <a id="filepos565428"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> returns the type of that variable, including top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and references:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int ci = 0, &amp;cj = ci;<br class="calibre6"/>decltype(ci) x = 0; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">x</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>decltype(cj) y = x; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">y</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and is bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">x</span></span></tt></span><br class="calibre6"/>decltype(cj) z;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">z</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference and must be initialized</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">cj</span></tt></code> is a reference, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(cj)</span></tt></code> is a reference type. Like any other reference, <code class="calibre23"><tt class="calibre23"><span class="calibre24">z</span></tt></code> must be initialized.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> is the <em class="calibre16">only</em> context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">decltype</span></span></tt></span></span></tt></code> and References</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">When we apply <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to an expression that is not a variable, we get the type that that expression yields. As we&#8217;ll see in &#167; <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a> (p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>), some expressions will cause <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to yield a reference type. Generally speaking, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">decltype</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of an expression can be a reference type</span></span></span><br class="calibre6"/>int i = 42, *p = &amp;i, &amp;r = i;<br class="calibre6"/>decltype(r + 0) b;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: addition yields an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an (uninitialized</span></span></span>) <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>decltype(*p) c;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and must be initialized</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> is a reference, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(r)</span></tt></code> is a reference type. If we want the type to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> refers, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> in an expression, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">r + 0</span></tt></code>, which is an expression that yields a value that has a nonreference type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">On the other hand, the dereference operator is an example of an expression for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> returns a reference. As we&#8217;ve seen, when we dereference a pointer, we get the object to which the pointer points. Moreover, we can assign to that object. Thus, the type deduced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(*p)</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>, not plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre25">Another important difference between <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> is that the deduction done by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>
<em class="calibre16">depends on the form of its given expression</em>. What can be confusing is that enclosing the name of a variable in parentheses affects the type returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>. When we apply <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to a variable without any parentheses, we get the type of that variable. If we wrap the variable&#8217;s name in one or more sets of parentheses, the compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> on such an expression yields a reference:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">decltype</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of a parenthesized variable is always a reference</span></span></span><br class="calibre6"/>decltype((i)) d;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">d</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and must be initialized</span></span></span><br class="calibre6"/>decltype(i) e;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an (uninitialized</span></span></span>) <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Remember that <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype((</span></tt></code><em class="calibre16">variable</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">))</span></tt></code> (note, double parentheses) is always a reference type, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(</span></tt></code><em class="calibre16">variable</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">)</span></tt></code> is a reference type only if <em class="calibre16">variable</em> is a reference.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos574381"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.5.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.36:</strong> In the following code, determine the type of each variable and the value each variable has when the code finishes:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int a = 3, b = 4;<br class="calibre6"/>decltype(a) c = a;<br class="calibre6"/>decltype((b)) d = a;<br class="calibre6"/>++c;<br class="calibre6"/>++d;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.37:</strong> Assignment is an example of an expression that yields a reference type. The type is a reference to the type of the left-hand operand. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, then the type of the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">i = x</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. Using that knowledge, determine the type and value of each variable in this code:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int a = 3, b = 4;<br class="calibre6"/>decltype(a) c = a;<br class="calibre6"/>decltype(a = b) d = a;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.38:</strong> Describe the differences in type deduction between <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>. Give an example of an expression where <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> will deduce the same type and an example where they will deduce differing types.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="024-2.4._const_qualifier.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="026-2.6._defining_our_own_data_structures.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
