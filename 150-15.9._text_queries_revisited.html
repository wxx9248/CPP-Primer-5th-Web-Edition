<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.9. Text Queries Revisited</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="149-15.8._containers_and_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="151-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4051570" class="calibre29"><span class="bold">15.9. Text Queries Revisited</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">As a final example of inheritance, we&#8217;ll extend our text-query application from &#167;<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>). The classes we wrote in that section let us look for occurrences of a <a id="filepos4051934"/>given word in a file. We&#8217;d like to extend the system to support more complicated queries. In our examples, we&#8217;ll run queries against the following simple story:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Alice Emma has long flowing red hair.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Her Daddy says when the wind blows</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">through her hair, it looks almost alive,</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">like a fiery bird in flight.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">A beautiful fiery bird, he tells her,</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">magical but untamed.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">"Daddy, shush, there is no such thing,"</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">she tells him, at the same time wanting</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">him to tell her more.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Shyly, she asks, "I mean, Daddy, is there?"</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our system should support the following queries:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Word queries find all the lines that match a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Executing Query for:</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Daddy Daddy occurs 3 times</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 2) Her Daddy says when the wind blows</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 7) "Daddy, shush, there is no such thing,"</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 10) Shyly, she asks, "I mean, Daddy, is there?"</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Not queries, using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator, yield lines that don&#8217;t match the query:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Executing Query for: ~(Alice)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">~(Alice) occurs 9 times</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 2) Her Daddy says when the wind blows</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 3) through her hair, it looks almost alive,</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 4) like a fiery bird in flight.</span></span></tt></span><br class="calibre6"/>...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Or queries, using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code> operator, return lines matching either of two queries:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Executing Query for: (hair | Alice)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(hair | Alice) occurs 2 times</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 1) Alice Emma has long flowing red hair.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 3) through her hair, it looks almost alive,</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; And queries, using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> operator, return lines matching both queries:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Executing query for: (hair &amp; Alice)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(hair &amp; Alice) occurs 1 time</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 1) Alice Emma has long flowing red hair.</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Moreover, we want to be able to combine these operations, as in</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">fiery &amp; bird | wind</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We&#8217;ll use normal C++ precedence rules (&#167;<a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>) to evaluate compound expressions such as this example. Thus, this query will match a line in which both <code class="calibre23"><tt class="calibre23"><span class="calibre24">fiery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bird</span></tt></code> appear or one in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">wind</span></tt></code> appears:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><a id="filepos4057722"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Executing Query for: ((fiery &amp; bird) | wind)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">((fiery &amp; bird) | wind) occurs 3 times</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 2) Her Daddy says when the wind blows</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 4) like a fiery bird in flight.</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">(line 5) A beautiful fiery bird, he tells her,</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our output will print the query, using parentheses to indicate the way in which the query was interpreted. As with our original implementation, our system will display lines in ascending order and will not display the same line more than once.</p><div class="calibre15">&#160;</div>
<h4 id="filepos4058655" class="calibre37"><span class="calibre5">15.9.1. An Object-Oriented Solution</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We might think that we should use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> class from &#167;<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">487</a>) to represent our word query and derive our other queries from that class.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, this design would be flawed. To see why, consider a Not query. A Word query looks for a particular word. In order for a Not query to be a kind of Word query, we would have to be able to identify the word for which the Not query was searching. In general, there is no such word. Instead, a Not query has a query (a Word query or any other kind of query) whose value it negates. Similarly, an And query and an Or query have two queries whose results it combines.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This observation suggests that we model our different kinds of queries as independent classes that share a common base class:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">WordQuery // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Daddy</span></span></tt></span><br class="calibre6"/>NotQuery&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">~Alice</span></span></tt></span><br class="calibre6"/>OrQuery&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hair</span></span></tt></span> | <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Alice</span></span></tt></span><br class="calibre6"/>AndQuery&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hair &amp; Alice</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These classes will have only two operations:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code>, which takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> object and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> function will use the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> object to find the query&#8217;s the matching lines.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>, which returns the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representation of the underlying query. This function will be used by <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> to create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> representing the match and by the output operator to print the query expressions.</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Abstract Base Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, our four query types are not related to one another by inheritance; they are conceptually siblings. Each class shares the same interface, which suggests that we&#8217;ll need to define an abstract base class (&#167;<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>) to represent that interface. We&#8217;ll name our abstract base class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>, indicating that its role is to serve as the root of our query hierarchy.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> class will define <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> as pure virtual functions (&#167;<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>). Each of our classes that represents a particular kind of query must override these functions. We&#8217;ll derive <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> directly from <a id="filepos4063003"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> classes share one property that the other classes in our system do not: Each has two operands. To model this property, we&#8217;ll define another abstract base class, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code>, to represent queries with two operands. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> classes will inherit from <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code>, which in turn will inherit from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. These decisions give us the class design represented in <a href="150-15.9._text_queries_revisited.html#filepos4064029">Figure 15.2</a>.</p><div class="calibre22">&#160;</div>
<div class="calibre52"><a id="filepos4064029"/><img alt="Image" src="images/00103.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 15.2. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query_base</span></span></tt></span></span></tt></code> Inheritance Hierarchy</span></p><div class="calibre12">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Inheritance versus Composition</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The design of inheritance hierarchies is a complicated topic in its own right and well beyond the scope of this language Primer. However, there is one important design guide that is so fundamental that every programmer should be familiar with it.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">When we define a class as publicly inherited from another, the derived class should reflect an &#8220;Is A&#8221; relationship to the base class. In well-designed class hierarchies, objects of a publicly derived class can be used wherever an object of the base class is expected.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Another common relationship among types is a &#8220;Has A&#8221; relationship. Types related by a &#8220;Has A&#8221; relationship imply membership.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">In our bookstore example, our base class represents the concept of a quote for a book sold at a stipulated price. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> &#8220;is a&#8221; kind of quote, but one with a different pricing strategy. Our bookstore classes &#8220;have a&#8221; price and an <small class="calibre48">ISBN</small>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Hiding a Hierarchy in an Interface Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Our program will deal with evaluating queries, not with building them. However, we need to be able to create queries in order to run our program. The simplest way to do so is to write C++ expressions to create the queries. For example, we&#8217;d like to generate the compound query previously described by writing code such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Query q = Query("fiery") &amp; Query("bird") | Query("wind");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4066923"/>This problem description implicitly suggests that user-level code won&#8217;t use the inherited classes directly. Instead, we&#8217;ll define an interface class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>, which will hide the hierarchy. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class will store a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. That pointer will be bound to an object of a type derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class will provide the same operations as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> classes: <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> to evaluate the associated query, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> to generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> version of the query. It will also define an overloaded output operator to display the associated query.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Users will create and manipulate <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> objects only indirectly through operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> objects. We&#8217;ll define three overloaded operators on <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> objects, along with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Each of these functions will dynamically allocate a new object of a type derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> operator will generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> bound to a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code> operator will generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> bound to a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator will generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> bound to a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> will generate a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Understanding How These Classes Work</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is important to realize that much of the work in this application consists of building objects to represent the user&#8217;s query. For example, an expression such as the one above generates the collection of interrelated objects illustrated in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a>.</p><div class="calibre15">&#160;</div>
<div class="calibre52"><a id="filepos4070749"/><img alt="Image" src="images/00104.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 15.3. Objects Created by <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query</span></span></tt></span></span></tt></code> Expressions</span></p><div class="calibre12">&#160;</div>
<p class="calibre25">Once the tree of objects is built up, evaluating (or generating the representation of) a query is basically a process (managed for us by the compiler) of following these links, asking each object to evaluate (or display) itself. For example, if we <a id="filepos4071360"/>call <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> (i.e., on the root of the tree), that call asks the <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> points to <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> itself. Evaluating this <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on its two operands&#8212;on the <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> that looks for the word <code class="calibre23"><tt class="calibre23"><span class="calibre24">wind</span></tt></code>. Evaluating the <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> evaluates its two <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code>s, generating the results for the words <code class="calibre23"><tt class="calibre23"><span class="calibre24">fiery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bird</span></tt></code>, respectively.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When new to object-oriented programming, it is often the case that the hardest part in understanding a program is understanding the design. Once you are thoroughly comfortable with the design, the implementation flows naturally. As an aid to understanding this design, we&#8217;ve summarized the classes used in this example in <a href="150-15.9._text_queries_revisited.html#filepos4073117">Table 15.1</a> (overleaf).</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4073117"/>Table 15.1. Recap: Query Program Design</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00105.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.9.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.31:</strong> Given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">s1</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">s2</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">s3</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">s4</span></tt></code> are all <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, determine what objects are created in the following expressions:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Query(s1) | Query(s2) &amp; ~ Query(s3);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">Query(s1) | (Query(s2) &amp; ~ Query(s3));</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(Query(s1) &amp; (Query(s2)) | (Query(s3) &amp; Query(s4)));</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4074865" class="calibre37"><span class="calibre5">15.9.2. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query_base</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query</span></span></tt></span></span></tt></code> Classes</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;ll start our implementation by defining the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">abstract class acts as a base class for concrete query types; all members are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">private</span></span></tt></span><br class="calibre6"/>class Query_base {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Query;<br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;using line_no = TextQuery::line_no; // <span><span class="calibre45"><span class="calibre16">used in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">eval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">functions</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual ~Query_base() = default;<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">eval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">QueryResult</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that matches this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual QueryResult eval(const TextQuery&amp;) const = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rep</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">representation of the query</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual std::string rep() const = 0;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> are pure virtual functions, which makes <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> an abstract base class (&#167;<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>). Because we don&#8217;t intend users, or the derived classes, to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> directly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> has no <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> members. All use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> will be through <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> objects. We grant friendship to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class, because members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> will call the virtuals in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">protected</span></tt></code> member, <code class="calibre23"><tt class="calibre23"><span class="calibre24">line_no</span></tt></code>, will be used inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions. Similarly, the destructor is <code class="calibre23"><tt class="calibre23"><span class="calibre24">protected</span></tt></code> because it is used (implicitly) by the destructors in the derived classes.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4079028"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class provides the interface to (and hides) the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> inheritance hierarchy. Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> object will hold a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> object. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> is the only interface to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> classes, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> must define its own versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> will create a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> and bind its <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> member to that newly created object. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operators will create <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> objects, respectively. These operators will return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> object bound to its newly generated object. To support these operators, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> needs a constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> and stores its given pointer. We&#8217;ll make this constructor <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> because we don&#8217;t intend general user code to define <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> objects. Because this constructor is <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, we&#8217;ll need to make the operators <code class="calibre23"><tt class="calibre23"><span class="calibre24">friend</span></tt></code>s.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Given the preceding design, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class itself is simple:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">interface class to manage the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query_base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inheritance hierarchy</span></span></span><br class="calibre6"/>class Query {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">these operators need access to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator~(const Query &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator|(const Query&amp;, const Query&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator&amp;(const Query&amp;, const Query&amp;);<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Query(const std::string&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">builds a new</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">WordQuery</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">interface functions: call the corresponding</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query_base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operations</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;QueryResult eval(const TextQuery &amp;t) const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return q-&gt;eval(t); }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string rep() const { return q-&gt;rep(); }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;Query(std::shared_ptr&lt;Query_base&gt; query): q(query) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;Query_base&gt; q;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4084404"/>We start by naming as friends the operators that create <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> objects. These operators need to be friends in order to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> interface for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>, we declare, but cannot yet define, the constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. That constructor creates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> object, so we cannot define this constructor until we have defined the <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> class.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The other two <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> members represent the interface for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. In each case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> operation uses its <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> pointer to call the respective (virtual) <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> operation. The actual version that is called is determined at run time and will depend on the type of the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> points.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Query</span></span></tt></span></span></tt></code> Output Operator</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">The output operator is a good example of how our overall query system works:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::ostream &amp;<br class="calibre6"/>operator&lt;&lt;(std::ostream &amp;os, const Query &amp;query)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query::rep</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">makes a virtual call through its</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query_base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rep()</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return os &lt;&lt; query.rep();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we print a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>, the output operator calls the (public) <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>. That function makes a virtual call through its pointer member to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> member of the object to which this <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> points. That is, when we write</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Query andq = Query(sought1) &amp; Query(sought2);<br class="calibre6"/>cout &lt;&lt; andq &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the output operator calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query::rep</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">andq</span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query::rep</span></tt></code> in turn makes a virtual call through its <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">andq</span></tt></code> points to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> object, that call will run <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery::rep</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.9.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.32:</strong> What happens when an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> is copied, moved, assigned, and destroyed?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.33:</strong> What about objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4089928" class="calibre37"><span class="calibre5"><a id="filepos4089961"/>15.9.3. The Derived Classes</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The most interesting part of the classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> is how they are represented. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> class is most straightforward. Its job is to hold the search word.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The other classes operate on one or two operands. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> has a single operand, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> have two operands. In each of these classes, the operand(s) can be an object of any of the concrete classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>: A <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> can be applied to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code>, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code>, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code>, or another <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>. To allow this flexibility, the operands must be stored as pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>. That way we can bind the pointer to whichever concrete class we need.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, rather than storing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> pointer, our classes will themselves use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> object. Just as user code is simplified by using the interface class, we can simplify our own class code by using the same class.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Now that we know the design for these classes, we can implement them.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">WordQuery</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> looks for a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. It is the only operation that actually performs a query on the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class WordQuery: public Query_base {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Query; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">WordQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;WordQuery(const std::string &amp;s): query_word(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">concrete class:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">WordQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">defines all inherited pure virtual functions</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;QueryResult eval(const TextQuery &amp;t) const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return t.query(query_word); }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string rep() const { return query_word; }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string query_word;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">word for which to search</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> has no <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> members; <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> must make <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> a friend in order to allow <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> to access the <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each of the concrete query classes must define the inherited pure virtual functions, <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>. We defined both operations inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> class body: <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">query</span></tt></code> member of its given <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> parameter, which does the actual search in the file; <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> returns the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> represents (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">query_word</span></tt></code>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Having defined the <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> class, we can now define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">inline<br class="calibre6"/>Query::Query(const std::string &amp;s): q(new WordQuery(s)) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This constructor allocates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">WordQuery</span></tt></code> and initializes its pointer member to point to that newly allocated object.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">NotQuery</span></span></tt></span></span></tt></code> Class and the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">~</span></span></tt></span></span></tt></code> Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator generates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>, which holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>, which it negates:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4097604"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class NotQuery: public Query_base {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator~(const Query &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;NotQuery(const Query &amp;q): query(q) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">concrete class:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NotQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">defines all inherited pure virtual functions</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string rep() const {return "~(" + query.rep() + ")";}<br class="calibre6"/>&#160;&#160;&#160;&#160;QueryResult eval(const TextQuery&amp;) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;Query query;<br class="calibre6"/>};<br class="calibre6"/>inline Query operator~(const Query &amp;operand)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return std::shared_ptr&lt;Query_base&gt;(new NotQuery(operand));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> are all <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, we start by making the <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator a friend. To <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>, we concatenate the <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> symbol to the representation of the underlying <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>. We parenthesize the output to ensure that precedence is clear to the reader.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>&#8217;s own <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> member ultimately makes a virtual call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>: <code class="calibre23"><tt class="calibre23"><span class="calibre24">query.rep()</span></tt></code> is a nonvirtual call to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> class. <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query::rep</span></tt></code> in turn calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">q-&gt;rep()</span></tt></code>, which is a virtual call through its <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> pointer.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator dynamically allocates a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> object. The return (implicitly) uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Query_base&gt;</span></tt></code>. That is, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement is equivalent to</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">allocate a new</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NotQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">bind the resulting</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NotQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr&lt;Query_base</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;Query_base&gt; tmp(new NotQuery(expr));<br class="calibre6"/>return Query(tmp); // <span><span class="calibre45"><span class="calibre16">use the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> member is complicated enough that we will implement it outside the class body. We&#8217;ll define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions in &#167;<a href="150-15.9._text_queries_revisited.html#filepos4114112">15.9.4</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4114112">647</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">BinaryQuery</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> class is an abstract base class that holds the data needed by the query types that operate on two operands:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class BinaryQuery: public Query_base {<br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;BinaryQuery(const Query &amp;l, const Query &amp;r, std::string s):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lhs(l), rhs(r), opSym(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">abstract class:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">BinaryQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">doesn't define</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">eval</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string rep() const { return "(" + lhs.rep() + " "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ opSym + " "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+ rhs.rep() + ")"; }<br class="calibre6"/>&#160;&#160;&#160;&#160;Query lhs, rhs;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">right- and left-hand operands</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string opSym; // <span><span class="calibre45"><span class="calibre16">name of the operator</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4104958"/>The data in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> are the two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> operands and the corresponding operator symbol. The constructor takes the two operands and the operator symbol, each of which it stores in the corresponding data members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryOperator</span></tt></code>, we generate the parenthesized expression consisting of the representation of the left-hand operand, followed by the operator, followed by the representation of the right-hand operand. As when we displayed a <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code>, the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> ultimately make virtual calls to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> function of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> objects to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">lhs</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> point.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> class does not define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> function and so inherits a pure virtual. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> is also an abstract base class, and we cannot create objects of <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">AndQuery</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">OrQuery</span></span></tt></span></span></tt></code> Classes and Associated Operators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> classes, and their corresponding operators, are quite similar to one another:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class AndQuery: public BinaryQuery {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator&amp; (const Query&amp;, const Query&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;AndQuery(const Query &amp;left, const Query &amp;right):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryQuery(left, right, "&amp;") { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">concrete class:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">AndQuery</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inherits</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rep</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and defines the remaining pure virtual</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;QueryResult eval(const TextQuery&amp;) const;<br class="calibre6"/>};<br class="calibre6"/>inline Query operator&amp;(const Query &amp;lhs, const Query &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return std::shared_ptr&lt;Query_base&gt;(new AndQuery(lhs, rhs));<br class="calibre6"/>}<br class="calibre6"/><br class="calibre6"/>class OrQuery: public BinaryQuery {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend Query operator|(const Query&amp;, const Query&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;OrQuery(const Query &amp;left, const Query &amp;right):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinaryQuery(left, right, "|") { }<br class="calibre6"/>&#160;&#160;&#160;&#160;QueryResult eval(const TextQuery&amp;) const;<br class="calibre6"/>};<br class="calibre6"/>inline Query operator|(const Query &amp;lhs, const Query &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return std::shared_ptr&lt;Query_base&gt;(new OrQuery(lhs, rhs));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These classes make the respective operator a friend and define a constructor to create their <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> base part with the appropriate operator. They inherit the <code class="calibre23"><tt class="calibre23"><span class="calibre24">BinaryQuery</span></tt></code> definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code>, but each overrides the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code> operator, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">|</span></tt></code> operators return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> bound to a newly allocated object of the corresponding type. That <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> gets converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> as part of the return statement in each of these operators.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4110943"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.9.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.34:</strong> For the expression built in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4070749">638</a>):</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong> List the constructors executed in processing that expression.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong> List the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> that are made from <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; q</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong> List the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> made from <code class="calibre23"><tt class="calibre23"><span class="calibre24">q.eval()</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.35:</strong> Implement the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> classes, including a definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> but omitting the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.36:</strong> Put print statements in the constructors and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> members and run your code to check your answers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">(a)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">(b)</span></tt></code> from the first exercise.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.37:</strong> What changes would your classes need if the derived classes had members of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Query_base&gt;</span></tt></code> rather than of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.38:</strong> Are the following declarations legal? If not, why not? If so, explain what the declarations mean.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">BinaryQuery a = Query("fiery") &amp; Query("bird");<br class="calibre6"/>AndQuery b = Query("fiery") &amp; Query("bird");<br class="calibre6"/>OrQuery c = Query("fiery") &amp; Query("bird");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4114112" class="calibre37"><span class="calibre5">15.9.4. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">eval</span></span></tt></span></span></tt></code> Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions are the heart of our query system. Each of these functions calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on its operand(s) and then applies its own logic: The <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery eval</span></tt></code> operation returns the union of the results of its two operands; <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> returns the intersection. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> is more complicated: It must return the line numbers that are not in its operand&#8217;s set.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To support the processing in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions, we need to use the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> that defines the members we added in the exercises to &#167;<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">490</a>). We&#8217;ll assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> has <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members that will let us iterate through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> of line numbers that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> holds. We&#8217;ll also assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> has a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_file</span></tt></code> that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the underlying file on which the query was executed.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> classes use members defined for <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> in the exercises to &#167;<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">490</a>).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">OrQuery::eval</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">An <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> represents the union of the results for its two operands, which we obtain by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on each of its operands. Because these operands are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> objects, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> is a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query::eval</span></tt></code>, which in turn makes a virtual call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on the underlying <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> object. Each of these calls yields a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> representing the line numbers in which its operand appears. We&#8217;ll combine those line numbers into a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4118222"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns the union of its operands' result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>QueryResult<br class="calibre6"/>OrQuery::eval(const TextQuery&amp; text) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">virtual calls through the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the calls to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">eval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">return the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">QueryResult</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">for each operand</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto right = rhs.eval(text), left = lhs.eval(text);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the line numbers from the left-hand operand into the result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret_lines =<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;make_shared&lt;set&lt;line_no&gt;&gt;(left.begin(), left.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">insert lines from the right-hand operand</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ret_lines-&gt;insert(right.begin(), right.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return the new</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">QueryResult</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">representing the union of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return QueryResult(rep(), ret_lines, left.get_file());<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code> using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> constructor that takes a pair of iterators. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> return iterators into that object&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> of line numbers. So, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code> is created by copying the elements from <code class="calibre23"><tt class="calibre23"><span class="calibre24">left</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>. We next call <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code> to insert the elements from <code class="calibre23"><tt class="calibre23"><span class="calibre24">right</span></tt></code>. After this call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code> contains the line numbers that appear in either <code class="calibre23"><tt class="calibre23"><span class="calibre24">left</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">right</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> function ends by building and returning a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> representing the combined match. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> constructor (&#167;<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a>, p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">489</a>) takes three arguments: a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representing the query, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> of matching line numbers, and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that represents the input file. We call <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> to generate the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_file</span></tt></code> to obtain the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the file. Because both <code class="calibre23"><tt class="calibre23"><span class="calibre24">left</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">right</span></tt></code> refer to the same file, it doesn&#8217;t matter which of these we use for <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_file</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">AndQuery::eval</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> is similar to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery</span></tt></code> version, except that it calls a library algorithm to find the lines in common to both queries:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns the intersection of its operands' result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>QueryResult<br class="calibre6"/>AndQuery::eval(const TextQuery&amp; text) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">virtual calls through the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operands to get result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s for the operands</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto left = lhs.eval(text), right = rhs.eval(text);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to hold the intersection of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">left</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">right</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret_lines = make_shared&lt;set&lt;line_no&gt;&gt;();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">writes the intersection of two ranges to a destination iterator</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destination iterator in this call adds elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;set_intersection(left.begin(), left.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;right.begin(), right.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inserter(*ret_lines, ret_lines-&gt;begin()));<br class="calibre6"/>&#160;&#160;&#160;&#160;return QueryResult(rep(), ret_lines, left.get_file());<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4127069"/>Here we use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">set_intersection</span></tt></code> algorithm, which is described in <a href="189-a.2._a_brief_tour_of_the_algorithms.html#filepos5478694">Appendix A.2.8</a> (p. <a href="189-a.2._a_brief_tour_of_the_algorithms.html#filepos5478694">880</a>), to merge these two <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">set_intersection</span></tt></code> algorithm takes five iterators. It uses the first four to denote two input sequences (&#167;<a href="102-10.5._structure_of_generic_algorithms.html#filepos2684451">10.5.2</a>, p. <a href="102-10.5._structure_of_generic_algorithms.html#filepos2684451">413</a>). Its last argument denotes a destination. The algorithm writes the elements that appear in both input sequences into the destination.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In this call we pass an insert iterator (&#167;<a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>) as the destination. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">set_intersection</span></tt></code> writes to this iterator, the effect will be to insert a new element into <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery eval</span></tt></code> function, this one ends by building and returning a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> representing the combined match.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">NotQuery::eval</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">NotQuery</span></tt></code> finds each line of the text within which the operand is not found:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns the lines not in its operand's result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><br class="calibre6"/>QueryResult<br class="calibre6"/>NotQuery::eval(const TextQuery&amp; text) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">virtual call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">eval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Query</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operand</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto result = query.eval(text);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">start out with an empty result</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret_lines = make_shared&lt;set&lt;line_no&gt;&gt;();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we have to iterate through the lines on which our operand appears</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto beg = result.begin(), end = result.end();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">for each line in the input file, if that line is not in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">result</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">add that line number to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret_lines</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto sz = result.get_file()-&gt;size();<br class="calibre6"/>&#160;&#160;&#160;&#160;for (size_t n = 0; n != sz; ++n) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if we haven't processed all the lines in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">result</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">check whether this line is present</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (beg == end || *beg != n)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret_lines-&gt;insert(n);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if not in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">result</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, add this line</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (beg != end)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++beg; // <span><span class="calibre45"><span class="calibre16">otherwise get the next line number in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">result</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if there is one</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;return QueryResult(rep(), ret_lines, result.get_file());<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in the other <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions, we start by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> on this object&#8217;s operand. That call returns the <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> containing the line numbers on which the operand appears, but we want the line numbers on which the operand does not appear. That is, we want every line in the file that is not already in <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We generate that <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> by iterating through sequenital integers up to the size of the input file. We&#8217;ll put each number that is not in <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code> into <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code>. We position <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> to denote the first and one past the last elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code>. That object is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>, so when we iterate through it, we&#8217;ll obtain the line numbers in ascending order.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a/>The loop body checks whether the current number is in <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code>. If not, we add that number to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code>. If the number is in <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code>, we increment <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>, which is our iterator into <code class="calibre23"><tt class="calibre23"><span class="calibre24">result</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Once we&#8217;ve processed all the line numbers, we return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> containing <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret_lines</span></tt></code>, along with the results of running <code class="calibre23"><tt class="calibre23"><span class="calibre24">rep</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_file</span></tt></code> as in the previous <code class="calibre23"><tt class="calibre23"><span class="calibre24">eval</span></tt></code> functions.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.9.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.39:</strong> Implement the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> classes. Test your application by evaluating and printing a query such as the one in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4070749">638</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.40:</strong> In the <code class="calibre23"><tt class="calibre23"><span class="calibre24">OrQuery eval</span></tt></code> function what would happen if its <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> member returned an empty set? What if its <code class="calibre23"><tt class="calibre23"><span class="calibre24">lhs</span></tt></code> member did so? What if both <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">lhs</span></tt></code> returned empty sets?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.41:</strong> Reimplement your classes to use built-in pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s. Remember that your classes will no longer be able to use the synthesized copy-control members.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.42:</strong> Design and implement one of the following enhancements:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong> Print words only once per sentence rather than once per line.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong> Introduce a history system in which the user can refer to a previous query by number, possibly adding to it or combining it with another.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong> Allow the user to limit the results so that only matches in a given range of lines are displayed.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="149-15.8._containers_and_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="151-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
