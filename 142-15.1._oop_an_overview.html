<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.1. OOP: An Overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="141-chapter_15._objectoriented_programming.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="143-15.2._defining_base_and_derived_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3782427" class="calibre29"><span class="bold">15.1. OOP: An Overview</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The key ideas in <strong class="calibre5"><a id="filepos3782637" href="152-defined_terms.html#filepos4145072">object-oriented programming</a></strong> are data abstraction, inheritance, and dynamic binding. Using data abstraction, we can define classes that separate interface from implementation (<a href="072-chapter_7._classes.html#filepos1741323">Chapter 7</a>). Through inheritance, we can define classes that model the relationships among similar types. Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Inheritance</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Classes related by <strong class="calibre5"><a id="filepos3783270" href="152-defined_terms.html#filepos4144710">inheritance</a></strong> form a hierarchy. Typically there is a <strong class="calibre5"><a id="filepos3783382" href="152-defined_terms.html#filepos4141212">base class</a></strong> at the root of the hierarchy, from which the other classes inherit, directly or indirectly. These inheriting classes are known as <strong class="calibre5"><a id="filepos3783584" href="152-defined_terms.html#filepos4142216">derived classes</a></strong>. The base class defines those members that are common to the types in the hierarchy. Each derived class defines those members that are specific to the derived class itself.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To model our different kinds of pricing strategies, we&#8217;ll define a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>, which will be the base class of our hierarchy. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object will represent undiscounted books. From <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> we will inherit a second class, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>, to represent books that can be sold with a quantity discount.</p><div class="calibre22">&#160;</div>
<p class="calibre25">These classes will have the following two member functions:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn()</span></tt></code>, which will return the <small class="calibre48">ISBN</small>. This operation does not depend on the specifics of the inherited class(es); it will be defined only in class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price(size_t)</span></tt></code>, which will return the price for purchasing a specified number of copies of a book. This operation is type specific; both <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> will define their own version of this function.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">In C++, a base class distinguishes functions that are type dependent from those that it expects its derived classes to inherit without change. The base class defines as <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">virtual</span></span></tt></span></span></tt></code> those functions it expects its derived classes to define for themselves. Using this knowledge, we can start to write our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string isbn() const;<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual double net_price(std::size_t n) const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3786543"/>A derived class must specify the class(es) from which it intends to inherit. It does so in a <strong class="calibre5"><a id="filepos3786652" href="152-defined_terms.html#filepos4141491">class derivation list</a></strong>, which is a colon followed by a comma-separated list of base classes each of which may have an optional access specifier:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Bulk_quote : public Quote { // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inherits from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span><br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;double net_price(std::size_t) const override;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> in its derivation list, we can use objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>
<em class="calibre16">as if</em> they were <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself. A derived class may include the <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> keyword on these functions but is not required to do so. For reasons we&#8217;ll explain in &#167; <a href="144-15.3._virtual_functions.html#filepos3853256">15.3</a> (p. <a href="144-15.3._virtual_functions.html#filepos3853256">606</a>), the new standard lets a derived class explicitly note that it intends a member function to <strong class="calibre5"><a id="filepos3788507" href="152-defined_terms.html#filepos4145346">override</a></strong> a virtual that it inherits. It does so by specifying <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> after its parameter list.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Dynamic Binding</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Through <strong class="calibre5"><a id="filepos3788879" href="152-defined_terms.html#filepos4143355">dynamic binding</a></strong>, we can use the same code to process objects of either type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> interchangeably. For example, the following function prints the total price for purchasing the given number of copies of a given book:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">calculate and print the price for the given number of copies, applying any discounts</span></span></span><br class="calibre6"/>double print_total(ostream &amp;os,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Quote &amp;item, size_t n)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">depending on the type of the object bound to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls either</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote::net_price</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote::net_price</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double ret = item.net_price(n);<br class="calibre6"/>&#160;&#160;&#160;&#160;os &lt;&lt; "ISBN: " &lt;&lt; item.isbn() // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote::isbn</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " # sold: " &lt;&lt; n &lt;&lt; " total due: " &lt;&lt; ret &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;return ret;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This function is pretty simple&#8212;it prints the results of calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> on its parameter and returns the value calculated by the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Nevertheless, there are two interesting things about this function: For reasons we&#8217;ll explain in &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>), because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> parameter is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>, we can call this function on either a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object. And, for reasons we&#8217;ll explain in &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">15.2.1</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">594</a>), because <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> is a virtual function, and because <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> through a reference, the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> that is run will depend on the type of the object that we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">basic</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span><span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bulk</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote</span></span></tt></span><br class="calibre6"/>print_total(cout, basic, 20); //&#160;&#160;<span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">net_price</span></span></tt></span><br class="calibre6"/>print_total(cout, bulk, 20);&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">net_price</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first call passes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> version will be run. In the next call, the argument is a <a id="filepos3794740"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>, so the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> (which applies a discount) will be run. Because the decision as to which version to run depends on the type of the argument, that decision can&#8217;t be made until run time. Therefore, dynamic binding is sometimes known as <strong class="calibre5"><a id="filepos3795220" href="152-defined_terms.html#filepos4148889">run-time binding</a></strong>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In C++, dynamic binding happens when a virtual function is called through a reference (or a pointer) to a base class.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="141-chapter_15._objectoriented_programming.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="143-15.2._defining_base_and_derived_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
