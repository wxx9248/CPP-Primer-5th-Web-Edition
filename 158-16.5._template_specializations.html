<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>16.5. Template Specializations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="157-16.4._variadic_templates.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="159-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4508634" class="calibre29"><span class="bold">16.5. Template Specializations</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">It is not always possible to write a single template that is best suited for every possible template argument with which the template might be instantiated. In some cases, the general template definition is simply wrong for a type: The general definition might not compile or might do the wrong thing. At other times, we may be able to take advantage of some specific knowledge to write more efficient code than would be instantiated from the template. When we can&#8217;t (or don&#8217;t want to) use the template version, we can define a specialized version of the class or function template.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function is a good example of a function template for which the general definition is not appropriate for a particular type, namely, character pointers. We&#8217;d like <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> to compare character pointers by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcmp</span></tt></code> rather than by comparing the pointer values. Indeed, we have already overloaded the <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function to handle character string literals (&#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">654</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4510261"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">first version; can compare any two types</span></span></span><br class="calibre6"/>template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">second version to handle string literals</span></span></span><br class="calibre6"/>template&lt;size_t N, size_t M&gt;<br class="calibre6"/>int compare(const char (&amp;)[N], const char (&amp;)[M]);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> that has two nontype template parameters will be called only when we pass a string literal or an array. If we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> with character pointers, the first version of the template will be called:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char *p1 = "hi", *p2 = "mom";<br class="calibre6"/>compare(p1, p2);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls the first template</span></span></span><br class="calibre6"/>compare("hi", "mom"); // <span><span class="calibre45"><span class="calibre16">calls the template with two nontype parameters</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There is no way to convert a pointer to a reference to an array, so the second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> is not viable when we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> as arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To handle character pointers (as opposed to arrays), we can define a <strong class="calibre5"><a id="filepos4512451" href="160-defined_terms.html#filepos4556399">template specialization</a></strong> of the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>. A specialization is a separate definition of the template in which one or more template parameters are specified to have particular types.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Defining a Function Template Specialization</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we specialize a function template, we must supply arguments for every template parameter in the original template. To indicate that we are specializing a template, we use the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">template</span></tt></code> followed by an empty pair of angle brackets (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt; &gt;</span></tt></code>). The empty brackets indicate that arguments will be supplied for all the template parameters of the original template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">special version of compare to handle pointers to character arrays</span></span></span><br class="calibre6"/>template &lt;&gt;<br class="calibre6"/>int compare(const char* const &amp;p1, const char* const &amp;p2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return strcmp(p1, p2);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The hard part in understanding this specialization is the function parameter types. When we define a specialization, the function parameter type(s) must match the corresponding types in a previously declared template. Here we are specializing:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">in which the function parameters are references to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. As with type aliases, the interaction between template parameter types, pointers, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> can be surprising (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">68</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">We want to define a specialization of this function with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code>. Our function requires a reference to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of this type. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of a pointer type is a constant pointer as distinct from a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">63</a>). The type we need to use in our specialization is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char* const &amp;</span></tt></code>, which is a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos4516185"/>Function Overloading versus Template Specializations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we define a function template specialization, we are essentially taking over the job of the compiler. That is, we are supplying the definition to use for a specific instantiation of the original template. It is important to realize that a specialization is an instantiation; it is not an overloaded instance of the function name.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Specializations instantiate a template; they do not overload it. As a result, specializations do not affect function matching.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Whether we define a particular function as a specialization or as an independent, nontemplate function can impact function matching. For example, we have defined two versions of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function template, one that takes references to array parameters and the other that takes <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code>. The fact that we also have a specialization for character pointers has no impact on function matching. When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> on a string literal:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">compare("hi", "mom")</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">both function templates are viable and provide an equally good (i.e., exact) match to the call. However, the version with character array parameters is more specialized (&#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a>, p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">695</a>) and is chosen for this call.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Had we defined the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> that takes character pointers as a plain nontemplate function (rather than as a specialization of the template), this call would resolve differently. In this case, there would be three viable functions: the two templates and the nontemplate character-pointer version. All three are also equally good matches for this call. As we&#8217;ve seen, when a nontemplate provides an equally good match as a function template, the nontemplate is selected (&#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a>, p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">695</a>)</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Ordinary Scope Rules Apply to Specializations</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In order to specialize a template, a declaration for the original template must be in scope. Moreover, a declaration for a specialization must be in scope before any code uses that instantiation of the template.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">With ordinary classes and functions, missing declarations are (usually) easy to find&#8212;the compiler won&#8217;t be able to process our code. However, if a specialization declaration is missing, the compiler will usually generate code using the original template. Because the compiler can often instantiate the original template when a specialization is missing, errors in declaration order between a template and its specializations are easy to make but hard to find.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">It is an error for a program to use a specialization and an instantiation of the original template with the same set of template arguments. However, it is an error that the compiler is unlikely to detect.</p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Templates and their specializations should be declared in the same header file. Declarations for all the templates with a given name should appear first, followed by any specializations of those templates.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos4521059"/>Class Template Specializations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In addition to specializing function templates, we can also specialize class templates. As an example, we&#8217;ll define a specialization of the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> template that we can use to store <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects in an unordered container. By default, the unordered containers use <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;key_type&gt;</span></tt></code> (&#167; <a href="110-11.4._the_unordered_containers.html#filepos2872751">11.4</a>, p. <a href="110-11.4._the_unordered_containers.html#filepos2872751">444</a>) to organize their elements. To use this default with our own data type, we must define a specialization of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> template. A specialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> class must define</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; An overloaded call operator (&#167; <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>) that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> and takes an object of the container&#8217;s key type</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Two type members, <code class="calibre23"><tt class="calibre23"><span class="calibre24">result_type</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">argument_type</span></tt></code>, which are the return and argument types, respectively, of the call operator</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The default constructor and a copy-assignment operator (which can be implicitly defined (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">13.1.2</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">500</a>))</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The only complication in defining this <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> specialization is that when we specialize a template, we must do so in the same namespace in which the original template is defined. We&#8217;ll have more to say about namespaces in &#167; <a href="172-18.2._namespaces.html#filepos4928252">18.2</a> (p. <a href="172-18.2._namespaces.html#filepos4928252">785</a>). For now, what we need to know is that we can add members to a namespace. To do so, we must first open the namespace:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">open the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace so we can specialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std::hash</span></span></tt></span><br class="calibre6"/>namespace std {<br class="calibre6"/>}&#160;&#160;// <span><span class="calibre45"><span class="calibre16">close the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace; note: no semicolon after the close curly</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Any definitions that appear between the open and close curlies will be part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The following defines a specialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">open the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace so we can specialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std::hash</span></span></tt></span><br class="calibre6"/>namespace std {<br class="calibre6"/>template &lt;&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we're defining a specialization with</span></span></span><br class="calibre6"/>struct hash&lt;Sales_data&gt; // <span><span class="calibre45"><span class="calibre16">the template parameter of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the type used to hash an unordered container must define these types</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;typedef size_t result_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef Sales_data argument_type; // <span><span class="calibre45"><span class="calibre16">by default, this type needs</span></span></span> ==<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t operator()(const Sales_data&amp; s) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">our class uses synthesized copy control and default constructor</span></span></span><br class="calibre6"/>};<br class="calibre6"/>size_t<br class="calibre6"/>hash&lt;Sales_data&gt;::operator()(const Sales_data&amp; s) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return hash&lt;string&gt;()(s.bookNo) ^<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash&lt;unsigned&gt;()(s.units_sold) ^<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hash&lt;double&gt;()(s.revenue);<br class="calibre6"/>}<br class="calibre6"/>} // <span><span class="calibre45"><span class="calibre16">close the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">namespace; note: no semicolon after the close curly</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4527265"/>Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;Sales_data&gt;</span></tt></code> definition starts with <code class="calibre23"><tt class="calibre23"><span class="calibre24">template&lt;&gt;</span></tt></code>, which indicates that we are defining a fully specialized template. The template we&#8217;re specializing is named <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> and the specialized version is <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;Sales_data&gt;</span></tt></code>. The members of the class follow directly from the requirements for specializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any other class, we can define the members of a specialization inside the class or out of it, as we did here. The overloaded call operator must define a hashing function over the values of the given type. This function is required to return the same result every time it is called for a given value. A good hash function will (almost always) yield different results for objects that are not equal.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Here, we delegate the complexity of defining a good hash function to the library. The library defines specializations of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> class for the built-in types and for many of the library types. We use an (unnamed) <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;string&gt;</span></tt></code> object to generate a hash code for <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code>, an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;unsigned&gt;</span></tt></code> to generate a hash from <code class="calibre23"><tt class="calibre23"><span class="calibre24">units_sold</span></tt></code>, and an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;double&gt;</span></tt></code> to generate a hash from <code class="calibre23"><tt class="calibre23"><span class="calibre24">revenue</span></tt></code>. We exclusive <small class="calibre48">OR</small> (&#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a>, p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">154</a>) these results to form an overall hash code for the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is worth noting that we defined our <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> function to hash all three data members so that our <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> function will be compatible with our definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator==</span></tt></code> for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> (&#167; <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">14.3.1</a>, p. <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">561</a>). By default, the unordered containers use the specialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> that corresponds to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">key_type</span></tt></code> along with the equality operator on the key type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Assuming our specialization is in scope, it will be used automatically when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> as a key to one of these containers:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hash&lt;Sales_data&gt;</span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">and</span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data operator==</span></span></tt></span><span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 14.3.1 (p. 561)</span></span></span><br class="calibre6"/>unordered_multiset&lt;Sales_data&gt; SDset;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;Sales_data&gt;</span></tt></code> uses the private members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>, we must make this class a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;class T&gt; class std::hash;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">needed for the friend declaration</span></span></span><br class="calibre6"/>class Sales_data {<br class="calibre6"/>friend class std::hash&lt;Sales_data&gt;;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we say that the specific instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;Sales_data&gt;</span></tt></code> is a friend. Because that instantiation is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace, we must remember to that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> type is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace. Hence, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">friend</span></tt></code> declaration refers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::hash</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">To enable users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> to use the specialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code>, we should define this specialization in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> header.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Class-Template Partial Specializations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Differently from function templates, a class template specialization does not have to supply an argument for every template parameter. We can specify some, but not all, of the template parameters or some, but not all, aspects of the parameters. <a id="filepos4534257"/>A class template <strong class="calibre5"><a id="filepos4534290" href="160-defined_terms.html#filepos4553754">partial specialization</a></strong> is itself a template. Users must supply arguments for those template parameters that are not fixed by the specialization.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We can partially specialize only a class template. We cannot partially specialize a function template.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">In &#167; <a href="155-16.2._template_argument_deduction.html#filepos4354202">16.2.3</a> (p. <a href="155-16.2._template_argument_deduction.html#filepos4354202">684</a>) we introduced the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> type. That template works through a series of specializations:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">original, most general template</span></span></span><br class="calibre6"/>template &lt;class T&gt; struct remove_reference {<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef T type;<br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">partial specializations that will be used for lvalue and rvalue references</span></span></span><br class="calibre6"/>template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">lvalue references</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{ typedef T type; };<br class="calibre6"/>template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; // <span><span class="calibre45"><span class="calibre16">rvalue references</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{ typedef T type; };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first template defines the most general version. It can be instantiated with any type; it uses its template argument as the type for its member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code>. The next two classes are partial specializations of this original template.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because a partial specialization is a template, we start, as usual, by defining the template parameters. Like any other specialization, a partial specialization has the same name as the template it specializes. The specialization&#8217;s template parameter list includes an entry for each template parameter whose type is not completely fixed by this partial specialization. After the class name, we specify arguments for the template parameters we are specializing. These arguments are listed inside angle brackets following the template name. The arguments correspond positionally to the parameters in the original template.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The template parameter list of a partial specialization is a subset of, or a specialization of, the parameter list of the original template. In this case, the specializations have the same number of parameters as the original template. However, the parameter&#8217;s type in the specializations differ from the original template. The specializations will be used for lvalue and rvalue reference types, respectively:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">decltype(42)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, uses the original template</span></span></span><br class="calibre6"/>remove_reference&lt;decltype(42)&gt;::type a;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">decltype(i)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, uses first (T&amp;) partial specialization</span></span></span><br class="calibre6"/>remove_reference&lt;decltype(i)&gt;::type b;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">decltype(std::move(i))</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;&amp;</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, uses second (i.e.,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T&amp;&amp;</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">partial specialization</span></span></span><br class="calibre6"/>remove_reference&lt;decltype(std::move(i))&gt;::type c;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">All three variables, <code class="calibre23"><tt class="calibre23"><span class="calibre24">a, b</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>, have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Specializing Members but Not the Class</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Rather than specializing the whole template, we can specialize just specific member function(s). For example, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> is a template class with a member <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code>, we can <a id="filepos4540179"/>specialize just that member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; struct Foo {<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo(const T &amp;t = T()): mem(t) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;void Bar() { /* <span><span class="calibre45"><span class="calibre16">...</span></span></span> */ }<br class="calibre6"/>&#160;&#160;&#160;&#160;T mem;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>};<br class="calibre6"/>template&lt;&gt;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we're specializing a template</span></span></span><br class="calibre6"/>void Foo&lt;int&gt;::Bar() // <span><span class="calibre45"><span class="calibre16">we're specializing the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bar</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;</span></span></tt></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do whatever specialized processing that applies to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we are specializing just one member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;int&gt;</span></tt></code> class. The other members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;int&gt;</span></tt></code> will be supplied by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Foo&lt;string&gt; fs;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;string&gt;::Foo()</span></span></tt></span><br class="calibre6"/>fs.Bar();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;string&gt;::Bar()</span></span></tt></span><br class="calibre6"/>Foo&lt;int&gt; fi;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::Foo()</span></span></tt></span><br class="calibre6"/>fi.Bar();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses our specialization of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo&lt;int&gt;::Bar(</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> with any type other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, members are instantiated as usual. When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, members other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> are instantiated as usual. If we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bar</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo&lt;int&gt;</span></tt></code>, then we get our specialized definition.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.62:</strong> Define your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;Sales_data&gt;</span></tt></code> and define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_multiset</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects. Put several transactions into the container and print its contents.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.63:</strong> Define a function template to count the number of occurrences of a given value in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Test your program by passing it a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>s, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.64:</strong> Write a specialized version of the template from the previous exercise to handle <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;const char*</span></tt></code>&gt; and a program that uses this specialization.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.65:</strong> In &#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">698</a>) we defined overloaded two versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> one had a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code> and the other a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code> parameter. Rewrite these functions as specializations.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.66:</strong> What are the advantages and disadvantages of overloading these <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> functions as compared to defining specializations?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.67:</strong> Would defining these specializations affect function matching for <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code>? If so, how? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="157-16.4._variadic_templates.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="159-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
