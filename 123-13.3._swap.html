<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>13.3. Swap</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="122-13.2._copy_control_and_resource_management.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="124-13.4._a_copycontrol_example.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3315883" class="calibre29"><span class="bold">13.3. Swap</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">In addition to defining the copy-control members, classes that manage resources often also define a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> (&#167; <a href="090-9.2._container_library_overview.html#filepos2239281">9.2.5</a>, p. <a href="090-9.2._container_library_overview.html#filepos2239281">339</a>). Defining <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is particularly important for classes that we plan to use with algorithms that reorder elements (&#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">383</a>). Such algorithms call <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> whenever they need to exchange two elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If a class defines its own <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, then the algorithm uses that class-specific version. Otherwise, it uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function defined by the library. Although, as usual, we don&#8217;t know how <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is implemented, conceptually it&#8217;s easy to see that swapping two objects involves a copy and two assignments. For example, code to swap two objects of our valuelike <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class (&#167; <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">13.2.1</a>, p. <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">511</a>) might look something like:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr temp = v1; // <span><span class="calibre45"><span class="calibre16">make a temporary copy of the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><br class="calibre6"/>v1 = v2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><br class="calibre6"/>v2 = temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign the saved value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3318720"/>This code copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that was originally in <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> twice&#8212;once when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> copy constructor copies <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> into <code class="calibre23"><tt class="calibre23"><span class="calibre24">temp</span></tt></code> and again when the assignment operator assigns <code class="calibre23"><tt class="calibre23"><span class="calibre24">temp</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>. It also copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that was originally in <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> when it assigns <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code>. As we&#8217;ve seen, copying a valuelike <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> allocates a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In principle, none of this memory allocation is necessary. Rather than allocating new copies of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we&#8217;d like <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> to swap the pointers. That is, we&#8217;d like swapping two <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>s to execute as:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *temp = v1.ps; // <span><span class="calibre45"><span class="calibre16">make a temporary copy of the pointer in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1.ps</span></span></tt></span><br class="calibre6"/>v1.ps = v2.ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign the pointer in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2.ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1.ps</span></span></tt></span><br class="calibre6"/>v2.ps = temp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign the saved pointer in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1.ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2.ps</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Writing Our Own <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code> Function</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We can override the default behavior of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> by defining a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> that operates on our class. The typical implementation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class HasPtr {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend void swap(HasPtr&amp;, HasPtr&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in &#167; 13.2.1 (p. 511)</span></span></span><br class="calibre6"/>};<br class="calibre6"/>inline<br class="calibre6"/>void swap(HasPtr &amp;lhs, HasPtr &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;using std::swap;<br class="calibre6"/>&#160;&#160;&#160;&#160;swap(lhs.ps, rhs.ps); // <span><span class="calibre45"><span class="calibre16">swap the pointers, not the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">data</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;swap(lhs.i, rhs.i);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">swap the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by declaring <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">friend</span></tt></code> to give it access to <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>&#8217;s (<code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>) data members. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> exists to optimize our code, we&#8217;ve defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> function (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">238</a>). The body of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> on each of the data members of the given object. In this case, we first <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> the pointers and then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> members of the objects bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">lhs</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Unlike the copy-control members, <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is never necessary. However, defining <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> can be an important optimization for classes that allocate resources.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code> Functions Should Call <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code>, Not <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::swap</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">There is one important subtlety in this code: Although it doesn&#8217;t matter in this particular case, it is essential that <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> functions call <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> and not <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::swap</span></tt></code>. In the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> function, the data members have built-in types. There is no type-specific version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> for the built-in types. In this case, these calls will invoke the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::swap</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, if a class has a member that has its own type-specific <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::swap</span></tt></code> would be a mistake. For example, assume we had another class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> that has a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">h</span></tt></code>, which has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>. If we did <a id="filepos3327477"/>not write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, then the library version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> would be used. As we&#8217;ve already seen, the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> makes unnecessary copies of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s managed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can avoid these copies by writing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code>. However, if we wrote the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> as:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void swap(Foo &amp;lhs, Foo &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">WRONG: this function uses the library version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">swap</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, not the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::swap(lhs.h, rhs.h);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">swap other members of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">this code would compile and execute. However, there would be no performance difference between this code and simply using the default version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. The problem is that we&#8217;ve explicitly requested the library version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. However, we don&#8217;t want the version in <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>; we want the one defined for <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> objects.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The right way to write this <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function is:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void swap(Foo &amp;lhs, Foo &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;using std::swap;<br class="calibre6"/>&#160;&#160;&#160;&#160;swap(lhs.h, rhs.h); // <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">swap</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">swap other members of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Each call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> must be unqualified. That is, each call should be to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::swap</span></tt></code>. For reasons we&#8217;ll explain in &#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">697</a>), if there is a type-specific version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, that version will be a better match than the one defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>. As a result, if there is a type-specific version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> will match that type-specific version. If there is no type-specific version, then&#8212;assuming there is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> in scope&#8212;calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> will use the version in <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Very careful readers may wonder why the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> does not hide the declarations for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> (&#167; <a href="066-6.4._overloaded_functions.html#filepos1621309">6.4.1</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1621309">234</a>). We&#8217;ll explain the reasons for why this code works in &#167; <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>).</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code> in Assignment Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Classes that define <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> often use <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> to define their assignment operator. These operators use a technique known as <strong class="calibre5"><a id="filepos3333773" href="128-defined_terms.html#filepos3534923">copy and swap</a></strong>. This technique <em class="calibre16">swaps</em> the left-hand operand with a <em class="calibre16">copy</em> of the right-hand operand:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">note</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is passed by value, which means the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">copies the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the right-hand operand into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>HasPtr&amp; HasPtr::operator=(HasPtr rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">swap the contents of the left-hand operand with the local variable</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;swap(*this, rhs); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now points to the memory this object had used</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is destroyed, which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s the pointer in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3335986"/>In this version of the assignment operator, the parameter is not a reference. Instead, we pass the right-hand operand by value. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> is a copy of the right-hand operand. Copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> allocates a new copy of that object&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the body of the assignment operator, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, which swaps the data members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> with those in <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code>. This call puts the pointer that had been in the left-hand operand into <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code>, and puts the pointer that was in <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> into <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code>. Thus, after the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, the pointer member in <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> points to the newly allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that is a copy of the right-hand operand.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When the assignment operator finishes, <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> is destroyed and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> destructor is run. That destructor <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>s the memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> now points, thus freeing the memory to which the left-hand operand had pointed.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The interesting thing about this technique is that it automatically handles self assignment and is automatically exception safe. By copying the right-hand operand before changing the left-hand operand, it handles self assignment in the same was as we did in our original assignment operator (&#167; <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">13.2.1</a>, p. <a href="122-13.2._copy_control_and_resource_management.html#filepos3285596">512</a>). It manages exception safety in the same way as the original definition as well. The only code that might throw is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression inside the copy constructor. If an exception occurs, it will happen before we have changed the left-hand operand.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Assignment operators that use copy and swap are automatically exception safe and correctly handle self-assignment.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.29:</strong> Explain why the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap(HasPtr&amp;, HasPtr&amp;)</span></tt></code> do not cause a recursion loop.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.30:</strong> Write and test a <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function for your valuelike version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>. Give your <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> a print statement that notes when it is executed.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.31:</strong> Give your class a <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator and define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>s. Give that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> some elements and then <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Note when <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is called.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.32:</strong> Would the pointerlike version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> benefit from defining a <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> function? If so, what is the benefit? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="122-13.2._copy_control_and_resource_management.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="124-13.4._a_copycontrol_example.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
