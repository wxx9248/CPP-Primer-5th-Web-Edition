<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.1. Controlling Memory Allocation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="176-chapter_19._specialized_tools_and_techniques.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="178-19.2._runtime_type_identification.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5124326" class="calibre29"><span class="bold">19.1. Controlling Memory Allocation</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Some applications have specialized memory allocation needs that cannot be met by the standard memory management facilities. Such applications need to take over the details of how memory is allocated, for example, by arranging for <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to put objects into particular kinds of memory. To do so, they can overload the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> operators to control memory allocation.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5125048" class="calibre37"><span class="calibre5">19.1.1. Overloading <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">delete</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Although we say that we can &#8220;overload <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>,&#8221; overloading these operators is quite different from the way we overload other operators. In order to understand how we overload these operators, we first need to know a bit more about how <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expressions work.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">new</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">expressions</span></span></span><br class="calibre6"/>string *sp = new string("a value"); // <span><span class="calibre45"><span class="calibre16">allocate and initialize a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>string *arr = new string[10];&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate ten default initialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">three steps actually happen. First, the expression calls a library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5127298" href="186-defined_terms.html#filepos5405028">operator new</a></span></span></tt></span></span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">operator new[]</span></span></tt></span></span></tt></code>). This function allocates raw, untyped memory large enough to hold an object (or an array of objects) of the specified type. Next, the compiler runs the appropriate constructor to construct the object(s) from the specified initializers. Finally, a pointer to the newly allocated and constructed object is returned.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression to delete a dynamically allocated object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">delete sp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroy</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*sp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and free the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>delete [] arr;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroy the elements in the array and free the memory</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">two steps happen. First, the appropriate destructor is run on the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> points or on the elements in the array to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> points. Next, the compiler frees the memory by calling a library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5129440" href="186-defined_terms.html#filepos5404474">operator delete</a></span></span></tt></span></span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">operator delete[]</span></span></tt></span></span></tt></code>, respectively.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Applications that want to take control of memory allocation define their own versions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions. Even though the library contains definitions for these functions, we can define our own versions of them and the compiler won&#8217;t complain about duplicate definitions. Instead, the compiler will use our version in place of the one defined by the library.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos5130378"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we define the global <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions, we take over responsibility for all dynamic memory allocation. These functions <em class="calibre16">must</em> be correct: They form a vital part of all processing in the program.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Applications can define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions in the global scope and/or as member functions. When the compiler sees a <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression, it looks for the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator</span></tt></code> function to call. If the object being allocated (deallocated) has class type, the compiler first looks in the scope of the class, including any base classes. If the class has a member <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code>, that function is used by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression. Otherwise, the compiler looks for a matching function in the global scope. If the compiler finds a user-defined version, it uses that function to execute the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression. Otherwise, the standard library version is used.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can use the scope operator to force a <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression to bypass a class-specific function and use the one from the global scope. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">::new</span></tt></code> will look only in the global scope for a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> function. Similarly for <code class="calibre23"><tt class="calibre23"><span class="calibre24">::delete</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">operator new</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">operator delete</span></span></tt></span></span></tt></code> Interface</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The library defines eight overloaded versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> functions. The first four support the versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> that can throw a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code> exception. The next four support nonthrowing versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">these versions might throw an exception</span></span></span><br class="calibre6"/>void *operator new(size_t);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate an object</span></span></span><br class="calibre6"/>void *operator new[](size_t);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate an array</span></span></span><br class="calibre6"/>void *operator delete(void*) noexcept;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free an object</span></span></span><br class="calibre6"/>void *operator delete[](void*) noexcept; // <span><span class="calibre45"><span class="calibre16">free an array</span></span></span><br class="calibre6"/><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">versions that promise not to throw; see &#167; 12.1.2 (p. 460)</span></span></span><br class="calibre6"/>void *operator new(size_t, nothrow_t&amp;) noexcept;<br class="calibre6"/>void *operator new[](size_t, nothrow_t&amp;) noexcept;<br class="calibre6"/>void *operator delete(void*, nothrow_t&amp;) noexcept;<br class="calibre6"/>void *operator delete[](void*, nothrow_t&amp;) noexcept;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">nothrow_t</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">struct</span></tt></code> defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> header. This type has no members. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> header also defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">nothrow</span></tt></code>, which users can pass to signal they want the nonthrowing version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>). Like destructors, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> must not throw an exception (&#167; <a href="171-18.1._exception_handling.html#filepos4856427">18.1.1</a>, p. <a href="171-18.1._exception_handling.html#filepos4856427">774</a>). When we overload these operators, we must specify that they will not throw, which we do through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> exception specifier (&#167; <a href="171-18.1._exception_handling.html#filepos4896504">18.1.4</a>, p. <a href="171-18.1._exception_handling.html#filepos4896504">779</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">An application can define its own version of any of these functions. If it does so, it must define these functions in the global scope or as members of a class. When defined as members of a class, these operator functions are implicitly static (&#167; <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">302</a>). There is no need to declare them <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> explicitly, although it is legal to do so. The member <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> functions must be static because they are used either before the object is constructed <code class="calibre23"><tt class="calibre23"><span class="calibre24">(operator new)</span></tt></code> or after it has been <a id="filepos5137632"/>destroyed <code class="calibre23"><tt class="calibre23"><span class="calibre24">(operator delete)</span></tt></code>. There are, therefore, no member data for these functions to manipulate.</p><div class="calibre22">&#160;</div>
<p class="calibre25">An <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new[]</span></tt></code> function must have a return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> and its first parameter must have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code>. That parameter may not have a default argument. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> function is used when we allocate an object; <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new[]</span></tt></code> is called when we allocate an array. When the compiler calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code>, it initializes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> parameter with the number of bytes required to hold an object of the specified type; when it calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new[]</span></tt></code>, it passes the number of bytes required to store an array of the given number of elements.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we define our own <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> function, we can define additional parameters. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression that uses such functions must use the placement form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>) to pass arguments to these additional parameters. Although generally we may define our version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> to have whatever parameters are needed, we may not define a function with the following form:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void *operator new(size_t, void*); // <span><span class="calibre45"><span class="calibre16">this version may not be redefined</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This specific form is reserved for use by the library and may not be redefined.</p><div class="calibre15">&#160;</div>
<p class="calibre25">An <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete[]</span></tt></code> function must have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> return type and a first parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code>. Executing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression calls the appropriate <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator</span></tt></code> function and initializes its <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> parameter with a pointer to the memory to free.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete[]</span></tt></code> is defined as a class member, the function may have a second parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code>. If present, the additional parameter is initialized with the size in bytes of the object addressed by the first parameter. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> parameter is used when we delete objects that are part of an inheritance hierarchy. If the base class has a virtual destructor (&#167; <a href="148-15.7._constructors_and_copy_control.html#filepos3974566">15.7.1</a>, p. <a href="148-15.7._constructors_and_copy_control.html#filepos3974566">622</a>), then the size passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> will vary depending on the dynamic type of the object to which the deleted pointer points. Moreover, the version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> function that is run will be the one from the dynamic type of the object.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Terminology: <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> Expression versus <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> Function</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The library functions <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> are misleadingly named. Unlike other <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator</span></tt></code> functions, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator=</span></tt></code>, these functions do not overload the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expressions. In fact, we cannot redefine the behavior of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expressions.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression always executes by calling an <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> function to obtain memory and then constructing an object in that memory. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression always executes by destroying an object and then calling an <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> function to free the memory used by the object.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">By providing our own definitions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions, we can change how memory is allocated. However, we cannot change this basic meaning of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> operators.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5144765"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">malloc</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5145004" href="186-defined_terms.html#filepos5401047">free</a></span></span></tt></span></span></tt></code> Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If you define your own global <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code>, those functions must allocate and deallocate memory somehow. Even if you define these functions in order to use a specialized memory allocator, it can still be useful for testing purposes to be able to allocate memory similarly to how the implementation normally does so.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To this end, we can use functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5145826" href="186-defined_terms.html#filepos5402699">malloc</a></span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">free</span></span></tt></span></span></tt></code> that C++ inherits from C. These functions, are defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstdlib</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">malloc</span></tt></code> function takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> that says how many bytes to allocate. It returns a pointer to the memory that it allocated, or 0 if it was unable to allocate the memory. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> function takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> that is a copy of a pointer that was returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">malloc</span></tt></code> and returns the associated memory to the system. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">free(0)</span></tt></code> has no effect.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A simple way to write <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> is as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void *operator new(size_t size) {<br class="calibre6"/>&#160;&#160;&#160;&#160;if (void *mem = malloc(size))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return mem;<br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw bad_alloc();<br class="calibre6"/>}<br class="calibre6"/>void operator delete(void *mem) noexcept { free(mem); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">and similarly for the other versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.1:</strong> Write your own <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new(size_t)</span></tt></code> function using <code class="calibre23"><tt class="calibre23"><span class="calibre24">malloc</span></tt></code> and use <code class="calibre23"><tt class="calibre23"><span class="calibre24">free</span></tt></code> to write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete(void*)</span></tt></code> function.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.2:</strong> By default, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> class uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> to obtain storage and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> to free it. Recompile and rerun your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> programs (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>) using your versions of the functions from the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos5149502" class="calibre37"><span class="calibre5">19.1.2. Placement <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> Expressions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Although the <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions are intended to be used by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expressions, they are ordinary functions in the library. As a result, ordinary code can call these functions directly.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In earlier versions of the language&#8212;before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> (&#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">481</a>) class was part of the library&#8212;applications that wanted to separate allocation from initialization did so by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code>. These functions behave analogously to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code> members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code>. Like those members, <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator delete</span></tt></code> functions allocate and deallocate memory but do not construct or destroy objects.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5151315"/>Differently from an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code>, there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> function we can call to construct objects in memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code>. Instead, we use the <strong class="calibre5">placement</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>) to construct an object. As we&#8217;ve seen, this form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> provides extra information to the allocation function. We can use placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to pass an address, in which case the placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression has the form</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">new (<span><span class="calibre45"><span class="calibre16">place_address</span></span></span>) <span><span class="calibre45"><span class="calibre16">type</span></span></span><br class="calibre6"/>new (<span><span class="calibre45"><span class="calibre16">place_address</span></span></span>) <span><span class="calibre45"><span class="calibre16">type</span></span></span> (<span><span class="calibre45"><span class="calibre16">initializers)</span></span></span><br class="calibre6"/>new (<span><span class="calibre45"><span class="calibre16">place_address</span></span></span>) <span><span class="calibre45"><span class="calibre16">type</span></span></span> [<span><span class="calibre45"><span class="calibre16">size</span></span></span>]<br class="calibre6"/>new (<span><span class="calibre45"><span class="calibre16">place_address</span></span></span>) <span><span class="calibre45"><span class="calibre16">type</span></span></span> [<span><span class="calibre45"><span class="calibre16">size</span></span></span>] { <span><span class="calibre45"><span class="calibre16">braced initializer list</span></span></span> }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">place_address</em> must be a pointer and the <em class="calibre16">initializers</em> provide (a possibly empty) comma-separated list of initializers to use to construct the newly allocated object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When called with an address and no other arguments, placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new(size_t, void*)</span></tt></code> to &#8220;allocate&#8221; its memory. This is the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code> that we are not allowed to redefine (&#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">19.1.1</a>, p. <a href="177-19.1._controlling_memory_allocation.html#filepos5125048">822</a>). This function does <em class="calibre16">not</em> allocate any memory; it simply returns its pointer argument. The overall <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression then finishes its work by initializing an object at the given address. In effect, placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> allows us to construct an object at a specific, preallocated memory address.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When passed a single argument that is a pointer, a placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression constructs an object but does not allocate memory.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Although in many ways using placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is analogous to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> member of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code>, there is one important difference. The pointer that we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> must point to space allocated by the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> object. The pointer that we pass to placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> need not point to memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator new</span></tt></code>. Indeed, as we&#8217;ll see in &#167; <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">19.6</a> (p. <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">851</a>), the pointer passed to a placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression need not even refer to dynamic memory.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Explicit Destructor Invocation</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is analogous to using <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code>, an explicit call to a destructor is analogous to calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code>. We call a destructor the same way we call any other member function on an object or through a pointer or reference to an object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *sp = new string("a value"); // <span><span class="calibre45"><span class="calibre16">allocate and initialize a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>sp-&gt;~string();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we invoke a destructor directly. The arrow operator dereferences the pointer <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> to obtain the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> points. We then call the destructor, which is the name of the type preceded by a tilde (<code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code>, calling a destructor cleans up the given object but does not free the space in which that object resides. We can reuse the space if desired.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Calling a destructor destroys an object but does not free the memory.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="176-chapter_19._specialized_tools_and_techniques.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="178-19.2._runtime_type_identification.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
