<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>10.2. A First Look at the Algorithms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="098-10.1._overview.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="100-10.3._customizing_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2472467" class="calibre29"><span class="bold">10.2. A First Look at the Algorithms</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The library provides more than 100 algorithms. Fortunately, like the containers, the algorithms have a consistent architecture. Understanding this architecture makes learning and using the algorithms easier than memorizing all 100+ of them. In this chapter, we&#8217;ll illustrate how to use the algorithms, and describe the unifying principles that characterize them. <a href="187-appendix_a._the_library.html#filepos5411866">Appendix A</a> lists all the algorithms classified by how they operate.</p><div class="calibre15">&#160;</div>
<p class="calibre25">With only a few exceptions, the algorithms operate over a range of elements. We&#8217;ll refer to this range as the &#8220;input range.&#8221; The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange the order of the elements.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2473899" class="calibre37"><span class="calibre5"><a id="filepos2473932"/>10.2.1. Read-Only Algorithms</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A number of the algorithms read, but never write to, the elements in their input range. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> function is one such algorithm, as is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> function we used in the exercises for &#167; <a href="098-10.1._overview.html#filepos2458324">10.1</a> (p. <a href="098-10.1._overview.html#filepos2458324">378</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Another read-only algorithm is <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code>, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">numeric</span></tt></code> header. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> function takes three arguments. The first two specify a range of elements to sum. The third is an initial value for the sum. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> is a sequence of integers, the following</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">sum the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">starting the summation with the value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>int sum = accumulate(vec.cbegin(), vec.cend(), 0);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">sets <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> equal to the sum of the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code>, using <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> as the starting point for the summation.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The type of the third argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> determines which addition operator is used and is the type that <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> returns.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms and Element Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> uses its third argument as the starting point for the summation has an important implication: It must be possible to add the element type to the type of the sum. That is, the elements in the sequence must match or be convertible to the type of the third argument. In this example, the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> might be <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, or they might be <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code>, or any other type that can be added to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As another example, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator, we can concatenate the elements of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string sum = accumulate(v.cbegin(), v.cend(), string(""));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call concatenates each element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">v</span></tt></code> onto a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that starts out as the empty string. Note that we explicitly create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> as the third parameter. Passing the empty string as a string literal would be a compile-time error:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: no</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">+</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const char*</span></span></tt></span><br class="calibre6"/>string sum = accumulate(v.cbegin(), v.cend(), "");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Had we passed a string literal, the type of the object used to hold the sum would be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code>. That type determines which <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator is used. Because there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator for type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code>, this call will not compile.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily it is best to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">cbegin()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cend()</span></tt></code> (&#167; <a href="090-9.2._container_library_overview.html#filepos2212546">9.2.3</a>, p. <a href="090-9.2._container_library_overview.html#filepos2212546">334</a>) with algorithms that read, but do not write, the elements. However, if you plan to use the iterator returned by the algorithm to change an element&#8217;s value, then you need to pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin()</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2481142"/>Algorithms That Operate on Two Sequences</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Another read-only algorithm is <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code>, which lets us determine whether two sequences hold the same values. It compares each element from the first sequence to the corresponding element in the second. It returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the corresponding elements are equal, <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> otherwise. The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">roster2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should have at least as many elements as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">roster1</span></span></tt></span><br class="calibre6"/>equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> operates in terms of iterators, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> to compare elements in containers of different types. Moreover, the element types also need not be the same so long as we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> to compare the element types. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">roster1</span></tt></code> could be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">roster2</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;const char*&gt;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> makes one critically important assumption: It assumes that the second sequence is at least as big as the first. This algorithm potentially looks at every element in the first sequence. It assumes that there is a corresponding element for each of those elements in the second sequence.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Algorithms that take a single iterator denoting a second sequence <em class="calibre16">assume</em> that the second sequence is at least as large at the first.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.3:</strong> Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate</span></tt></code> to sum the elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.4:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">v</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;double&gt;</span></tt></code>, what, if anything, is wrong with calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">accumulate(v.cbegin(), v.cend(), 0)?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.5:</strong> In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> on rosters, what would happen if both rosters held C-style strings, rather than library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2485637" class="calibre37"><span class="calibre5">10.2.2. Algorithms That Write Container Elements</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Some algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container operations, so they have no way themselves to change the size of a container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Some algorithms write to elements in the input range itself. These algorithms are not inherently dangerous because they write only as many elements as are in the specified range.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As one example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill</span></tt></code> algorithm takes a pair of iterators that denote a range and a third argument that is a value. <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill</span></tt></code> assigns the given value to each element in the input sequence:</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos2486948"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Iterator Arguments</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some algorithms read elements from two sequences. The elements that constitute these sequences can be stored in different kinds of containers. For example, the first sequence might be stored in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and the second might be in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, a built-in array, or some other sequence. Moreover, the element types in the two sequences are not required to match exactly. What is required is that we be able to compare elements from the two sequences. For example, in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> algorithm, the element types need not be identical, but we do have to be able to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> to compare elements from the two sequences.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Algorithms that operate on two sequences differ as to how we pass the second sequence. Some algorithms, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code>, take three iterators: The first two denote the range of the first sequence, and the third iterator denotes the first element in the second sequence. Others take four iterators: The first two denote the range of elements in the first sequence, and the second two denote the range for the second sequence.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Algorithms that use a single iterator to denote the second sequence <em class="calibre16">assume</em> that the second sequence is at least as large as the first. It is up to us to ensure that the algorithm will not attempt to access a nonexistent element in the second sequence. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> algorithm potentially compares every element from its first sequence to an element in the second. If the second sequence is a subset of the first, then our program has a serious error&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> will attempt to access elements beyond the end of the second sequence.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">fill(vec.begin(), vec.end(), 0);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reset each element to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">set a subsequence of the container to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">10</span></span></tt></span><br class="calibre6"/>fill(vec.begin(), vec.begin() + vec.size()/2, 10);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill</span></tt></code> writes to its given input sequence, so long as we pass a valid input sequence, the writes will be safe.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms Do Not Check Write Operations</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Some algorithms take an iterator that denotes a separate destination. These algorithms assign new values to the elements of a sequence starting at the element denoted by the destination iterator. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> function takes a single iterator, a count, and a value. It assigns the given value to the specified number of elements starting at the element denoted to by the iterator. We might use <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> to assign a new value to the elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">giving it various values</span></span></span><br class="calibre6"/>fill_n(vec.begin(), vec.size(), 0); // <span><span class="calibre45"><span class="calibre16">reset all the elements of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> function assumes that it is safe to write the specified number of elements. That is, for a call of the form</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">fill_n(dest, n, val)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> assumes that <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> refers to an element and that there are at least <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> elements in the sequence starting from <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2493305"/>It is a fairly common beginner mistake to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> (or similar algorithms that write to elements) on a container that has no elements:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">disaster: attempts to write to ten (nonexistent) elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span><br class="calibre6"/>fill_n(vec.begin(), 10, 0);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> is a disaster. We specified that ten elements should be written, but there are no such elements&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> is empty. The result is undefined.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Algorithms that write to a destination iterator <em class="calibre16">assume</em> the destination is large enough to hold the number of elements being written.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Introducing <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">back_inserter</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One way to ensure that an algorithm has enough elements to hold the output is to use an <strong class="calibre5"><a id="filepos2495420" href="105-defined_terms.html#filepos2713270">insert iterator</a></strong>. An insert iterator is an iterator that <em class="calibre16">adds</em> elements to a container. Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We&#8217;ll have more to say about insert iterators in &#167; <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>). However, in order to illustrate how to use algorithms that write to a container, we will use <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2496180" href="105-defined_terms.html#filepos2709723">back_inserter</a></span></span></tt></span></span></tt></code>, which is a function defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> header.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><code class="calibre23"><tt class="calibre23"><span class="calibre24">back_inserter</span></tt></code> takes a reference to a container and returns an insert iterator bound to that container. When we assign through that iterator, the assignment calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> to add an element with the given value to the container:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>auto it = back_inserter(vec); // <span><span class="calibre45"><span class="calibre16">assigning through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">adds elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span><br class="calibre6"/>*it = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now has one element with value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We frequently use <code class="calibre23"><tt class="calibre23"><span class="calibre24">back_inserter</span></tt></code> to create an iterator to use as the destination of an algorithm. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">back_inserter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">creates an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">insert</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">iterator that adds elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span><br class="calibre6"/>fill_n(back_inserter(vec), 10, 0);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">appends ten elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">On each iteration, <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> assigns to an element in the given sequence. Because we passed an iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">back_inserter</span></tt></code>, each assignment will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code>. As a result, this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> adds ten elements to the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code>, each of which has the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Copy Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> algorithm is another example of an algorithm that writes to the elements of an output sequence denoted by a destination iterator. This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. This algorithm copies elements from its input range into elements in the destination. It is essential that the destination passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> be at least as large as the input range.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2500853"/>As one example, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> to copy one built-in array to another:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int a1[] = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>int a2[sizeof(a1)/sizeof(*a1)];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has the same size as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points just past the last element copied into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a2</span></span></tt></span><br class="calibre6"/>auto ret = copy(begin(a1), end(a1), a2);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we define an array named <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code> and use <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof</span></tt></code> to ensure that <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code> has as many elements as the array <code class="calibre23"><tt class="calibre23"><span class="calibre24">a1</span></tt></code> (&#167; <a href="047-4.9._the_sizeof_operator.html#filepos1142429">4.9</a>, p. <a href="047-4.9._the_sizeof_operator.html#filepos1142429">157</a>). We then call <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> to copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">a1</span></tt></code> into <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code>. After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code>, the elements in both arrays have the same values.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> is the (incremented) value of its destination iterator. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code> will point just past the last element copied into <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Several algorithms provide so-called &#8220;copying&#8221; versions. These algorithms compute new element values, but instead of putting them back into their input sequence, the algorithms create a new sequence to contain the results.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">replace</span></tt></code> algorithm reads a sequence and replaces every instance of a given value with another value. This algorithm takes four parameters: two iterators denoting the input range, and two values. It replaces each element that is equal to the first value with the second:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">replace any element with the value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><br class="calibre6"/>replace(ilst.begin(), ilst.end(), 0, 42);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call replaces all instances of <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> by <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>. If we want to leave the original sequence unchanged, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">replace_copy</span></tt></code>. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">back_inserter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to grow destination as needed</span></span></span><br class="calibre6"/>replace_copy(ilst.cbegin(), ilst.cend(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;back_inserter(ivec), 0, 42);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">After this call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ilst</span></tt></code> is unchanged, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code> contains a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ilst</span></tt></code> with the exception that every element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ilst</span></tt></code> with the value 0 has the value 42 in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos2506543" class="calibre37"><span class="calibre5">10.2.3. Algorithms That Reorder Container Elements</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Some algorithms rearrange the order of elements within a container. An obvious example of such an algorithm is <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>. A call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> arranges the elements in the input range into sorted order using the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, suppose we want to analyze the words used in a set of children&#8217;s stories. We&#8217;ll assume that we have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds the text of several stories. We&#8217;d like to reduce this <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> so that each word appears only once, regardless of how many times that word appears in any of the given stories.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For purposes of illustration, we&#8217;ll use the following simple story as our input:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">the quick red fox jumps over the slow red turtle</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Given this input, our program should produce the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>:</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00068.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2508583"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.6:</strong> Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code>, write a program to set a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> values to 0.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.7:</strong> Determine if there are any errors in the following programs and, if so, correct the error(s):</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec; list&lt;int&gt; lst; int i;<br class="calibre6"/>&#160;while (cin &gt;&gt; i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;lst.push_back(i);<br class="calibre6"/>&#160;copy(lst.cbegin(), lst.cend(), vec.begin());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vec;<br class="calibre6"/>&#160;vec.reserve(10); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reserve</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is covered in &#167; 9.4 (p. 356)</span></span></span><br class="calibre6"/>&#160;fill_n(vec.begin(), 10, 0);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.8:</strong> We said that algorithms do not change the size of the containers over which they operate. Why doesn&#8217;t the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">back_inserter</span></tt></code> invalidate this claim?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Eliminating Duplicates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To eliminate the duplicated words, we will first sort the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> so that duplicated words appear adjacent to each other. Once the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is sorted, we can use another library algorithm, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code>, to reorder the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> so that the unique elements appear in the first part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Because algorithms cannot do container operations, we&#8217;ll use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to actually remove the elements:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void elimDups(vector&lt;string&gt; &amp;words)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">sort</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">alphabetically so we can find the duplicates</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;sort(words.begin(), words.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unique</span></span></tt></span>&#160;&#160;<span><span class="calibre45"><span class="calibre16">reorders the input range so that each word appears once in the</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">front portion of the range and returns an iterator one past the unique range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto end_unique = unique(words.begin(), words.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">erase</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operation to remove the nonunique elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;words.erase(end_unique, words.end());<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> algorithm takes two iterators denoting the range of elements to sort. In this call, we sort the entire <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort, words</span></tt></code> is ordered as</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00069.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">Note that the words <code class="calibre23"><tt class="calibre23"><span class="calibre24">red</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">the</span></tt></code> appear twice.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Once <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> is sorted, we want to keep only one copy of each word. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code> algorithm rearranges the input range to &#8220;eliminate&#8221; adjacent duplicated entries, <a id="filepos2514857"/>and returns an iterator that denotes the end of the range of the unique values. After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> holds</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00070.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The size of <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> is unchanged; it still has ten elements. The order of those elements is changed&#8212;the adjacent duplicates have been &#8220;removed.&#8221; We put remove in quotes because <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code> doesn&#8217;t remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements appear at the front of the sequence. The iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code> denotes one past the last unique element. The elements beyond that point still exist, but we don&#8217;t know what values they have.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The library algorithms operate on iterators, not containers. Therefore, an algorithm cannot (directly) add or remove elements.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Container Operations to Remove Elements</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">To actually remove the unused elements, we must use a container operation, which we do in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2306887">9.3.3</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2306887">349</a>). We erase the range of elements from the one to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">end_unique</span></tt></code> refers through the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code>. After this call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> contains the eight unique words from the input.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> would be safe even if <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> has no duplicated words. In that case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code> would return <code class="calibre23"><tt class="calibre23"><span class="calibre24">words.end()</span></tt></code>. Both arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> would have the same value: <code class="calibre23"><tt class="calibre23"><span class="calibre24">words.end()</span></tt></code>. The fact that the iterators are equal would mean that the range passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> would be empty. Erasing an empty range has no effect, so our program is correct even if the input has no duplicates.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.9:</strong> Implement your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">elimDups</span></tt></code>. Test your program by printing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> after you read the input, after the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code>, and after the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.10:</strong> Why do you think the algorithms don&#8217;t change the size of containers?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="098-10.1._overview.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="100-10.3._customizing_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
