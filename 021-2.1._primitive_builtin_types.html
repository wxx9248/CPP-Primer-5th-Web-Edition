<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>2.1. Primitive Built-in Types</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="020-chapter_2._variables_and_basic_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="022-2.2._variables.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos288112" class="calibre29"><span class="bold">2.1. Primitive Built-in Types</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">C++ defines a set of primitive types that include the <strong class="calibre5"><a id="filepos288306" href="028-defined_terms.html#filepos612338">arithmetic types</a></strong> and a special type named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">void</span></span></tt></span></span></tt></code>. The arithmetic types represent characters, integers, boolean values, and floating-point numbers. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value.</p><div class="calibre15">&#160;</div>
<h4 id="filepos288881" class="calibre37"><span class="calibre5">2.1.1. Arithmetic Types</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The arithmetic types are divided into two categories: <strong class="calibre5"><a id="filepos289128" href="028-defined_terms.html#filepos620540">integral types</a></strong> (which include character and boolean types) and floating-point types.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The size of&#8212;that is, the number of bits in&#8212;the arithmetic types varies across machines. The standard guarantees minimum sizes as listed in <a href="021-2.1._primitive_builtin_types.html#filepos289763">Table 2.1</a>. However, compilers are allowed to use larger sizes for these types. Because the number of bits varies, the largest (or smallest) value that a type can represent also varies.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos289763"/>Table 2.1. C++: Arithmetic Types</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00014.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> type represents the truth values <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">There are several character types, most of which exist to support internationalization. The basic character type is <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> is guaranteed to be big enough to hold numeric values corresponding to the characters in the machine&#8217;s basic character set. That is, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> is the same size as a single machine byte.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos290839"/>The remaining character types&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char16_t</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">char32_t</span></tt></code>&#8212;are used for extended character sets. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code> type is guaranteed to be large enough to hold any character in the machine&#8217;s largest extended character set. The types <code class="calibre23"><tt class="calibre23"><span class="calibre24">char16_t</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">char32_t</span></tt></code> are intended for Unicode characters. (Unicode is a standard for representing characters used in essentially any natural language.)</p><div class="calibre22">&#160;</div>
<p class="calibre25">The remaining integral types represent integer values of (potentially) different sizes. The language guarantees that an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> will be at least as large as <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> at least as large as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code> at least as large as <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>. The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code> was introduced by the new standard.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos292468"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Machine-Level Representation of the Built-in Types</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Computers store data as a sequence of bits, each holding a 0 or 1, such as</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">00011011011100010110010000111011 ...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Most computers deal with memory as chunks of bits of sizes that are powers of 2. The smallest chunk of addressable memory is referred to as a &#8220;byte.&#8221; The basic unit of storage, usually a small number of bytes, is referred to as a &#8220;word.&#8221; In C++ a byte has at least as many bits as are needed to hold a character in the machine&#8217;s basic character set. On most machines a byte contains 8 bits and a word is either 32 or 64 bits, that is, 4 or 8 bytes.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Most computers associate a number (called an &#8220;address&#8221;) with each byte in memory. On a machine with 8-bit bytes and 32-bit words, we might view a word of memory as follows</p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00015.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Here, the byte&#8217;s address is on the left, with the 8 bits of the byte following the address.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">We can use an address to refer to any of several variously sized collections of bits starting at that address. It is possible to speak of the word at address 736424 or the byte at address 736427. To give meaning to memory at a given address, we must know the type of the value stored there. The type determines how many bits are used and how to interpret those bits.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">If the object at location 736424 has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code> and if <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code>s on this machine are stored in 32 bits, then we know that the object at that address spans the entire word. The value of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code> depends on the details of how the machine stores floating-point numbers. Alternatively, if the object at location 736424 is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code> on a machine using the ISO-Latin-1 character set, then the byte at that address represents a semicolon.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The floating-point types represent single-, double-, and extended-precision values. The standard specifies a minimum number of significant digits. Most compilers provide more precision than the specified minimum. Typically, <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code>s are represented in one word (32 bits), <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>s in two words (64 bits), and <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>s in either three or four words (96 or 128 bits). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> types typically yield about 7 and 16 significant digits, respectively. The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>
<a id="filepos296586"/>is often used as a way to accommodate special-purpose floating-point hardware; its precision is more likely to vary from one implementation to another.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Signed and Unsigned Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Except for <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> and the extended character types, the integral types may be <strong class="calibre5"><a id="filepos297046" href="028-defined_terms.html#filepos626822">signed</a></strong> or <strong class="calibre5"><a id="filepos297117" href="028-defined_terms.html#filepos630051">unsigned</a></strong>. A signed type represents negative or positive numbers (including zero); an unsigned type represents only values greater than or equal to zero.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The types <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code> are all signed. We obtain the corresponding unsigned type by adding <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> to the type, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>. The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code> may be abbreviated as <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Unlike the other integer types, there are three distinct basic character types: <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed char</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code>. In particular, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> is not the same type as <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed char</span></tt></code>. Although there are three character types, there are only two representations: signed and unsigned. The (plain) <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> type uses one of these representations. Which of the other two character representations is equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> depends on the compiler.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In an unsigned type, all the bits represent the value. For example, an 8-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code> can hold the values from 0 through 255 inclusive.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The standard does not define how signed types are represented, but does specify that the range should be evenly divided between positive and negative values. Hence, an 8-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed char</span></tt></code> is guaranteed to be able to hold values from &#8211;127 through 127; most modern machines use representations that allow values from &#8211;128 through 127.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Deciding which Type to Use</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">C++, like C, is designed to let programs get close to the hardware when necessary. The arithmetic types are defined to cater to the peculiarities of various kinds of hardware. Accordingly, the number of arithmetic types in C++ can be bewildering. Most programmers can (and should) ignore these complexities by restricting the types they use. A few rules of thumb can be useful in deciding which type to use:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Use an unsigned type when you know that the values cannot be negative.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> for integer arithmetic. <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> is usually too small and, in practice, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> often has the same size as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. If your data values are larger than the minimum guaranteed size of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, then use <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Do not use plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> in arithmetic expressions. Use them <em class="calibre16">only</em> to hold characters or truth values. Computations using <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> are especially problematic because <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed</span></tt></code> on some machines and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> on others. If you need a tiny integer, explicitly specify either <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed char</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> for floating-point computations; <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code> usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible. In fact, on some machines, double-precision operations are faster than single. The precision offered by <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code> usually is unnecessary and often entails considerable run-time cost.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos303010"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.1:</strong> What are the differences between <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>? Between an unsigned and a signed type? Between a <code class="calibre23"><tt class="calibre23"><span class="calibre24">float</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.2:</strong> To calculate a mortgage payment, what types would you use for the rate, principal, and payment? Explain why you selected each type.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos304094" class="calibre37"><span class="calibre5">2.1.2. Type Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The type of an object defines the data that an object might contain and what operations that object can perform. Among the operations that many types support is the ability to <strong class="calibre5">convert</strong> objects of the given type to other, related types.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Type conversions happen automatically when we use an object of one type where an object of another type is expected. We&#8217;ll have more to say about conversions in &#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a> (p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>), but for now it is useful to understand what happens when we assign a value of one type to an object of another type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we assign one arithmetic type to another:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool b = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><br class="calibre6"/>int i = b;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>i = 3.14;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span><br class="calibre6"/>double pi = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3.0</span></span></tt></span><br class="calibre6"/>unsigned char c = -1;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assuming 8-bit</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>, <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">255</span></span></tt></span><br class="calibre6"/>signed char c2 = 256;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assuming 8-bit</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>, <span><span class="calibre45"><span class="calibre16">the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is undefined</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">what happens depends on the range of the values that the types permit:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we assign one of the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> arithmetic types to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> object, the result is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> if the value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> otherwise.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> to one of the other arithmetic types, the resulting value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code> if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we assign a floating-point value to an object of integral type, the value is truncated. The value that is stored is the part before the decimal point.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When we assign an integral value to an object of floating-point type, the fractional part is zero. Precision may be lost if the integer has more bits than the floating-point object can accommodate.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. For example, an 8-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code> can hold values from 0 through 255, inclusive. If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. Therefore, assigning &#8211;1 to an 8-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code> gives that object the value 255.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If we assign an out-of-range value to an object of signed type, the result is <strong class="calibre5"><a id="filepos310269" href="028-defined_terms.html#filepos629355">undefined</a></strong>. The program might appear to work, it might crash, or it might produce garbage values.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos310517"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Avoid Undefined and Implementation-Defined Behavior</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Undefined behavior results from errors that the compiler is not required (and sometimes is not able) to detect. Even if the code compiles, a program that executes an undefined expression is in error.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Unfortunately, programs that contain undefined behavior can appear to execute correctly in some circumstances and/or on some compilers. There is no guarantee that the same program, compiled under a different compiler or even a subsequent release of the same compiler, will continue to run correctly. Nor is there any guarantee that what works with one set of inputs will work with another.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Similarly, programs usually should avoid implementation-defined behavior, such as assuming that the size of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> is a fixed and known value. Such programs are said to be <em class="calibre16">nonportable</em>. When the program is moved to another machine, code that relied on implementation-defined behavior may fail. Tracking down these sorts of problems in previously working programs is, mildly put, unpleasant.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The compiler applies these same type conversions when we use a value of one arithmetic type where a value of another arithmetic type is expected. For example, when we use a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value as a condition (&#167; <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a>, p. <a href="014-1.4._flow_of_control.html#filepos166704">12</a>), the arithmetic value is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> in the same way that it would be converted if we had assigned that arithmetic value to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> variable:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>if (i) // <span><span class="calibre45"><span class="calibre16">condition will evaluate as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;i = 0;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, then the condition is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>; all other (nonzero) values yield <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">By the same token, when we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> in an arithmetic expression, its value always converts to either <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>. As a result, using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> in an arithmetic expression is almost surely incorrect.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Expressions Involving Unsigned Types</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Although we are unlikely to intentionally assign a negative value to an object of unsigned type, we can (all too easily) write code that does so implicitly. For example, if we use both <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> values in an arithmetic expression, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value ordinarily is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>. Converting an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> executes the same way as if we assigned the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned u = 10;<br class="calibre6"/>int i = -42;<br class="calibre6"/>std::cout &lt;&lt; i + i &lt;&lt; std::endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span> -<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">84</span></span></tt></span><br class="calibre6"/>std::cout &lt;&lt; u + i &lt;&lt; std::endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if 32-bit</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s, prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">4294967264</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first expression, we add two (negative) <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> values and obtain the expected result. In the second expression, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value <code class="calibre23"><tt class="calibre23"><span class="calibre24">-42</span></tt></code> is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> before the addition is done. Converting a negative number to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> behaves exactly as if we had attempted to assign that negative value to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> object. The value &#8220;wraps around&#8221; as described above.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Regardless of whether one or both operands are unsigned, if we subtract a value from an unsigned, we must be sure that the result cannot be negative:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos317212"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned u1 = 42, u2 = 10;<br class="calibre6"/>std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl; // <span><span class="calibre45"><span class="calibre16">ok: result is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">32</span></span></tt></span><br class="calibre6"/>std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl; // <span><span class="calibre45"><span class="calibre16">ok: but the result will wrap around</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The fact that an unsigned cannot be less than zero also affects how we write loops. For example, in the exercises to &#167; <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a> (p. <a href="014-1.4._flow_of_control.html#filepos166704">13</a>), you were to write a loop that used the decrement operator to print the numbers from <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code> down to <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>. The loop you wrote probably looked something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (int i = 10; i &gt;= 0; --i)<br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; i &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We might think we could rewrite this loop using an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>. After all, we don&#8217;t plan to print negative numbers. However, this simple change in type means that our loop will never terminate:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">WRONG</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">: u</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can never be less than 0; the condition will always succeed</span></span></span><br class="calibre6"/>for (unsigned u = 10; u &gt;= 0; --u)<br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; u &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Consider what happens when <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>. On that iteration, we&#8217;ll print <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> and then execute the expression in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop. That expression, <code class="calibre23"><tt class="calibre23"><span class="calibre24">--u</span></tt></code>, subtracts <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code>. That result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code>, won&#8217;t fit in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> value. As with any other out-of-range value, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code> will be transformed to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> value. Assuming 32-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">--u</span></tt></code>, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, is <code class="calibre23"><tt class="calibre23"><span class="calibre24">4294967295</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">One way to write this loop is to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> instead of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>. Using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> lets us decrement before (rather than after) printing our value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned u = 11; // <span><span class="calibre45"><span class="calibre16">start the loop one past the first element we want to print</span></span></span><br class="calibre6"/>while (u &gt; 0) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;--u;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">decrement first, so that the last iteration will print 0</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; u &lt;&lt; std::endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This loop starts by decrementing the value of the loop control variable. On the last iteration, <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code> on entry to the loop. We&#8217;ll decrement that value, meaning that we&#8217;ll print <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> on this iteration. When we next test <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> condition, its value will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> and the loop will exit. Because we start by decrementing <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code>, we have to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> to a value one greater than the first value we want to print. Hence, we initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">11</span></tt></code>, so that the first value printed is <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Don&#8217;t Mix Signed and Unsigned Types</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. It is essential to remember that signed values are automatically converted to unsigned. For example, in an expression like <code class="calibre23"><tt class="calibre23"><span class="calibre24">a * b</span></tt></code>, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, then if both <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, the value is, as expected <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code>. However, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code>, then the value of this expression depends on how many bits an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> has on the particular machine. On our machine, this expression yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">4294967295</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos325446"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.3:</strong> What output will the following code produce?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned u = 10, u2 = 42;<br class="calibre6"/>std::cout &lt;&lt; u2 - u &lt;&lt; std::endl;<br class="calibre6"/>std::cout &lt;&lt; u - u2 &lt;&lt; std::endl;<br class="calibre6"/><br class="calibre6"/>int i = 10, i2 = 42;<br class="calibre6"/>std::cout &lt;&lt; i2 - i &lt;&lt; std::endl;<br class="calibre6"/>std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;<br class="calibre6"/><br class="calibre6"/>std::cout &lt;&lt; i - u &lt;&lt; std::endl;<br class="calibre6"/>std::cout &lt;&lt; u - i &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.4:</strong> Write a program to check whether your predictions were correct. If not, study this section until you understand what the problem is.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos326709" class="calibre37"><span class="calibre5">2.1.3. Literals</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A value, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>, is known as a <strong class="calibre5"><a id="filepos326932" href="028-defined_terms.html#filepos621001">literal</a></strong> because its value self-evident. Every literal has a type. The form and value of a literal determine its type.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Integer and Floating-Point Literals</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can write an integer literal using decimal, octal, or hexadecimal notation. Integer literals that begin with <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> (zero) are interpreted as octal. Those that begin with either <code class="calibre23"><tt class="calibre23"><span class="calibre24">0x</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">0X</span></tt></code> are interpreted as hexadecimal. For example, we can write the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">20</span></tt></code> in any of the following three ways:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">20 /* <span><span class="calibre45"><span class="calibre16">decimal</span></span></span> */ 024 /* <span><span class="calibre45"><span class="calibre16">octal</span></span></span> */ 0x14 /* <span><span class="calibre45"><span class="calibre16">hexadecimal</span></span></span> */</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of an integer literal depends on its value and notation. By default, decimal literals are signed whereas octal and hexadecimal literals can be either signed or unsigned types. A decimal literal has the smallest type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code> (i.e., the first type in this list) in which the literal&#8217;s value fits. Octal and hexadecimal literals have the smallest type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long long</span></tt></code> in which the literal&#8217;s value fits. It is an error to use a literal that is too large to fit in the largest related type. There are no literals of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>. We&#8217;ll see in <a href="021-2.1._primitive_builtin_types.html#filepos329875">Table 2.2</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos329875">40</a>) that we can override these defaults by using a suffix.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos329875"/>Table 2.2. Specifying the Type of a Literal</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00016.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. If we write what appears to be a negative decimal literal, for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-42</span></tt></code>, the minus sign is <em class="calibre16">not</em> part of the literal. The minus sign is an operator that negates the value of its (literal) operand.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Floating-point literals include either a decimal point or an exponent specified using scientific notation. Using scientific notation, the exponent is indicated by either <code class="calibre23"><tt class="calibre23"><span class="calibre24">E</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">3.14159&#160;&#160;&#160;&#160;3.14159E0&#160;&#160;&#160;&#160;0.&#160;&#160;&#160;&#160;0e0&#160;&#160;&#160;&#160;.001</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos331329"/>By default, floating-point literals have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. We can override the default using a suffix from <a href="021-2.1._primitive_builtin_types.html#filepos329875">Table 2.2</a> (overleaf).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Character and Character String Literals</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A character enclosed within single quotes is a literal of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. Zero or more characters enclosed in double quotation marks is a string literal:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">'a'&#160;&#160;// <span><span class="calibre45"><span class="calibre16">character literal</span></span></span><br class="calibre6"/>"Hello World!"&#160;&#160;// <span><span class="calibre45"><span class="calibre16">string literal</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of a string literal is <em class="calibre16"><strong class="calibre5"><a id="filepos332535" href="028-defined_terms.html#filepos612610">array</a></strong></em> of constant <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>s, a type we&#8217;ll discuss in &#167; <a href="034-3.5._arrays.html#filepos918393">3.5.4</a> (p. <a href="034-3.5._arrays.html#filepos918393">122</a>). The compiler appends a null character (&#8217;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\0</span></tt></code>&#8217;) to every string literal. Thus, the actual size of a string literal is one more than its apparent size. For example, the literal <code class="calibre23"><tt class="calibre23"><span class="calibre24">'A'</span></tt></code> represents the single character <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code>, whereas the string literal <code class="calibre23"><tt class="calibre23"><span class="calibre24">"A"</span></tt></code> represents an array of two characters, the letter <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> and the null character.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Two string literals that appear adjacent to one another and that are separated only by spaces, tabs, or newlines are concatenated into a single literal. We use this form of literal when we need to write a literal that would otherwise be too large to fit comfortably on a single line:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">multiline string literal</span></span></span><br class="calibre6"/>std::cout &lt;&lt; "a really, really long string literal "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"that spans two lines" &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Escape Sequences</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Some characters, such as backspace or control characters, have no visible image. Such characters are <strong class="calibre5"><a id="filepos334603" href="028-defined_terms.html#filepos622100">nonprintable</a></strong>. Other characters (single and double quotation marks, question mark, and backslash) have special meaning in the language. Our programs cannot use any of these characters directly. Instead, we use an <strong class="calibre5"><a id="filepos334876" href="028-defined_terms.html#filepos618223">escape sequence</a></strong> to represent such characters. An escape sequence begins with a backslash. The language defines several escape sequences:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31">newline&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\n</span></tt></code>&#160;&#160;&#160;&#160;&#160;horizontal tab&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\t</span></tt></code>&#160;&#160;&#160;&#160;&#160;alert&#160;(bell)&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\a</span></tt></code><br class="calibre6"/>vertical tab&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\v</span></tt></code>&#160;&#160;&#160;&#160;&#160;backspace&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\b</span></tt></code>&#160;&#160;&#160;&#160;&#160;double quote&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\"</span></tt></code><br class="calibre6"/>backslash&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\\</span></tt></code>&#160;&#160;&#160;&#160;&#160;question mark&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\?</span></tt></code>&#160;&#160;&#160;&#160;&#160;single quote&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\'</span></tt></code><br class="calibre6"/>carriage return&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\r</span></tt></code>&#160;&#160;&#160;&#160;&#160;formfeed&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">\f</span></tt></code></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We use an escape sequence as if it were a single character:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::cout &lt;&lt; '\n';&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints a newline</span></span></span><br class="calibre6"/>std::cout &lt;&lt; "\tHi!\n";&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints a tab followd by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"Hi!"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and a newline</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can also write a generalized escape sequence, which is <code class="calibre23"><tt class="calibre23"><span class="calibre24">\x</span></tt></code> followed by one or more hexadecimal digits or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code> followed by one, two, or three octal digits. The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><code class="calibre23"><tt class="calibre23"><span class="calibre24">\7 (</span></tt></code>bell<code class="calibre23"><tt class="calibre23"><span class="calibre24">)&#160;&#160;&#160;&#160;\12 (</span></tt></code>newline<code class="calibre23"><tt class="calibre23"><span class="calibre24">)&#160;&#160;&#160;&#160;&#160;&#160;\40 (</span></tt></code>blank<code class="calibre23"><tt class="calibre23"><span class="calibre24">)<br class="calibre6"/>\0 (</span></tt></code>null<code class="calibre23"><tt class="calibre23"><span class="calibre24">)&#160;&#160;&#160;&#160;\115 (</span></tt></code><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">'M'</span></span></tt></span><code class="calibre23"><tt class="calibre23"><span class="calibre24">)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\x4d (</span></tt></code><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">'M'</span></span></tt></span><code class="calibre23"><tt class="calibre23"><span class="calibre24">)</span></tt></code></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos339078"/>As with an escape sequence defined by the language, we use these escape sequences as we would any other character:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::cout &lt;&lt; "Hi \x4dO\115!\n";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Hi MOM!</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">followed by a newline</span></span></span><br class="calibre6"/>std::cout &lt;&lt; '\115' &lt;&lt; '\n';&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">M</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">followed by a newline</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Note that if a <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code> is followed by more than three octal digits, only the first three are associated with the <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code>. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">"\1234"</span></tt></code> represents two characters: the character represented by the octal value 123 and the character 4. In contrast, <code class="calibre23"><tt class="calibre23"><span class="calibre24">\x</span></tt></code> uses up all the hex digits following it; <code class="calibre23"><tt class="calibre23"><span class="calibre24">"\x1234"</span></tt></code> represents a single, 16-bit character composed from the bits corresponding to these four hexadecimal digits. Because most machines have 8-bit <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>s, such values are unlikely to be useful. Ordinarily, hexadecimal characters with more than 8 bits are used with extended characters sets using one of the prefixes from <a href="021-2.1._primitive_builtin_types.html#filepos329875">Table 2.2</a>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Specifying the Type of a Literal</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can override the default type of an integer, floating- point, or character literal by supplying a suffix or prefix as listed in <a href="021-2.1._primitive_builtin_types.html#filepos329875">Table 2.2</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">L'a'&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">wide character literal, type is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">wchar_t</span></span></tt></span><br class="calibre6"/>u8"hi!"&#160;&#160;// <span><span class="calibre45"><span class="calibre16">utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)</span></span></span><br class="calibre6"/>42ULL&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">unsigned integer literal, type is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unsigned long long</span></span></tt></span><br class="calibre6"/>1E-3F&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">single-precision floating-point literal, type is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">float</span></span></tt></span><br class="calibre6"/>3.14159L // <span><span class="calibre45"><span class="calibre16">extended-precision floating-point literal, type is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">long double</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When you write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> literal, use the uppercase <code class="calibre23"><tt class="calibre23"><span class="calibre24">L</span></tt></code>; the lowercase letter <code class="calibre23"><tt class="calibre23"><span class="calibre24">l</span></tt></code> is too easily mistaken for the digit 1.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">We can independently specify the signedness and size of an integral literal. If the suffix contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">U</span></tt></code>, then the literal has an unsigned type, so a decimal, octal, or hexadecimal literal with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">U</span></tt></code> suffix has the smallest type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long long</span></tt></code> in which the literal&#8217;s value fits. If the suffix contains an <code class="calibre23"><tt class="calibre23"><span class="calibre24">L</span></tt></code>, then the literal&#8217;s type will be at least <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>; if the suffix contains <code class="calibre23"><tt class="calibre23"><span class="calibre24">LL</span></tt></code>, then the literal&#8217;s type will be either <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long long</span></tt></code>. <a id="filepos344641"/>We can combine <code class="calibre23"><tt class="calibre23"><span class="calibre24">U</span></tt></code> with either <code class="calibre23"><tt class="calibre23"><span class="calibre24">L</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">LL</span></tt></code>. For example, a literal with a suffix of <code class="calibre23"><tt class="calibre23"><span class="calibre24">UL</span></tt></code> will be either <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long long</span></tt></code>, depending on whether its value fits in <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Boolean and Pointer Literals</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The words <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> are literals of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool test = false;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The word <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> is a pointer literal. We&#8217;ll have more to say about pointers and <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> in &#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a> (p. <a href="023-2.3._compound_types.html#filepos409391">52</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.5:</strong> Determine the type of each of the following literals. Explain the differences among the literals in each of the four examples:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">'a'</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">L'a'</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">"a"</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">L"a"</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10u</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10L</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10uL</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">012</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">0xC</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14f</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14L</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10u</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10.</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">10e-2</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.6:</strong> What, if any, are the differences between the following definitions:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>int month = 9, day = 7;<br class="calibre6"/>int month = 09, day = 07;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.7:</strong> What values do these literals represent? What type does each have?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">"Who goes with F\145rgus?\012"</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14e1L</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">1024f</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">3.14L</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.8:</strong> Using escape sequences, write a program to print <code class="calibre23"><tt class="calibre23"><span class="calibre24">2M</span></tt></code> followed by a newline. Modify the program to print <code class="calibre23"><tt class="calibre23"><span class="calibre24">2</span></tt></code>, then a tab, then an <code class="calibre23"><tt class="calibre23"><span class="calibre24">M</span></tt></code>, followed by a newline.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="020-chapter_2._variables_and_basic_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="022-2.2._variables.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
