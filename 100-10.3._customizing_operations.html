<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>10.3. Customizing Operations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="099-10.2._a_first_look_at_the_algorithms.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="101-10.4._revisiting_iterators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2519145" class="calibre29"><span class="bold">10.3. Customizing Operations</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Many of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2519746"/>For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> algorithm uses the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. However, we might want to sort a sequence into a different order from that defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, or our sequence might have elements of a type (such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>) that does not have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. In both cases, we need to override the default behavior of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2520495" class="calibre37"><span class="calibre5">10.3.1. Passing a Function to an Algorithm</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As one example, assume that we want to print the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> after we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">elimDups</span></tt></code> (&#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">384</a>). However, we&#8217;ll also assume that we want to see the words ordered by their size, and then alphabetically within each size. To reorder the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> by length, we&#8217;ll use a second, overloaded version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>. This version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> takes a third argument that is a <strong class="calibre5"><a id="filepos2521451" href="105-defined_terms.html#filepos2716674">predicate</a></strong>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Predicates</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either <strong class="calibre5"><a id="filepos2521820" href="105-defined_terms.html#filepos2718411">unary predicates</a></strong> (meaning they have a single parameter) or <strong class="calibre5"><a id="filepos2521940" href="105-defined_terms.html#filepos2710462">binary predicates</a></strong> (meaning they have two parameters). The algorithms that take predicates call the given predicate on the elements in the input range. As a result, it must be possible to convert the element type to the parameter type of the predicate.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> that takes a binary predicate uses the given predicate in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> to compare elements. The predicates that we supply to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> must meet the requirements that we&#8217;ll describe in &#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). For now, what we need to know is that the operation must define a consistent order for all possible elements in the input sequence. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> function from &#167; <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a> (p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>) is an example of a function that meets these requirements, so we can pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>. Doing so will reorder the elements by size:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">comparison function to be used to sort by word length</span></span></span><br class="calibre6"/>bool isShorter(const string &amp;s1, const string &amp;s2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return s1.size() &lt; s2.size();<br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">sort on word length, shortest to longest</span></span></span><br class="calibre6"/>sort(words.begin(), words.end(), isShorter);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> contains the same data as in &#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a> (p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">384</a>), this call would reorder <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> so that all the words of length 3 appear before words of length 4, which in turn are followed by words of length 5, and so on.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Sorting Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we sort <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> by size, we also want to maintain alphabetic order among the elements that have the same length. To keep the words of the same length in alphabetical order we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> algorithm. A stable sort maintains the original order among equal elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Ordinarily, we don&#8217;t care about the relative order of equal elements in a sorted sequence. After all, they&#8217;re equal. However, in this case, we have defined &#8220;equal&#8221; <a id="filepos2525318"/>to mean &#8220;have the same length.&#8221; Elements that have the same length still differ from one another when we view their contents. By calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code>, we can maintain alphabetical order among those elements that have the same length:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">elimDups(words); // <span><span class="calibre45"><span class="calibre16">put</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in alphabetical order and remove duplicates</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">resort by length, maintaining alphabetical order among words of the same length</span></span></span><br class="calibre6"/>stable_sort(words.begin(), words.end(), isShorter);<br class="calibre6"/>for (const auto &amp;s : words)&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no need to copy the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; s &lt;&lt; " ";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print each element separated by a space</span></span></span><br class="calibre6"/>cout &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> was in alphabetical order before this call, after the call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> will be sorted by element size, and the words of each length remain in alphabetical order. If we run this code on our original <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, the output will be</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">fox red the over slow jumps quick turtle</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.11:</strong> Write a program that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> to sort a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> passed to your version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">elimDups</span></tt></code>. Print the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to verify that your program is correct.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos2528435"/><strong class="calibre5">Exercise 10.12:</strong> Write a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">compareIsbn</span></tt></code> that compares the <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn()</span></tt></code> members of two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects. Use that function to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that holds <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos2529100"/><strong class="calibre5">Exercise 10.13:</strong> The library defines an algorithm named <code class="calibre23"><tt class="calibre23"><span class="calibre24">partition</span></tt></code> that takes a predicate and partitions the container so that values for which the predicate is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> appear in the first part and those for which the predicate is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> appear in the second part. The algorithm returns an iterator just past the last element for which the predicate returned <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. Write a function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> has five characters or more. Use that function to partition <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code>. Print the elements that have five or more characters.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2530282" class="calibre37"><span class="calibre5">10.3.2. Lambda Expressions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respectively. However, sometimes we want to do processing that requires more arguments than the algorithm&#8217;s predicate allows. For example, the solution you wrote for the last exercise in the previous section had to hard-wire the size 5 into the predicate used to partition the sequence. It would be move useful to be able to partition a sequence without having to write a separate predicate for every possible size.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As a related example, we&#8217;ll revise our program from &#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>) to report how many words are of a given size or greater. We&#8217;ll also change the output so that it prints only the words of the given length or greater.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A sketch of this function, which we&#8217;ll name <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code>, is as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2531609"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void biggies(vector&lt;string&gt; &amp;words,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector&lt;string&gt;::size_type sz)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;elimDups(words); // <span><span class="calibre45"><span class="calibre16">put</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in alphabetical order and remove duplicates</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">resort by length, maintaining alphabetical order among words of the same length</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;stable_sort(words.begin(), words.end(), isShorter);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get an iterator to the first element whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">compute the number of elements with size</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print words of the given size or longer, each one followed by a space</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Our new problem is to find the first element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that has the given size. Once we know that element, we can use its position to compute how many elements have that size or greater.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> algorithm to find an element that has a particular size. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> (&#167; <a href="098-10.1._overview.html#filepos2458324">10.1</a>, p. <a href="098-10.1._overview.html#filepos2458324">376</a>), the <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> algorithm takes a pair of iterators denoting a range. Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code>, the third argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> is a predicate. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> algorithm calls the given predicate on each element in the input range. It returns the first element for which the predicate returns a nonzero value, or its end iterator if no such element is found.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It would be easy to write a function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and a size and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether the size of a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is greater than the given size. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> takes a unary predicate&#8212;any function we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> must have exactly one parameter that can be called with an element from the input sequence. There is no way to pass a second argument representing the size. To solve this part of our problem we&#8217;ll need to use some additional language facilities.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Introducing Lambdas</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can pass any kind of <strong class="calibre5"><a id="filepos2535620" href="105-defined_terms.html#filepos2711085">callable object</a></strong> to an algorithm. An object or expression is callable if we can apply the call operator (&#167; <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>) to it. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> is a callable expression, we can write <code class="calibre23"><tt class="calibre23"><span class="calibre24">e(args)</span></tt></code> where args is a comma-separated list of zero or more arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The only callables we&#8217;ve used so far are functions and function pointers (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>). There are two other kinds of callables: classes that overload the function-call operator, which we&#8217;ll cover in &#167; <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a> (p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>), and <strong class="calibre5"><a id="filepos2536540" href="105-defined_terms.html#filepos2715084">lambda expressions</a></strong>.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2536657"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function. A lamba expression has the form</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">[<span><span class="calibre45"><span class="calibre16">capture list</span></span></span>] (<span><span class="calibre45"><span class="calibre16">parameter list</span></span></span>) -&gt; <span><span class="calibre45"><span class="calibre16">return type</span></span></span>&#160;&#160;{ <span><span class="calibre45"><span class="calibre16">function body</span></span></span> }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16"><a id="filepos2537724" href="105-defined_terms.html#filepos2711463">capture list</a></em> is an (often empty) list of local variables defined in the enclosing function; <em class="calibre16">return type</em>, <em class="calibre16">parameter list</em>, and <em class="calibre16">function body</em> are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>) to specify its return type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can omit either or both of the parameter list and return type but must always include the capture list and function body:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><a id="filepos2538459"/>auto f = [] { return 42; };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we&#8217;ve defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> as a callable object that takes no arguments and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We call a lambda the same way we call a function by using the call operator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; f() &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Omitting the parentheses and the parameter list in a lambda is equivalent to specifying an empty parameter list. Hence, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, the argument list is empty. If we omit the return type, the lambda has an inferred return type that depends on the code in the function body. If the function body is just a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement, the return type is inferred from the type of the expression that is returned. Otherwise, the return type is <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Lambdas with function bodies that contain anything other than a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement that do not specify a return type return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Passing Arguments to a Lambda</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As with an ordinary function call, the arguments in a call to a lambda are used to initialize the lambda&#8217;s parameters. As usual, the argument and parameter types must match. Unlike ordinary functions, a lambda may not have default arguments (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>). Therefore, a call to a lambda always has as many arguments as the lambda has parameters. Once the parameters are initialized, the function body executes.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example of a lambda that takes arguments, we can write a lambda that behaves like our <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">[](const string &amp;a, const string &amp;b)<br class="calibre6"/>&#160;&#160;{ return a.size() &lt; b.size();}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The empty capture list indicates that this lambda will not use any local variables from the surrounding function. The lambda&#8217;s parameters, like the parameters to <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code>, are references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>. Again like <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code>, the lambda&#8217;s function body compares its parameters&#8217; <code class="calibre23"><tt class="calibre23"><span class="calibre24">size()</span></tt></code>s and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> that depends on the relative sizes of the given arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can rewrite our call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> to use this lambda as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">sort</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by size, but maintain alphabetical order for words of the same size</span></span></span><br class="calibre6"/>stable_sort(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](const string &amp;a, const string &amp;b)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return a.size() &lt; b.size();});</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> needs to compare two elements, it will call the given lambda expression.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Capture List</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;re now ready to solve our original problem, which is to write a callable expression that we can pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code>. We want an expression that will compare the <a id="filepos2544363"/>length of each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in the input sequence with the value of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> parameter in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although a lambda may appear inside a function, it can use variables local to that function <em class="calibre16">only</em> if it specifies which variables it intends to use. A lambda specifies the variables it will use by including those local variables in its capture list. The capture list directs the lambda to include information needed to access those variables within the lambda itself.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In this case, our lambda will capture <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> and will have a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> parameter. The body of our lambda will compare the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>&#8217;s size with the captured value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">[sz](const string &amp;a)<br class="calibre6"/>&#160;&#160;&#160;&#160;{ return a.size() &gt;= sz; };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">[]</span></tt></code> that begins a lambda we can provide a comma-separated list of names defined in the surrounding function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because this lambda captures <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>, the body of the lambda may use <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>. The lambda does not capture <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code>, and so has no access to that variable. Had we given our lambda an empty capture list, our code would not compile:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sz</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not captured</span></span></span><br class="calibre6"/>[](const string &amp;a)<br class="calibre6"/>&#160;&#160;&#160;&#160;{ return a.size() &gt;= sz; };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A lambda may use a variable local to its surrounding function <em class="calibre16">only</em> if the lambda captures that variable in its capture list.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Calling <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_if</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Using this lambda, we can find the first element whose size is at least as big as <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">get an iterator to the first element whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>auto wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[sz](const string &amp;a)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return a.size() &gt;= sz; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> returns an iterator to the first element that is at least as long as the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>, or a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">words.end()</span></tt></code> if no such element exists.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use the iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> to compute how many elements appear between that iterator and the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> (&#167; <a href="033-3.4._introducing_iterators.html#filepos839265">3.4.2</a>, p. <a href="033-3.4._introducing_iterators.html#filepos839265">111</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">compute the number of elements with size</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>auto count = words.end() - wc;<br class="calibre6"/>cout &lt;&lt; count &lt;&lt; " " &lt;&lt; make_plural(count, "word", "s")<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " of length " &lt;&lt; sz &lt;&lt; " or longer" &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our output statement calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_plural</span></tt></code> (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>) to print <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code>, depending on whether that size is equal to 1.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2551054"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">for_each</span></span></tt></span></span></tt></code> Algorithm</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The last part of our problem is to print the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> that have length <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> or greater. To do so, we&#8217;ll use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> algorithm. This algorithm takes a callable object and calls that object on each element in the input range:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print words of the given size or longer, each one followed by a space</span></span></span><br class="calibre6"/>for_each(wc, words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](const string &amp;s){cout &lt;&lt; s &lt;&lt; " ";});<br class="calibre6"/>cout &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The capture list in this lambda is empty, yet the body uses two names: its own parameter, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The capture list is empty, because we use the capture list only for (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>) variables defined in the surrounding function. A lambda can use names that are defined outside the function in which the lambda appears. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> is not a name defined locally in <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies;</span></tt></code> that name is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostream</span></tt></code> header. So long as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostream</span></tt></code> header is included in the scope in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> appears, our lambda can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The capture list is used for local non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> variables only; lambdas can use local <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>s and variables declared outside the function directly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Putting It All Together</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Now that we&#8217;ve looked at the program in detail, here is the program as a whole:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void biggies(vector&lt;string&gt; &amp;words,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector&lt;string&gt;::size_type sz)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;elimDups(words); // <span><span class="calibre45"><span class="calibre16">put</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in alphabetical order and remove duplicates</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">sort</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by size, but maintain alphabetical order for words of the same size</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;stable_sort(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](const string &amp;a, const string &amp;b)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return a.size() &lt; b.size();});<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get an iterator to the first element whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[sz](const string &amp;a)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return a.size() &gt;= sz; });<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">compute the number of elements with size</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto count = words.end() - wc;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; count &lt;&lt; " " &lt;&lt; make_plural(count, "word", "s")<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; " of length " &lt;&lt; sz &lt;&lt; " or longer" &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print words of the given size or longer, each one followed by a space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for_each(wc, words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](const string &amp;s){cout &lt;&lt; s &lt;&lt; " ";});<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2557474"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.14:</strong> Write a lambda that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and returns their sum.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.15:</strong> Write a lambda that captures an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> from its enclosing function and takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter. The lambda should return the sum of the captured <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.16:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> function using lambdas.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.17:</strong> Rewrite <a href="100-10.3._customizing_operations.html#filepos2528435">exercise 10.12</a> from &#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>) to use a lambda in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> instead of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">compareIsbn</span></tt></code> function.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.18:</strong> Rewrite <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">partition</span></tt></code> instead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code>. We described the <code class="calibre23"><tt class="calibre23"><span class="calibre24">partition</span></tt></code> algorithm in <a href="100-10.3._customizing_operations.html#filepos2529100">exercise 10.13</a> in &#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.19:</strong> Rewrite the previous exercise to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_partition</span></tt></code>, which like <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> maintains the original element order in the paritioned sequence.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2560162" class="calibre37"><span class="calibre5">10.3.3. Lambda Captures and Returns</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda. We&#8217;ll see how these classes are generated in &#167; <a href="137-14.8._functioncall_operator.html#filepos3668993">14.8.1</a> (p. <a href="137-14.8._functioncall_operator.html#filepos3668993">572</a>). For now, what&#8217;s useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda.</p><div class="calibre15">&#160;</div>
<p class="calibre25">By default, the class generated from a lambda contains a data member corresponding to the variables captured by the lambda. Like the data members of any class, the data members of a lambda are initialized when a lambda object is created.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Capture by Value</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Similar to parameter passing, we can capture variables by value or by reference. <a href="100-10.3._customizing_operations.html#filepos2563299">Table 10.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2563299">395</a>) covers the various ways we can form a capture list. So far, our lambdas have captured variables by value. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn1()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t v1 = 42;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">local variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copies</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into the callable object named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto f = [v1] { return v1; };<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;auto j = f(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42; f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">stored a copy of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">when we created it</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2563299"/>Table 10.1. Lambda Capture List</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00071.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">Because the value is copied when the lambda is created, subsequent changes to a captured variable have no effect on the corresponding value inside the lambda.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2563709"/>Capture by Reference</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can also define lambdas that capture variables by reference. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn2()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t v1 = 42;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">local variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">the object</span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">contains a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto f2 = [&amp;v1] { return v1; };<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;auto j = f2(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>; <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">it doesn't store it</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> before <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> indicates that <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> should be captured as a reference. A variable captured by reference acts like any other reference. When we use the variable inside the lambda body, we are using the object to which that reference is bound. In this case, when the lambda returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code>, it returns the value of the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> refers.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Reference captures have the same problems and restrictions as reference returns (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">225</a>). If we capture a variable by reference, we must be <em class="calibre16">certain</em> that the referenced object exists at the time the lambda is executed. The variables captured by a lambda are local variables. These variables cease to exist once the function completes. If it is possible for a lambda to be executed after the function finishes, the local variables to which the capture refers no longer exist.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Reference captures are sometimes necessary. For example, we might want our <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> function to take a reference to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> on which to write and a character to use as the separator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void biggies(vector&lt;string&gt; &amp;words,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector&lt;string&gt;::size_type sz,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ostream &amp;os = cout, char c = ' ')<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">code to reorder</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as before</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">statement to print</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">count</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">revised to print to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">os</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&amp;os, c](const string &amp;s) { os &lt;&lt; s &lt;&lt; c; });<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We cannot copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> objects (&#167; <a href="083-8.1._the_io_classes.html#filepos2083864">8.1.1</a>, p. <a href="083-8.1._the_io_classes.html#filepos2083864">311</a>); the only way to capture <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code> is by reference (or through a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we pass a lambda to a function, as in this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code>, the lambda executes immediately. Capturing <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code> by reference is fine, because the variables in <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> exist while <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> is running.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can also return a lambda from a function. The function might directly return a callable object or the function might return an object of a class that has a callable object as a data member. If the function returns a lambda, then&#8212;for the same reasons that a function must not return a reference to a local variable&#8212;that lambda must not contain reference captures.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we capture a variable by reference, we must ensure that the variable exists at the time that the lambda executes.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos2570357"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Keep Your Lambda Captures Simple</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed. It is the programmer&#8217;s responsibility to ensure that whatever information is captured has the intended meaning each time the lambda is executed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Capturing an ordinary variable&#8212;an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, or other nonpointer type&#8212;by value is usually straightforward. In this case, we only need to care whether the variable has the value we need when we capture it.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">If we capture a pointer or iterator, or capture a variable by reference, we must ensure that the object bound to that iterator, pointer, or reference still exists, whenever the lambda <em class="calibre16">executes.</em> Moreover, we need to ensure that the object has the intended value. Code that executes between when the lambda is created and when it executes might change the value of the object to which the lambda capture points (or refers). The value of the object at the time the pointer (or reference) was captured might have been what we wanted. The value of that object when the lambda executes might be quite different.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As a rule, we can avoid potential problems with captures by minimizing the data we capture. Moreover, if possible, avoid capturing pointers or references.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Implicit Captures</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Rather than explicitly listing the variables we want to use from the enclosing function, we can let the compiler infer which variables we use from the code in the lambda&#8217;s body. To direct the compiler to infer the capture list, we use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> in the capture list. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> tells the compiler to capture by reference, and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> says the values are captured by value. For example, we can rewrite the lambda that we passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sz</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">implicitly captured by value</span></span></span><br class="calibre6"/>wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[=](const string &amp;s)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return s.size() &gt;= sz; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">If we want to capture some variables by value and others by reference, we can mix implicit and explicit captures:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void biggies(vector&lt;string&gt; &amp;words,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector&lt;string&gt;::size_type sz,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ostream &amp;os = cout, char c = ' ')<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other processing as before</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">os</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">implicitly captured by reference;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">explicitly captured by value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&amp;, c](const string &amp;s) { os &lt;&lt; s &lt;&lt; c; });<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">os</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">explicitly captured by reference;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">implicitly captured by value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for_each(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[=, &amp;os](const string &amp;s) { os &lt;&lt; s &lt;&lt; c; });<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2576136"/>When we mix implicit and explicit captures, the first item in the capture list must be an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>. That symbol sets the default capture mode as by reference or by value, respectively.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we mix implicit and explicit captures, the explicitly captured variables must use the alternate form. That is, if the implicit capture is by reference (using <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>), then the explicitly named variables must be captured by value; hence their names may not be preceded by an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>. Alternatively, if the implicit capture is by value (using <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>), then the explicitly named variables must be preceded by an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code> to indicate that they are to be captured by reference.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Mutable Lambdas</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, a lambda may not change the value of a variable that it copies by value. If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code>. Lambdas that are mutable may not omit the parameter list:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn3()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t v1 = 42; // <span><span class="calibre45"><span class="calibre16">local variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can change the value of the variables it captures</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto f = [v1] () mutable { return ++v1; };<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;auto j = f(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is 43</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Whether a variable captured by reference can be changed (as usual) depends only on whether that reference refers to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2579056"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void fcn4()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t v1 = 42;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">local variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to a non</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we can change that variable through the reference inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto f2 = [&amp;v1] { return ++v1; };<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;auto j = f2(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is 1</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Specifying the Lambda Return Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The lambdas we&#8217;ve written so far contain only a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement. As a result, we haven&#8217;t had to specify the return type. By default, if a lambda body contains any statements other than a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code>, that lambda is assumed to return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. Like other functions that return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>, lambdas inferred to return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> may not return a value.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As a simple example, we might use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> algorithm and a lambda to replace each negative value in a sequence with its absolute value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">transform(vi.begin(), vi.end(), vi.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int i) { return i &lt; 0 ? -i : i; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> function takes three iterators and a callable. The first two iterators denote an input sequence and the third is a destination. The algorithm calls the given callable on each element in the input sequence and writes the result to the destination. As in this call, the destination iterator can be the same as the iterator denoting the start of the input. When the input iterator and the destination iterator are the same, <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> replaces each element in the input range with the result of calling the callable on that element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this call, we passed a lambda that returns the absolute value of its parameter. The lambda body is a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement that returns the result of a conditional expression. We need not specify the return type, because that type can be inferred from the type of the conditional operator.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, if we write the seemingly equivalent program using an <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> statement, our code won&#8217;t compile:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: cannot deduce the return type for the lambda</span></span></span><br class="calibre6"/>transform(vi.begin(), vi.end(), vi.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int i) { if (i &lt; 0) return -i; else return i; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version of our lambda infers the return type as <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code> but we returned a value.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2584038"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">When we need to define a return type for a lambda, we must use a trailing return type (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">transform(vi.begin(), vi.end(), vi.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](int i) -&gt; int<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ if (i &lt; 0) return -i; else return i; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, the fourth argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">transform</span></tt></code> is a lambda with an empty capture list, which takes a single parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and returns a value of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Its function body is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> statement that returns the absolute value of its parameter.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2585437"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.20:</strong> The library defines an algorithm named <code class="calibre23"><tt class="calibre23"><span class="calibre24">count_if</span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code>, this function takes a pair of iterators denoting an input range and a predicate that it applies to each element in the given range. <code class="calibre23"><tt class="calibre23"><span class="calibre24">count_if</span></tt></code> returns a count of how often the predicate is true. Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">count_if</span></tt></code> to rewrite the portion of our program that counted how many words are greater than length 6.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.21:</strong> Write a lambda that captures a local <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> variable and decrements that variable until it reaches 0. Once the variable is 0 additional calls should no longer decrement the variable. The lambda should return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> that indicates whether the captured variable is 0.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2586884" class="calibre37"><span class="calibre5">10.3.4. Binding Arguments</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. Similarly, if an operation requires many statements, it is ordinarily better to use a function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is usually straightforward to use a function in place of a lambda that has an empty capture list. As we&#8217;ve seen, we can use either a lambda or our <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> function to order the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> on word length. Similarly, it would be easy to replace the lambda that printed the contents of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> by writing a function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and prints the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to the standard output.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> compared a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> with a given size. We can easily write a function to do the same work:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool check_size(const string &amp;s, string::size_type sz)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return s.size() &gt;= sz;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, we can&#8217;t use this function as an argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code>. As we&#8217;ve seen, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> takes a unary predicate, so the callable passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> must take a single argument. The lambda that <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> used its capture list to store <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>. In order to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> in place of that lambda, we have to figure out how to pass an argument to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> parameter.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bind</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos2590269"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">We can solve the problem of passing a size argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> by using a new library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2590610" href="105-defined_terms.html#filepos2710675">bind</a></span></span></tt></span></span></tt></code>, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> function can be thought of as a general-purpose function adaptor (&#167; <a href="094-9.6._container_adaptors.html#filepos2426063">9.6</a>, p. <a href="094-9.6._container_adaptors.html#filepos2426063">368</a>). It takes a callable object and generates a new callable that &#8220;adapts&#8221; the parameter list of the original object.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2591212"/>The general form of a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> is:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto <span><span class="calibre45"><span class="calibre16">newCallable</span></span></span> = bind(<span><span class="calibre45"><span class="calibre16">callable</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">arg_list</span></span></span>);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">newCallable</em> is itself a callable object and <em class="calibre16">arg_list</em> is a comma-separated list of arguments that correspond to the parameters of the given <em class="calibre16">callable</em>. That is, when we call <em class="calibre16">newCallable</em>, <em class="calibre16">newCallable</em> calls <em class="calibre16">callable</em>, passing the arguments in <em class="calibre16">arg_list</em>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The arguments in <em class="calibre16">arg_list</em> may include names of the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">_</span></tt></code><em class="calibre16">n</em>, where <em class="calibre16">n</em> is an integer. These arguments are &#8220;placeholders&#8221; representing the parameters of <em class="calibre16">newCallable</em>. They stand &#8220;in place of&#8221; the arguments that will be passed to <em class="calibre16">newCallable</em>. The number <em class="calibre16">n</em> is the position of the parameter in the generated callable: <code class="calibre23"><tt class="calibre23"><span class="calibre24">_1</span></tt></code> is the first parameter in <em class="calibre16">newCallable</em>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">_2</span></tt></code> is the second, and so forth.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Binding the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sz</span></span></tt></span></span></tt></code> Parameter of <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">check_size</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As a simple example, we&#8217;ll use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> to generate an object that calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> with a fixed value for its size parameter as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check6</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a callable object that takes one argument of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">and calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check_size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on its given</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and the value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">6</span></span></tt></span><br class="calibre6"/>auto check6 = bind(check_size, _1, 6);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> has only one placeholder, which means that <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code> takes a single argument. The placeholder appears first in <em class="calibre16">arg_list</em>, which means that the parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code> corresponds to the first parameter of <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code>. That parameter is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string&amp;</span></tt></code>, which means that the parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code> is also a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string&amp;</span></tt></code>. Thus, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code> must pass an argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, which <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code> will pass as the first argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second argument in <em class="calibre16">arg_list</em> (i.e., the third argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>) is the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">6</span></tt></code>. That value is bound to the second parameter of <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code>. Whenever we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">check6</span></tt></code>, it will pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">6</span></tt></code> as the second argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s = "hello";<br class="calibre6"/>bool b1 = check6(s);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check6(s</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check_size(s, 6</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>, we can replace our original lambda-based call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[sz](const string &amp;a)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">with a version that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind(check_size, _1, sz));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> generates a callable object that binds the second argument of <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> to the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> calls this object on the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s in <code class="calibre23"><tt class="calibre23"><span class="calibre24">words</span></tt></code> those calls will in turn call <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> passing the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>. So, <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> (effectively) will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> on each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in the input range and compare the size of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2599897"/>Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">placeholders</span></span></tt></span></span></tt></code> Names</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">_</span></tt></code><em class="calibre16">n</em> names are defined in a namespace named <code class="calibre23"><tt class="calibre23"><span class="calibre24">placeholders</span></tt></code>. That namespace is itself defined inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace (&#167; <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>). To use these names, we must supply the names of both namespaces. As with our other examples, our calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> assume the existence of appropriate <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">_1</span></tt></code> is</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using std::placeholders::_1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This declaration says we&#8217;re using the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">_1</span></tt></code>, which is defined in the namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">placeholders</span></tt></code>, which is itself defined in the namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We must provide a separate <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for each placeholder name that we use. Writing such declarations can be tedious and error-prone. Rather than separately declaring each placeholder, we can use a different form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> that we will cover in more detail in &#167; <a href="172-18.2._namespaces.html#filepos4964533">18.2.2</a> (p. <a href="172-18.2._namespaces.html#filepos4964533">793</a>). This form:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using namespace <span><span class="calibre45"><span class="calibre16">namespace_name</span></span></span>;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">says that we want to make all the names from <em class="calibre16">namespace_name</em> accessible to our program. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using namespace std::placeholders;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">makes all the names defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">placeholders</span></tt></code> usable. Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> function, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">placeholders</span></tt></code> namespace is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bind</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> to fix the value of a parameter. More generally, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> to bind or rearrange the parameters in the given callable. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is a callable object that has five parameters, the following call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">g</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a callable object that takes two arguments</span></span></span><br class="calibre6"/>auto g = bind(f, a, b, _2, c, _1);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">generates a new callable that takes two arguments, represented by the placeholders <code class="calibre23"><tt class="calibre23"><span class="calibre24">_2</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">_1</span></tt></code>. The new callable will pass its own arguments as the third and fifth arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>. The first, second, and fourth arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> are bound to the given values, <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>, respectively.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> are bound positionally to the placeholders. That is, the first argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">_1</span></tt></code>, and the second argument is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">_2</span></tt></code>. Thus, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>, the first argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> will be passed as the last argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>; the second argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> will be passed as <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s third argument. In effect, this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> maps</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">g(_1, _2)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">to</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f(a, b, _2, c, _1)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">That is, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> using <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s arguments for the placeholders along with the bound arguments, <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>. For example, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">g(X, Y)</span></tt></code> calls</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f(a, b, Y, c, X)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2607928"/>Using to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bind</span></span></tt></span></span></tt></code> to Reorder Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As a more concrete example of using <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> to reorder arguments, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> to invert the meaning of <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> by writing</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">sort on word length, shortest to longest</span></span></span><br class="calibre6"/>sort(words.begin(), words.end(), isShorter);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">sort on word length, longest to shortest</span></span></span><br class="calibre6"/>sort(words.begin(), words.end(), bind(isShorter, _2, _1));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first call, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> needs to compare two elements, <code class="calibre23"><tt class="calibre23"><span class="calibre24">A</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>, it will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter(A, B)</span></tt></code>. In the second call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code>, the arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter</span></tt></code> are swapped. In this case, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> compares elements, it will be as if <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> called <code class="calibre23"><tt class="calibre23"><span class="calibre24">isShorter(B, A)</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Binding Reference Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, the arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> that are not placeholders are copied into the callable object that <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> returns. However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference or we might want to bind an argument that has a type that we cannot copy.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, to replace the lambda that captured an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> by reference:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">os</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a local variable referring to an output stream</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a local variable of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char</span></span></tt></span><br class="calibre6"/>for_each(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&amp;os, c](const string &amp;s) { os &lt;&lt; s &lt;&lt; c; });</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can easily write a function to do the same job:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ostream &amp;print(ostream &amp;os, const string &amp;s, char c)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return os &lt;&lt; s &lt;&lt; c;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, we can&#8217;t use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> directly to replace the capture of <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: cannot copy</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">os</span></span></tt></span><br class="calibre6"/>for_each(words.begin(), words.end(), bind(print, os, _1, ' '));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">because <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> copies its arguments and we cannot copy an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code>. If we want to pass an object to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> without copying it, we must use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2613447" href="105-defined_terms.html#filepos2717512">ref</a></span></span></tt></span></span></tt></code> function:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for_each(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bind(print, ref(os), _1, ' '));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">ref</span></tt></code> function returns an object that contains the given reference and that is itself copyable. There is also a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2614288" href="105-defined_terms.html#filepos2711762">cref</a></span></span></tt></span></span></tt></code> function that generates a class that holds a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ref</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cref</span></tt></code> functions are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos2614920"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Backward Compatibility: Binding Arguments</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. The library defined two functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind1st</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind2nd</span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>, these functions take a function and generate a new callable object that calls the given function with one of its parameters bound to a given value. However, these functions can bind only the first or second parameter, respectively. Because they are of much more limited utility, they have been <em class="calibre16">deprecated</em> in the new standard. A deprecated feature is one that may not be supported in future releases. Modern C++ programs should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 10.3.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.22:</strong> Rewrite the program to count words of size 6 or less using functions in place of the lambdas.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.23:</strong> How many arguments does <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> take?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.24:</strong> Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> to find the first element in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s that has a value greater than the length of a specified <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> value.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 10.25:</strong> In the exercises for &#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a> (p. <a href="100-10.3._customizing_operations.html#filepos2530282">392</a>) you wrote a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">partition</span></tt></code>. Rewrite that function to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">check_size</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="099-10.2._a_first_look_at_the_algorithms.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="101-10.4._revisiting_iterators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
