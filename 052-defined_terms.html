<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Defined Terms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="051-chapter_summary.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="053-chapter_5._statements.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1213446" class="calibre29"><span class="bold">Defined Terms</span></h3><div class="calibre12">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1213585" href="049-4.11._type_conversions.html#filepos1163004"><strong class="calibre5">arithmetic conversion</strong></a> A conversion from one arithmetic type to another. In the context of the binary arithmetic operators, arithmetic conversions usually attempt to preserve precision by converting a smaller type to a larger type (e.g., integral types are converted to floating point).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1214032" href="039-4.1._fundamentals.html#filepos1001388"><strong class="calibre5">associativity</strong></a> Determines how operators with the same precedence are grouped. Operators can be either right associative (operators are grouped from right to left) or left associative (operators are grouped from left to right).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1214419" href="039-4.1._fundamentals.html#filepos999977"><strong class="calibre5">binary operators</strong></a> Operators that take two operands.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1214631" href="049-4.11._type_conversions.html#filepos1189842"><strong class="calibre5">cast</strong></a> An explicit conversion.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1214821" href="039-4.1._fundamentals.html#filepos1010505"><strong class="calibre5">compound expression</strong></a> An expression involving more than one operator.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1215050" href="049-4.11._type_conversions.html#filepos1191613"><strong class="calibre5">const_cast</strong></a> A cast that converts a low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object to the corresponding non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type or vice versa.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1215444" href="049-4.11._type_conversions.html#filepos1158220"><strong class="calibre5">conversion</strong></a> Process whereby a value of one type is transformed into a value of another type. The language defines conversions among the built-in types. Conversions to and from class types are also possible.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1215811" href="049-4.11._type_conversions.html#filepos1191426"><strong class="calibre5">dynamic_cast</strong></a> Used in combination with inheritance and run-time type identification. See &#167; <a href="178-19.2._runtime_type_identification.html#filepos5158705">19.2</a> (p. <a href="178-19.2._runtime_type_identification.html#filepos5158705">825</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1216138" href="038-chapter_4._expressions.html#filepos998961"><strong class="calibre5">expression</strong></a> The lowest level of computation in a C++ program. Expressions generally apply an operator to one or more operands. Each expression yields a result. Expressions can be used as operands, so we can write compound expressions requiring the evaluation of multiple operators.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1216580" href="049-4.11._type_conversions.html#filepos1159664"><strong class="calibre5">implicit conversion</strong></a> A conversion that is automatically generated by the compiler. Given an expression that needs a particular type but has an operand of a differing type, the compiler will automatically convert the operand to the desired type if an appropriate conversion exists.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1217021"/><a id="filepos1217029" href="049-4.11._type_conversions.html#filepos1163925"><strong class="calibre5">integral promotions</strong></a> conversions that take a smaller integral type to its most closely related larger integral type. Operands of small integral types (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, etc.) are always promoted, even in contexts where such conversions might not seem to be required.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1217583" href="039-4.1._fundamentals.html#filepos1005671"><strong class="calibre5">lvalue</strong></a> An expression that yields an object or function. A non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> lvalue that denotes an object may be the left-hand operand of assignment.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1217948" href="038-chapter_4._expressions.html#filepos998764"><strong class="calibre5">operands</strong></a> Values on which an expression operates. Each operator has one or more operands associated with it.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1218217" href="038-chapter_4._expressions.html#filepos999188"><strong class="calibre5">operator</strong></a> Symbol that determines what action an expression performs. The language defines a set of operators and what those operators mean when applied to values of built-in type. The language also defines the precedence and associativity of each operator and specifies how many operands each operator takes. Operators may be overloaded and applied to values of class type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1218751" href="039-4.1._fundamentals.html#filepos1001511"><strong class="calibre5">order of evaluation</strong></a> Order, if any, in which the operands to an operator are evaluated. In most cases, the compiler is free to evaluate operands in any order. However, the operands are always evaluated before the operator itself is evaluated. Only the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">?:</span></tt></code>, and comma operators specify the order in which their operands are evaluated.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1219449" href="039-4.1._fundamentals.html#filepos1004502"><strong class="calibre5">overloaded operator</strong></a> Version of an operator that is defined for use with a class type. We&#8217;ll see in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a> how to define overloaded versions of operators.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1219802" href="039-4.1._fundamentals.html#filepos1001303"><strong class="calibre5">precedence</strong></a> Defines the order in which different operators in a compound expression are grouped. Operators with higher precedence are grouped more tightly than operators with lower precedence.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1220155" href="039-4.1._fundamentals.html#filepos1003780"><strong class="calibre5">promoted</strong></a> See integral promotions.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1220350" href="049-4.11._type_conversions.html#filepos1191802"><strong class="calibre5">reinterpret_cast</strong></a> Interprets the contents of the operand as a different type. Inherently machine dependent and dangerous.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1220632" href="038-chapter_4._expressions.html#filepos998847"><strong class="calibre5">result</strong></a> Value or object obtained by evaluating an expression.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1220854" href="039-4.1._fundamentals.html#filepos1005560"><strong class="calibre5">rvalue</strong></a> Expression that yields a value but not the associated location, if any, of that value.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1221109" href="041-4.3._logical_and_relational_operators.html#filepos1046144"><strong class="calibre5">short-circuit evaluation</strong></a> Term used to describe how the logical <small class="calibre48">AND</small> and logical <small class="calibre48">OR</small> operators execute. If the first operand to these operators is sufficient to determine the overall result, evaluation stops. We are guaranteed that the second operand is not evaluated.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1221566" href="047-4.9._the_sizeof_operator.html#filepos1142776"><strong class="calibre5">sizeof</strong></a> Operator that returns the size, in bytes, to store an object of a given type name or of the type of a given expression.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1221854" href="049-4.11._type_conversions.html#filepos1191240"><strong class="calibre5">static_cast</strong></a> An explicit request for a well-defined type conversion. Often used to override an implicit conversion that the compiler would otherwise perform.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1222172" href="039-4.1._fundamentals.html#filepos999887"><strong class="calibre5">unary operators</strong></a> Operators that take a single operand.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">,</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> Comma operator. Binary operator that is evaluated left to right. The result of a comma expression is the value of the right-hand operand. The result is an lvalue if and only if that operand is an lvalue.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1222855" href="045-4.7._the_conditional_operator.html#filepos1107697"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">?:</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> Conditional operator. Provides an if-then-else expression of the form</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cond</span></span></tt></span> ?&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">expr1</span></span></tt></span> :&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">expr2</span></span></tt></span>;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre11">If the condition <em class="calibre16">cond</em> is true, then <em class="calibre16">expr1</em> is evaluated. Otherwise, <em class="calibre16">expr2</em> is evaluated. The type <em class="calibre16">expr1</em> and <em class="calibre16">expr2</em> must be the same type or be convertible to a common type. Only one of <em class="calibre16">expr1</em> or <em class="calibre16">expr2</em> is evaluated.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&amp;&amp;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> Logical <small class="calibre48">AND</small> operator. Result is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if both operands are <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The right-hand operand is evaluated <em class="calibre16">only</em> if the left-hand operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1224608" href="046-4.8._the_bitwise_operators.html#filepos1126738"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&amp;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> Bitwise <small class="calibre48">AND</small> operator. Generates a new integral value in which each bit position is 1 if both operands have a 1 in that position; otherwise the bit is 0.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1225081"/><a id="filepos1225089" href="046-4.8._the_bitwise_operators.html#filepos1127406"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">^</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> Bitwise exclusive or operator. Generates a new integral value in which each bit position is 1 if either but not both operands contain a 1 in that bit position; otherwise, the bit is 0.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">||</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> Logical <small class="calibre48">OR</small> operator. Yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if either operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The right-hand operand is evaluated <em class="calibre16">only</em> if the left-hand operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1226189" href="046-4.8._the_bitwise_operators.html#filepos1127068"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">|</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> Bitwise <small class="calibre48">OR</small> operator. Generates a new integral value in which each bit position is 1 if either operand has a 1 in that position; otherwise the bit is 0.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">++</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> The increment operator. The increment operator has two forms, prefix and postfix. Prefix increment yields an lvalue. It adds 1 to the operand and returns the changed value of the operand. Postfix increment yields an rvalue. It adds 1 to the operand and returns a copy of the original, unchanged value of the operand. Note: Iterators have <code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code> even if they do not have the <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">--</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> The decrement operator has two forms, prefix and postfix. Prefix decrement yields an lvalue. It subtracts 1 from the operand and returns the changed value of the operand. Postfix decrement yields an rvalue. It subtracts 1 from the operand and returns a copy of the original, unchanged value of the operand. Note: Iterators have <code class="calibre23"><tt class="calibre23"><span class="calibre24">--</span></tt></code> even if they do not have the <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1228184" href="046-4.8._the_bitwise_operators.html#filepos1123791"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&lt;&lt;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> The left-shift operator. Shifts bits in a (possibly promoted) copy of the value of the left-hand operand to the left. Shifts as many bits as indicated by the right-hand operand. The right-hand operand must be zero or positive and strictly less than the number of bits in the result. Left-hand operand should be <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned;</span></tt></code> if the left-hand operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed</span></tt></code>, it is undefined if a shift causes a different bit to shift into the sign bit.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1229053" href="046-4.8._the_bitwise_operators.html#filepos1124082"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&gt;&gt;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> The right-shift operator. Like the left-shift operator except that bits are shifted to the right. If the left-hand operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed</span></tt></code>, it is implementation defined whether bits shifted into the result are 0 or a copy of the sign bit.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a id="filepos1229657" href="046-4.8._the_bitwise_operators.html#filepos1124838"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">~</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a> Bitwise <small class="calibre48">NOT</small> operator. Generates a new integral value in which each bit is an inverted copy of the corresponding bit in the (possibly promoted) operand.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre11"><a/><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">!</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong> Logical <small class="calibre48">NOT</small> operator. Returns the inverse of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value of its operand. Result is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if operand is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> and vice versa.</p></blockquote><div class="calibre15">&#160;</div>  <div class="mbppagebreak" id="calibre_pb_24"/><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="051-chapter_summary.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="053-chapter_5._statements.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
