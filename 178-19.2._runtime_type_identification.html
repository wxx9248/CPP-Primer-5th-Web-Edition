<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.2. Run-Time Type Identification</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="177-19.1._controlling_memory_allocation.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="179-19.3._enumerations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5158705" class="calibre29"><span class="bold"><a id="filepos5158738" class="calibre2"/>19.2. Run-Time Type Identification</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos5158858" href="186-defined_terms.html#filepos5408238">Run-time type identification</a></strong> (RTTI) is provided through two operators:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operator, which returns the type of a given expression</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> operator, which safely converts a pointer or reference to a base type into a pointer or reference to a derived type</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">When applied to pointers or references to types that have virtual functions, these operators use the dynamic type (&#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>) of the object to which the pointer or reference is bound.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These operators are useful when we have a derived operation that we want to perform through a pointer or reference to a base-class object and it is not possible to make that operation a virtual function. Ordinarily, we should use virtual functions if we can. When the operation is virtual, the compiler automatically selects the right function according to the dynamic type of the object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, it is not always possible to define a virtual. If we cannot use a virtual, we can use one of the RTTI operators. On the other hand, using these operators is more error-prone than using virtual member functions: The programmer must <em class="calibre16">know</em> to which type the object should be cast and must check that the cast was performed successfully.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">RTTI should be used with caution. When possible, it is better to define a virtual function rather than to take over managing the types directly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos5161190" class="calibre37"><span class="calibre5">19.2.1. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">dynamic_cast</span></span></tt></span></span></tt></code> Operator</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5161543" href="186-defined_terms.html#filepos5399838">dynamic_cast</a></span></span></tt></span></span></tt></code> has the following form:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">dynamic_cast&lt;<span><span class="calibre45"><span class="calibre16">type</span></span></span>*&gt;(e)<br class="calibre6"/>dynamic_cast&lt;<span><span class="calibre45"><span class="calibre16">type</span></span></span>&amp;&gt;(e)<br class="calibre6"/>dynamic_cast&lt;<span><span class="calibre45"><span class="calibre16">type</span></span></span>&amp;&amp;&gt;(e)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">type</em> must be a class type and (ordinarily) names a class that has virtual functions. In the first case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> must be a valid pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>); in the second, <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> must be an lvalue; and in the third, <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> must not be an lvalue.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In all cases, the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> must be either a class type that is publicly derived from the target <em class="calibre16">type</em>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> base class of the target <em class="calibre16">type</em>, or the same as the target <em class="calibre16">type</em>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> has one of these types, then the cast will succeed. Otherwise, the cast fails. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> to a pointer type fails, the result is 0. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> to a reference type fails, the operator throws an exception of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_cast</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer-Type <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">dynamic_cast</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As a simple example, assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> is a class with at least one virtual function and that class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> is publicly derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>. If we have a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code>, we can cast it, at run time, to a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5164508"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (Derived *dp = dynamic_cast&lt;Derived*&gt;(bp))<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>} else {&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points at a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code> points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> object, then the cast will initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">dp</span></tt></code> to point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code> points. In this case, it is safe for the code inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> operations. Otherwise, the result of the cast is 0. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">dp</span></tt></code> is 0, the condition in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> fails. In this case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">else</span></tt></code> clause does processing appropriate to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> instead.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We can do a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> on a null pointer; the result is a null pointer of the requested type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">It is worth noting that we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">dp</span></tt></code> inside the condition. By defining the variable in a condition, we do the cast and corresponding check as a single operation. Moreover, the pointer <code class="calibre23"><tt class="calibre23"><span class="calibre24">dp</span></tt></code> is not accessible outside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code>. If the cast fails, then the unbound pointer is not available for use in subsequent code where we might forget to check whether the cast succeeded.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Performing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> in a condition ensures that the cast and test of its result are done in a single expression.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Reference-Type <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">dynamic_cast</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> to a reference type differs from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> to a pointer type in how it signals that an error occurred. Because there is no such thing as a null reference, it is not possible to use the same error-reporting strategy for references that is used for pointers. When a cast to a reference type fails, the cast throws a <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::bad_cast</span></tt></code> exception, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeinfo</span></tt></code> library header.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can rewrite the previous example to use references as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f(const Base &amp;b)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;try {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const Derived &amp;d = dynamic_cast&lt;const Derived&amp;&gt;(b);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">referred</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;} catch (bad_cast) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">handle the fact that the cast failed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 id="filepos5170863" class="calibre37"><span class="calibre5">19.2.2. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">typeid</span></span></tt></span></span></tt></code> Operator</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The second operator provided for RTTI is the <a id="filepos5171166" href="186-defined_terms.html#filepos5409184"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">typeid</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operator allows a program to ask of an expression: What type is your object?</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos5171579"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.3:</strong> Given the following class hierarchy in which each class defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> default constructor and virtual destructor:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class A { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span> */ };<br class="calibre6"/>class B : public A { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };<br class="calibre6"/>class C : public B { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };<br class="calibre6"/>class D : public B, public A { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">which, if any, of the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code>s fail?</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">(a) A *pa = new C;<br class="calibre6"/>&#160;&#160;&#160;&#160;B *pb = dynamic_cast&lt; B* &gt;(pa);<br class="calibre6"/>(b) B *pb = new B;<br class="calibre6"/>&#160;&#160;&#160;&#160;C *pc = dynamic_cast&lt; C* &gt;(pb);<br class="calibre6"/>(c) A *pa = new D;<br class="calibre6"/>&#160;&#160;&#160;&#160;B *pb = dynamic_cast&lt; B* &gt;(pa);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.4:</strong> Using the classes defined in the first exercise, rewrite the following code to convert the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pa</span></tt></code> to the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">C&amp;</span></tt></code>:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (C *pc = dynamic_cast&lt; C* &gt;(pa))<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">C</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s members</span></span></span><br class="calibre6"/>} else {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">A</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s members</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.5:</strong> When should you use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code> instead of a virtual function?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> expression has the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid(e)</span></tt></code> where <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> is any expression or a type name. The result of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operation is a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object of a library type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code>, or a type publicly derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code>. &#167; <a href="178-19.2._runtime_type_identification.html#filepos5195659">19.2.4</a> (p. <a href="178-19.2._runtime_type_identification.html#filepos5195659">831</a>) covers this type in more detail. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> class is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeinfo</span></tt></code> header.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operator can be used with expressions of any type. As usual, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) is ignored, and if the expression is a reference, <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> returns the type to which the reference refers. When applied to an array or function, however, the standard conversion to pointer (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">161</a>) is not done. That is, if we take <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid(a)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> is an array, the result describes an array type, not a pointer type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When the operand is not of class type or is a class without virtual functions, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operator indicates the static type of the operand. When the operand is an lvalue of a class type that defines at least one virtual function, then the type is evaluated at run time.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">typeid</span></span></tt></span></span></tt></code> Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> to compare the types of two expressions or to compare the type of an expression to a specified type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5177714"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Derived *dp = new Derived;<br class="calibre6"/>Base *bp = dp;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">both pointers point to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">compare the type of two objects at run time</span></span></span><br class="calibre6"/>if (typeid(*bp) == typeid(*dp)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to objects of the same type</span></span></span><br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">test whether the run-time type is a specific type</span></span></span><br class="calibre6"/>if (typeid(*bp) == typeid(Derived)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">actually points to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code>, we compare the dynamic types of the objects to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">dp</span></tt></code> point. If both point to the same type, then the condition succeeds. Similarly, the second <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> succeeds if <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code> currently points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Note that the operands to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> are objects&#8212;we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">*bp</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">test always fails: the type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>if (typeid(bp) == typeid(Derived)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">code never executed</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This condition compares the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base*</span></tt></code> to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>. Although the pointer <em class="calibre16">points</em> at an object of class type that has virtual functions, the pointer <em class="calibre16">itself</em> is not a class-type object. The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base*</span></tt></code> can be, and is, evaluated at compile time. That type is unequal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>, so the condition will always fail <em class="calibre16">regardless of the type of the object to which</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">bp</span></tt></code>
<em class="calibre16">points.</em></p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> of a pointer (as opposed to the object to which the pointer points) returns the static, compile-time type of the pointer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> requires a run-time check determines whether the expression is evaluated. The compiler evaluates the expression only if the type has virtual functions. If the type has no virtuals, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> returns the static type of the expression; the compiler knows the static type without evaluating the expression.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If the dynamic type of the expression might differ from the static type, then the expression must be evaluated (at run time) to determine the resulting type. The distinction matters when we evaluate <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid(*p)</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a pointer to a type that does not have virtual functions, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> does not need to be a valid pointer. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">*p</span></tt></code> is evaluated at run time, in which case <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> must be a valid pointer. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a null pointer, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid(*p)</span></tt></code> throws a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_typeid</span></tt></code> exception.</p><div class="calibre22">&#160;</div>
<h4 id="filepos5183811" class="calibre37"><span class="calibre5">19.2.3. Using RTTI</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As an example of when RTTI might be useful, consider a class hierarchy for which we&#8217;d like to implement the equality operator (&#167; <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">14.3.1</a>, p. <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">561</a>). Two objects are equal if they have the same type and same value for a given set of their data members. Each derived type may add its own data, which we will want to include when we test for equality.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos5184399"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.6:</strong> Write an expression to dynamically cast a pointer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> to a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> (&#167; <a href="150-15.9._text_queries_revisited.html#filepos4058655">15.9.1</a>, p. <a href="150-15.9._text_queries_revisited.html#filepos4058655">636</a>). Test the cast by using objects of <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code> and of another query type. Print a statement indicating whether the cast works and be sure that the output matches your expectations.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.7:</strong> Write the same cast, but cast a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> object to a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code>. Repeat the test to ensure that your cast works correctly.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.8:</strong> Write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> expression to see whether two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Query_base</span></tt></code> pointers point to the same type. Now check whether that type is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">AndQuery</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">We might think we could solve this problem by defining a set of virtual functions that would perform the equality test at each level in the hierarchy. Given those virtuals, we would define a single equality operator that operates on references to the base type. That operator could delegate its work to a virtual <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> operation that would do the real work.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Unfortunately, this strategy doesn&#8217;t quite work. Virtual functions must have the same parameter type(s) in both the base and derived classes (&#167; <a href="144-15.3._virtual_functions.html#filepos3853256">15.3</a>, p. <a href="144-15.3._virtual_functions.html#filepos3853256">605</a>). If we wanted to define a virtual <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> function, that function must have a parameter that is a reference to the base class. If the parameter is a reference to base, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> function could use only members from the base class. <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> would have no way to compare members that are in the derived class but not in the base.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can write our equality operation by realizing that the equality operator ought to return <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> if we attempt to compare objects of differing type. For example, if we try to compare a object of the base-class type with an object of a derived type, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator should return <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Given this observation, we can now see that we can use RTTI to solve our problem. We&#8217;ll define an equality operator whose parameters are references to the base-class type. The equality operator will use <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> to verify that the operands have the same type. If the operands differ, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> will return <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. Otherwise, it will call a virtual <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> function. Each class will define <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> to compare the data elements of its own type. These operators will take a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base&amp;</span></tt></code> parameter but will cast the operand to its own type before doing the comparison.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Class Hierarchy</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To make the concept a bit more concrete, we&#8217;ll define the following classes:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend bool operator==(const Base&amp;, const Base&amp;);<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">interface members for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual bool equal(const Base&amp;) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">data and other implementation members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>};<br class="calibre6"/><a/>class Derived: public Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other interface members for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span><br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;bool equal(const Base&amp;) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">data and other implementation members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Type-Sensitive Equality Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Next let&#8217;s look at how we might define the overall equality operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool operator==(const Base &amp;lhs, const Base &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">typeid</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">are different; otherwise makes a virtual call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">equal</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return typeid(lhs) == typeid(rhs) &amp;&amp; lhs.equal(rhs);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This operator returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> if the operands are different types. If they are the same type, then it delegates the real work of comparing the operands to the (virtual) <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> function. If the operands are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> objects, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base::equal</span></tt></code> will be called. If they are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> objects, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived::equal</span></tt></code> is called.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Virtual <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal</span></span></tt></span></span></tt></code> Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Each class in the hierarchy must define its own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code>. All of the functions in the derived classes will start the same way: They&#8217;ll cast their argument to the type of the class itself:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool Derived::equal(const Base &amp;rhs) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we know the types are equal, so the cast won't throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto r = dynamic_cast&lt;const Derived&amp;&gt;(rhs);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do the work to compare two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">objects and return the result</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The cast should always succeed&#8212;after all, the function is called from the equality operator only after testing that the two operands are the same type. However, the cast is necessary so that the function can access the derived members of the right-hand operand.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Base-Class <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">This operation is a bit simpler than the others:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool Base::equal(const Base &amp;rhs) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do whatever is required to compare to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">objects</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There is no need to cast the parameter before using it. Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> and the parameter are <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> objects, so all the operations available for this object are also defined for the parameter type.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5195659" class="calibre37"><span class="calibre5"><a id="filepos5195692"/>19.2.4. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">type_info</span></span></tt></span></span></tt></code> Class</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The exact definition of the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5196040" href="186-defined_terms.html#filepos5409937">type_info</a></span></span></tt></span></span></tt></code> class varies by compiler. However, the standard guarantees that the class will be defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeinfo</span></tt></code> header and that the class will provide at least the operations listed in <a href="178-19.2._runtime_type_identification.html#filepos5196487">Table 19.1</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos5196487"/>Table 19.1. Operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">type_info</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00136.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The class also provides a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> virtual destructor, because it is intended to serve as a base class. When a compiler wants to provide additional type information, it normally does so in a class derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">There is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> default constructor, and the copy and move constructors and the assignment operators are all defined as deleted (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">507</a>). Therefore, we cannot define, copy, or assign objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code>. The only way to create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> object is through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> operator.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">name</span></tt></code> member function returns a C-style character string for the name of the type represented by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> object. The value used for a given type depends on the compiler and in particular is not required to match the type names as used in a program. The only guarantee we have about the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">name</span></tt></code> is that it returns a unique string for each type. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int arr[10];<br class="calibre6"/>Derived d;<br class="calibre6"/>Base *p = &amp;d;<br class="calibre6"/>cout &lt;&lt; typeid(42).name() &lt;&lt; ", "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; typeid(arr).name() &lt;&lt; ", "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; typeid(Sales_data).name() &lt;&lt; ", "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; typeid(std::string).name() &lt;&lt; ", "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; typeid(p).name() &lt;&lt; ", "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; typeid(*p).name() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">This program, when executed on our machine, generates the following output:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">i, A10_i, 10Sales_data, Ss, P4Base, 7Derived</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> class varies by compiler. Some compilers provide additional member functions that provide additional information about types used in a program. You should consult the reference manual for your compiler to understand the exact <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_info</span></tt></code> support provided.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos5200560"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.9:</strong> Write a program similar to the last one in this section to print the names your compiler uses for common type names. If your compiler gives output similar to ours, write a function that will translate those strings to more human-friendly form.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.10:</strong> Given the following class hierarchy in which each class defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> default constructor and virtual destructor, which type name do the following statements print?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class A { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };<br class="calibre6"/>class B : public A { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };<br class="calibre6"/>class C : public B { /* <span><span class="calibre45"><span class="calibre16">. . .</span></span></span>&#160;&#160;*/ };<br class="calibre6"/><br class="calibre6"/>(a) A *pa = new C;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; typeid(pa).name() &lt;&lt; endl;<br class="calibre6"/>(b) C cobj;<br class="calibre6"/>&#160;&#160;&#160;&#160;A&amp; ra = cobj;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; typeid(&amp;ra).name() &lt;&lt; endl;<br class="calibre6"/>(c) B *px = new B;<br class="calibre6"/>&#160;&#160;&#160;&#160;A&amp; ra = *px;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; typeid(ra).name() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="177-19.1._controlling_memory_allocation.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="179-19.3._enumerations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
