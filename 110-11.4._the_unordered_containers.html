<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>11.4. The Unordered Containers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="109-11.3._operations_on_associative_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="111-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2872751" class="calibre29"><span class="bold">11.4. The Unordered Containers</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">The new standard defines four <strong class="calibre5"><a id="filepos2872982" href="112-defined_terms.html#filepos2896103">unordered associative containers</a></strong>. Rather than using a comparison operation to organize their elements, these containers use a <strong class="calibre5"><em class="calibre16"><a id="filepos2873173" href="112-defined_terms.html#filepos2891482">hash function</a></em></strong> and the key type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator. An unordered container is most useful when we have a key type for which there is no obvious ordering relationship among the elements. These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2873645"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Although hashing gives better average case performance in principle, achieving good results in practice often requires a fair bit of performance testing and tweaking. As a result, it is usually easier (and often yields better performance) to use an ordered container.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos2874086"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Use an unordered container if the key type is inherently unordered or if performance testing reveals problems that hashing might solve.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using an Unordered Container</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Aside from operations that manage the hashing, the unordered containers provide the same operations <code class="calibre23"><tt class="calibre23"><span class="calibre24">(find, insert</span></tt></code>, and so on) as the ordered containers. That means that the operations we&#8217;ve used on <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> apply to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_set</span></tt></code> as well. Similarly for the unordered versions of the containers that allow multiple keys.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As a result, we can usually use an unordered container in place of the corresponding ordered container, and vice versa. However, because the elements are not stored in order, the output of a program that uses an unordered container will (ordinarily) differ from the same program using an ordered container.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, we can rewrite our original word-counting program from &#167; <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a> (p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>) to use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">count occurrences, but the words won't be in alphabetical order</span></span></span><br class="calibre6"/>unordered_map&lt;string, size_t&gt; word_count;<br class="calibre6"/>string word;<br class="calibre6"/>while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;&#160;&#160;++word_count[word]; // <span><span class="calibre45"><span class="calibre16">fetch and increment the counter for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word</span></span></tt></span><br class="calibre6"/>for (const auto &amp;w : word_count) // <span><span class="calibre45"><span class="calibre16">for each element in the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">map</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the results</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;cout &lt;&lt;&#160;&#160;w.first &lt;&lt; " occurs " &lt;&lt; w.second<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ((w.second &gt; 1) ? " times" : " time") &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">word_count</span></tt></code> is the only difference between this program and our original. If we run this version on the same input as our original program,</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">containers. occurs 1 time</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">use occurs 1 time</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">can occurs 1 time</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">examples occurs 1 time</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">...</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">we&#8217;ll obtain the same count for each word in the input. However, the output is unlikely to be in alphabetical order.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Managing the Buckets</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. These containers use a hash function to map elements to buckets. To access an element, the container first computes the element&#8217;s hash code, which tells which bucket to search. The container puts all of its elements with a given hash value into the same bucket. If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2879142"/>The hash function must always yield the same result when called with the same argument. Ideally, the hash function also maps each particular value to a unique bucket. However, a hash function is allowed to map elements with differing keys to the same bucket. When a bucket holds several elements, those elements are searched sequentially to find the one we want. Typically, computing an element&#8217;s hash code and finding its bucket is a fast operation. However, if the bucket has many elements, many comparisons may be needed to find a particular element.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The unordered containers provide a set of functions, listed in <a href="110-11.4._the_unordered_containers.html#filepos2880096">Table 11.8</a>, that let us manage the buckets. These members let us inquire about the state of the container and force the container to reorganize itself as needed.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2880096"/>Table 11.8. Unordered Container Management Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00087.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Requirements on Key Type for Unordered Containers</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">By default, the unordered containers use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator on the key type to compare elements. They also use an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash&lt;key_type&gt;</span></tt></code> to generate the hash code for each element. The library supplies versions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2880865" href="112-defined_terms.html#filepos2891215">hash</a></span></span></tt></span></span></tt></code> template for the built-in types, including pointers. It also defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> for some of the library types, including <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s and the smart pointer types that we will describe in <a href="113-chapter_12._dynamic_memory.html#filepos2900383">Chapter 12</a>. Thus, we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, or a smart pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">However, we cannot directly define an unordered container that uses a our own class types for its key type. Unlike the containers, we cannot use the hash template directly. Instead, we must supply our own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> template. We&#8217;ll see how to do so in &#167; <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a> (p. <a href="158-16.5._template_specializations.html#filepos4508634">709</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Instead of using the default <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code>, we can use a strategy similar to the one we used to override the default comparison operation on keys for the ordered <a id="filepos2882262"/>containers (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). To use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> as the key, we&#8217;ll need to supply functions to replace both the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator and to calculate a hash code. We&#8217;ll start by defining these functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">size_t hasher(const Sales_data &amp;sd)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return hash&lt;string&gt;()(sd.isbn());<br class="calibre6"/>}<br class="calibre6"/>bool eqOp(const Sales_data &amp;lhs, const Sales_data &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return lhs.isbn() == rhs.isbn();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasher</span></tt></code> function uses an object of the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">hash</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> type to generate a hash code from the <small class="calibre48">ISBN</small> member. Similarly, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">eqOp</span></tt></code> funciton compares two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects by comparing their <small class="calibre48">ISBN</small>s.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use these functions to define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_multiset</span></tt></code> as follows</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using SD_multiset = unordered_multiset&lt;Sales_data,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;decltype(hasher)*, decltype(eqOp)*&gt;;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">arguments are the bucket size and pointers to the hash function and equality operator</span></span></span><br class="calibre6"/>SD_multiset bookstore(42, hasher, eqOp);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To simplify the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookstore</span></tt></code> we first define a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) for an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_multiset</span></tt></code> whose hash and equality operations have the same types as our <code class="calibre23"><tt class="calibre23"><span class="calibre24">hasher</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">eqOp</span></tt></code> functions. Using that type, we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookstore</span></tt></code> passing pointers to the functions we want <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookstore</span></tt></code> to use.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If our class has its own <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator we can override just the hash function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">FooHash</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to generate the hash code;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Foo</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must have an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">==</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operator</span></span></span><br class="calibre6"/>unordered_set&lt;Foo, decltype(FooHash)*&gt; fooSet(10, FooHash);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 11.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.37:</strong> What are the advantages of an unordered container as compared to the ordered version of that container? What are the advantages of the ordered version?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 11.38:</strong> Rewrite the word-counting (&#167; <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a>, p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>) and word-transformation (&#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2854545">11.3.6</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2854545">440</a>) programs to use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unordered_map</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="109-11.3._operations_on_associative_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="111-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
