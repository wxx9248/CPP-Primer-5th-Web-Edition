<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>7.4. Class Scope</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="075-7.3._additional_class_features.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="077-7.5._constructors_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1923787" class="calibre29"><span class="bold">7.4. Class Scope</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Every class defines its own new scope. Outside the class scope, ordinary data and function members may be accessed only through an object, a reference, or a pointer using a member access operator (&#167; <a href="044-4.6._the_member_access_operators.html#filepos1101794">4.6</a>, p. <a href="044-4.6._the_member_access_operators.html#filepos1101794">150</a>). We access type members from the class using the scope operator . In either case, the name that follows the operator must be a member of the associated class.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen::pos ht = 24, wd = 80; // <span><span class="calibre45"><span class="calibre16">use the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pos</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type defined by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>Screen scr(ht, wd, ' ');<br class="calibre6"/>Screen *p = &amp;scr;<br class="calibre6"/>char c = scr.get(); // <span><span class="calibre45"><span class="calibre16">fetches the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member from the object</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">scr</span></span></tt></span><br class="calibre6"/>c = p-&gt;get();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">fetches the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member from the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Scope and Members Defined outside the Class</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that a class is a scope explains why we must provide the class name as well as the function name when we define a member function outside its class (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">259</a>). Outside of the class, the names of the members are hidden.</p><div class="calibre15">&#160;</div>
<p class="calibre14">Once the class name is seen, the remainder of the definition&#8212;including the parameter list and the function body&#8212;is in the scope of the class. As a result, we can refer to other class members without qualification.</p><div class="calibre15">&#160;</div>
<p class="calibre14">For example, recall the <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> member of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> (&#167; <a href="075-7.3._additional_class_features.html#filepos1906774">7.3.4</a>, p. <a href="075-7.3._additional_class_features.html#filepos1906774">280</a>). That function&#8217;s parameter uses a type that is defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void Window_mgr::clear(ScreenIndex i)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;s = screens[i];<br class="calibre6"/>&#160;&#160;&#160;&#160;s.contents = string(s.height * s.width, ' ');<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the compiler sees the parameter list after noting that we are in the scope of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">WindowMgr</span></tt></code>, there is no need to specify that we want the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ScreenIndex</span></tt></code>
<a id="filepos1927885"/>that is defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">WindowMgr</span></tt></code>. For the same reason, the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">screens</span></tt></code> in the function body refers to name declared inside class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">On the other hand, the return type of a function normally appears before the function&#8217;s name. When a member function is defined outside the class body, any name used in the return type is outside the class scope. As a result, the return type must specify the class of which it is a member. For example, we might give <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> a function, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">addScreen</span></tt></code>, to add another screen to the display. This member will return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">ScreenIndex</span></tt></code> value that the user can subsequently use to locate this <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Window_mgr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">add a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the window and returns its index</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ScreenIndex addScreen(const Screen&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">return type is seen before we're in the scope of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Window_mgr</span></span></tt></span><br class="calibre6"/>Window_mgr::ScreenIndex<br class="calibre6"/>Window_mgr::addScreen(const Screen &amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;screens.push_back(s);<br class="calibre6"/>&#160;&#160;&#160;&#160;return screens.size() - 1;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the return type appears before the name of the class is seen, it appears outside the scope of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>. To use <code class="calibre23"><tt class="calibre23"><span class="calibre24">ScreenIndex</span></tt></code> for the return type, we must specify the class in which that type is defined.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.33:</strong> What would happen if we gave <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> member defined as follows? Fix any problems you identify.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pos Screen::size() const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return height * width;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1931587" class="calibre37"><span class="calibre5">7.4.1. Name Lookup and Class Scope</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">In the programs we&#8217;ve written so far, <strong class="calibre5"><a id="filepos1931835" href="080-defined_terms.html#filepos2064170">name lookup</a></strong> (the process of finding which declarations match the use of a name) has been relatively straightforward:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; First, look for a declaration of the name in the block in which the name was used. Only names declared before the use are considered.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the name isn&#8217;t found, look in the enclosing scope(s).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If no declaration is found, then the program is in error.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1932618"/>The way names are resolved inside member functions defined inside the class may seem to behave differently than these lookup rules. However, in this case, appearances are deceiving. Class definitions are processed in two phases:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; First, the member declarations are compiled.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Function bodies are compiled only after the entire class has been seen.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Member function definitions are processed <em class="calibre16">after</em> the compiler processes all of the declarations in the class.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Classes are processed in this two-phase way to make it easier to organize class code. Because member function bodies are not processed until the entire class is seen, they can use any name defined inside the class. If function definitions were processed at the same time as the member declarations, then we would have to order the member functions so that they referred only to names already seen.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Name Lookup for Class Member Declarations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">This two-step process applies only to names used in the body of a member function. Names used in declarations, including names used for the return type and types in the parameter list, must be seen before they are used. If a member declaration uses a name that has not yet been seen inside the class, the compiler will look for that name in the scope(s) in which the class is defined. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef double Money;<br class="calibre6"/>string bal;<br class="calibre6"/>class Account {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Money balance() { return bal; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;Money bal;<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler sees the declaration of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">balance</span></tt></code> function, it will look for a declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Money</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> class. The compiler considers only declarations inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> that appear before the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Money</span></tt></code>. Because no matching member is found, the compiler then looks for a declaration in the enclosing scope(s). In this example, the compiler will find the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Money</span></tt></code>. That type will be used for the return type of the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">balance</span></tt></code> and as the type for the data member <code class="calibre23"><tt class="calibre23"><span class="calibre24">bal</span></tt></code>. On the other hand, the function body of <code class="calibre23"><tt class="calibre23"><span class="calibre24">balance</span></tt></code> is processed only after the entire class is seen. Thus, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> inside that function returns the member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">bal</span></tt></code>, not the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> from the outer scope.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Type Names Are Special</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, an inner scope can redefine a name from an outer scope even if that name has already been used in the inner scope. However, in a class, if a member <a id="filepos1937046"/>uses a name from an outer scope and that name is a type, then the class may not subsequently redefine that name:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef double Money;<br class="calibre6"/>class Account {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Money balance() { return bal; }&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Money</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the outer scope</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef double Money; // <span><span class="calibre45"><span class="calibre16">error: cannot redefine</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Money</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Money bal;<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">It is worth noting that even though the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Money</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">Account</span></tt></code> uses the same type as the definition in the outer scope, this code is still in error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although it is an error to redefine a type name, compilers are not required to diagnose this error. Some compilers will quietly accept such code, even though the program is in error.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Definitions of type names usually should appear at the beginning of a class. That way any member that uses that type will be seen after the type name has already been defined.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Normal Block-Scope Name Lookup inside Member Definitions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A name used in the body of a member function is resolved as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; First, look for a declaration of the name inside the member function. As usual, only declarations in the function body that precede the use of the name are considered.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the declaration is not found inside the member function, look for a declaration inside the class. All the members of the class are considered.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If a declaration for the name is not found in the class, look for a declaration that is in scope before the member function definition.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">Ordinarily, it is a bad idea to use the name of another member as the name for a parameter in a member function. However, in order to show how names are resolved, we&#8217;ll violate that normal practice in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">dummy_fcn</span></tt></code> function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">note: this code is for illustration purposes only and reflects bad practice</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">it is generally a bad idea to use the same name for a parameter and a member</span></span></span><br class="calibre6"/>int height;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defines a name subsequently used inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::string::size_type pos;<br class="calibre6"/>&#160;&#160;&#160;&#160;void dummy_fcn(pos height) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cursor = width * height; // <span><span class="calibre45"><span class="calibre16">which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height?</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">the parameter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/><a id="filepos1941825"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;pos cursor = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;pos height = 0, width = 0;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When the compiler processes the multiplication expression inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">dummy_fcn</span></tt></code>, it first looks for the names used in that expression in the scope of that function. A function&#8217;s parameters are in the function&#8217;s scope. Thus, the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code>, used in the body of <code class="calibre23"><tt class="calibre23"><span class="calibre24">dummy_fcn</span></tt></code>, refers to this parameter declaration.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code> parameter hides the member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code>. If we wanted to override the normal lookup rules, we can do so:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">bad practice: names local to member functions shouldn't hide member names</span></span></span><br class="calibre6"/>void Screen::dummy_fcn(pos height) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cursor = width * this-&gt;height;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">alternative way to indicate the member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cursor = width * Screen::height; // <span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Even though the class member is hidden, it is still possible to use that member by qualifying the member&#8217;s name with the name of its class or by using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer explicitly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A much better way to ensure that we get the member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code> would be to give the parameter a different name:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">good practice: don't use a member name for a parameter or other local variable</span></span></span><br class="calibre6"/>void Screen::dummy_fcn(pos ht) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cursor = width * height;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, when the compiler looks for the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code>, it won&#8217;t be found inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">dummy_fcn</span></tt></code>. The compiler next looks at all the declarations in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Even though the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code> appears after its use inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">dummy_fcn</span></tt></code>, the compiler resolves this use to the data member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">After Class Scope, Look in the Surrounding Scope</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If the compiler doesn&#8217;t find the name in function or class scope, it looks for the name in the surrounding scope. In our example, the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code> is defined in the outer scope before the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. However, the object in the outer scope is hidden by our member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code>. If we want the name from the outer scope, we can ask for it explicitly using the scope operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">bad practice: don't hide names that are needed from surrounding scopes</span></span></span><br class="calibre6"/>void Screen::dummy_fcn(pos height) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cursor = width * ::height;// <span><span class="calibre45"><span class="calibre16">which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height?</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">the global one</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Even though the outer object is hidden, it is still possible to access that object by using the scope operator.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1948166"/>Names Are Resolved Where They Appear within a File</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a member is defined outside its class, the third step of name lookup includes names declared in the scope of the member definition as well as those that appear in the scope of the class definition. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int height;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defines a name subsequently used inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::string::size_type pos;<br class="calibre6"/>&#160;&#160;&#160;&#160;void setHeight(pos);<br class="calibre6"/>&#160;&#160;&#160;&#160;pos height = 0;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides the declaration of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the outer scope</span></span></span><br class="calibre6"/>};<br class="calibre6"/>Screen::pos verify(Screen::pos);<br class="calibre6"/>void Screen::setHeight(pos var) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">var</span></span></tt></span><span><span class="calibre45"><span class="calibre16">: refers to the parameter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">height</span></span></tt></span><span><span class="calibre45"><span class="calibre16">: refers to the class member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">verify</span></span></tt></span><span><span class="calibre45"><span class="calibre16">: refers to the global function</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;height = verify(var);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Notice that the declaration of the global function <code class="calibre23"><tt class="calibre23"><span class="calibre24">verify</span></tt></code> is not visible before the definition of the class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. However, the third step of name lookup includes the scope in which the member definition appears. In this example, the declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">verify</span></tt></code> appears before <code class="calibre23"><tt class="calibre23"><span class="calibre24">setHeight</span></tt></code> is defined and may, therefore, be used.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.4.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.34:</strong> What would happen if we put the <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class on page <a href="076-7.4._class_scope.html#filepos1937046">285</a> as the last line in the class?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.35:</strong> Explain the following code, indicating which definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Type</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">initVal</span></tt></code> is used for each use of those names. Say how you would fix any errors.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef string Type;<br class="calibre6"/>Type initVal();<br class="calibre6"/>class Exercise {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef double Type;<br class="calibre6"/>&#160;&#160;&#160;&#160;Type setVal(Type);<br class="calibre6"/>&#160;&#160;&#160;&#160;Type initVal();<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;int val;<br class="calibre6"/>};<br class="calibre6"/>Type Exercise::setVal(Type parm) {<br class="calibre6"/>&#160;&#160;&#160;&#160;val = parm + initVal();<br class="calibre6"/>&#160;&#160;&#160;&#160;return val;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="075-7.3._additional_class_features.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="077-7.5._constructors_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
