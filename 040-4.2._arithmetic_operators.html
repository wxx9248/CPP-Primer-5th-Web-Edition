<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.2. Arithmetic Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="039-4.1._fundamentals.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="041-4.3._logical_and_relational_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1028232" class="calibre29"><span class="bold">4.2. Arithmetic Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14"><a href="040-4.2._arithmetic_operators.html#filepos1028961">Table 4.1</a> (and the operator tables in subsequent sections) groups the operators by their precedence. The unary arithmetic operators have higher precedence than the multiplication and division operators, which in turn have higher precedence than the binary addition and subtraction operators. Operators of higher precedence group more tightly than do operators with lower precedence. These operators are all left associative, meaning that they group left to right when the precedence levels are the same.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos1028961"/>Table 4.1. Arithmetic Operators (Left Associative)</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00030.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Unless noted otherwise, the arithmetic operators may be applied to any of the arithmetic types (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">32</a>) or to any type that can be converted to an arithmetic type. The operands and results of these operators are rvalues. As described in &#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a> (p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>), operands of small integral types are promoted to a larger integral type, and all operands may be converted to a common type as part of evaluating these operators.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The unary plus operator and the addition and subtraction operators may also be applied to pointers. &#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a> (p. <a href="034-3.5._arrays.html#filepos881970">119</a>) covered the use of binary <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code> with <a id="filepos1030127"/>pointer operands. When applied to a pointer or arithmetic value, unary plus returns a (possibly promoted) copy of the value of its operand.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The unary minus operator returns the result of negating a (possibly promoted) copy of the value of its operand:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 1024;<br class="calibre6"/>int k = -i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-1024</span></span></tt></span><br class="calibre6"/>bool b = true;<br class="calibre6"/>bool b2 = -b; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true!</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In &#167; <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">34</a>) we noted that <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> values should not be used for computation. The result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">-b</span></tt></code> is a good example of what we had in mind.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For most operators, operands of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> are promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. In this case, the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>, which promotes to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code> (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>). That (promoted) value is negated, yielding <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code>. The value <code class="calibre23"><tt class="calibre23"><span class="calibre24">-1</span></tt></code> is converted back to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> and used to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code>. This initializer is a nonzero value, which when converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. Thus, the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>!</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Overflow and Other Arithmetic Exceptions</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some arithmetic expressions yield undefined results. Some of these undefined expressions are due to the nature of mathematics&#8212;for example, division by zero. Others are undefined due to the nature of computers&#8212;for example, due to overflow. Overflow happens when a value is computed that is outside the range of values that the type can represent.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Consider a machine on which <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>s are 16 bits. In that case, the maximum <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code> is 32767. On such a machine, the following compound assignment overflows:</p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">short short_value = 32767; // <span><span class="calibre45"><span class="calibre16">max value if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shorts</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are 16 bits</span></span></span><br class="calibre6"/>short_value += 1; // <span><span class="calibre45"><span class="calibre16">this calculation overflows</span></span></span><br class="calibre6"/>cout &lt;&lt; "short_value: " &lt;&lt; short_value &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The assignment to <code class="calibre23"><tt class="calibre23"><span class="calibre24">short_value</span></tt></code> is undefined. Representing a signed value of 32768 requires 17 bits, but only 16 are available. On many systems, there is <em class="calibre16">no</em> compile-time or run-time warning when an overflow occurs. As with any undefined behavior, what happens is unpredictable. On our system the program completes and writes</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">short_value: -32768</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The value &#8220;wrapped around&#8221;: The sign bit, which had been 0, was set to 1, resulting in a negative value. On another system, the result might be different, or the program might behave differently, including crashing entirely.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">When applied to objects of arithmetic types, the arithmetic operators, <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">/</span></tt></code>, have their obvious meanings: addition, subtraction, multiplication, and division. Division between integers returns an integer. If the quotient contains a fractional part, it is truncated toward zero:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival1 = 21/6;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">result is truncated; remainder is discarded</span></span></span><br class="calibre6"/>int ival2 = 21/7;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">3</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">no remainder; result is an integral value</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos1037329"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre24">%</span></tt></code> operator, known as the &#8220;remainder&#8221; or the &#8220;modulus&#8221; operator, computes the remainder that results from dividing the left-hand operand by the right-hand operand. The operands to <code class="calibre23"><tt class="calibre23"><span class="calibre24">%</span></tt></code> must have integral type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 42;<br class="calibre6"/>double dval = 3.14;<br class="calibre6"/>ival % 12;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: result is 6</span></span></span><br class="calibre6"/>ival % dval; // <span><span class="calibre45"><span class="calibre16">error: floating-point operand</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">In a division, a nonzero quotient is positive if the operands have the same sign and negative otherwise. Earlier versions of the language permitted a negative quotient to be rounded up or down; the new standard requires the quotient to be rounded toward zero (i.e., truncated).</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos1038636"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">The modulus operator is defined so that if <code class="calibre23"><tt class="calibre23"><span class="calibre24">m</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> are integers and <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> is nonzero, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">(m/n)*n + m%n</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">m</span></tt></code>. By implication, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">m%n</span></tt></code> is nonzero, it has the same sign as <code class="calibre23"><tt class="calibre23"><span class="calibre24">m</span></tt></code>. Earlier versions of the language permitted <code class="calibre23"><tt class="calibre23"><span class="calibre24">m%n</span></tt></code> to have the same sign as <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> on implementations in which negative <code class="calibre23"><tt class="calibre23"><span class="calibre24">m/n</span></tt></code> was rounded away from zero, but such implementations are now prohibited. Moreover, except for the obscure case where <code class="calibre23"><tt class="calibre23"><span class="calibre24">-m</span></tt></code> overflows, <code class="calibre23"><tt class="calibre23"><span class="calibre24">(-m)/n</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">m/(-n)</span></tt></code> are always equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">-(m/n)</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">m%(-n)</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">m%n</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">(-m)%n</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">-(m%n)</span></tt></code>. More concretely:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"> &#160;21 % 6;&#160;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 3</span></span></span>&#160;&#160;*/&#160;&#160;&#160;&#160;&#160;&#160;21 / 6;&#160;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 3</span></span></span>&#160;&#160;&#160;*/<br class="calibre6"/>&#160;21 % 7;&#160;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 0</span></span></span>&#160;&#160;*/&#160;&#160;&#160;&#160;&#160;&#160;21 / 7;&#160;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 3</span></span></span>&#160;&#160;&#160;*/<br class="calibre6"/>-21 % -8;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is&#160;&#160;-5</span></span></span> */&#160;&#160;&#160;&#160;&#160;-21 / -8;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 2</span></span></span>&#160;&#160;&#160;*/<br class="calibre6"/>&#160;21 % -5;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is 1</span></span></span>&#160;&#160;*/&#160;&#160;&#160;&#160;&#160;&#160;21 / -5;&#160;&#160;/*&#160;&#160;<span><span class="calibre45"><span class="calibre16">result is&#160;&#160;-4</span></span></span>&#160;&#160;*/</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.4:</strong> Parenthesize the following expression to show how it is evaluated. Test your answer by compiling the expression (without parentheses) and printing its result.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">12 / 3 * 4 + 5 * 15 + 24 % 4 / 2</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.5:</strong> Determine the result of the following expressions.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">-30 * 3 + 21 / 5</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">-30 + 3 * 21 / 5</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">30 / 3 * 21 % 5</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">-30 / 3 * 21 % 4</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.6:</strong> Write an expression to determine whether an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value is even or odd.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.7:</strong> What does overflow mean? Show three expressions that will overflow.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="039-4.1._fundamentals.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="041-4.3._logical_and_relational_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
