<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.6. Class Scope under Inheritance</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="146-15.5._access_control_and_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="148-15.7._constructors_and_copy_control.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3941072" class="calibre29"><span class="bold"><a id="filepos3941105" class="calibre2"/>15.6. Class Scope under Inheritance</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Each class defines its own scope (&#167;<a href="076-7.4._class_scope.html#filepos1923787">7.4</a>, p. <a href="076-7.4._class_scope.html#filepos1923787">282</a>) within which its members are defined. Under inheritance, the scope of a derived class is nested (&#167;<a href="022-2.2._variables.html#filepos382972">2.2.4</a>, p. <a href="022-2.2._variables.html#filepos382972">48</a>) inside the scope of its base classes. If a name is unresolved within the scope of the derived class, the enclosing base-class scopes are searched for a definition of that name.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fact that the scope of a derived class nests inside the scope of its base classes can be surprising. After all, the base and derived classes are defined in separate parts of our program&#8217;s text. However, it is this hierarchical nesting of class scopes that allows the members of a derived class to use members of its base class as if those members were part of the derived class. For example, when we write</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Bulk_quote bulk;<br class="calibre6"/>cout &lt;&lt; bulk.isbn();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the use of the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> is resolved as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Because we called <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> on an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>, the search starts in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> class. The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> is not found in that class.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> is derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> class is searched next. The name is still not found.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> is derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class is searched next. The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> is found in that class; the use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> is resolved to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Name Lookup Happens at Compile Time</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The static type (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>) of an object, reference, or pointer determines which members of that object are visible. Even when the static and dynamic types might differ (as can happen when a reference or pointer to a base class is used), the static type determines what members can be used. As an example, we might add a member to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> class that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167;<a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) holding the minimum (or maximum) quantity and the discounted price:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Disc_quote : public Quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::pair&lt;size_t, double&gt; discount_policy() const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return {quantity, discount}; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount_policy</span></tt></code> only through an object, pointer, or reference of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> or of a class derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Bulk_quote bulk;<br class="calibre6"/>Bulk_quote *bulkP = &amp;bulk; //&#160;&#160;<span><span class="calibre45"><span class="calibre16">static and dynamic types are the same</span></span></span><br class="calibre6"/>Quote *itemP = &amp;bulk;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">static and dynamic types differ</span></span></span><br class="calibre6"/>bulkP-&gt;discount_policy();&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bulkP</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><span class="calibre45"><span class="calibre16">type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote*</span></span></tt></span><br class="calibre6"/>itemP-&gt;discount_policy();&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">itemP</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote*</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3947510"/>Even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">bulk</span></tt></code> has a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount_policy</span></tt></code>, that member is not visible through <code class="calibre23"><tt class="calibre23"><span class="calibre24">itemP</span></tt></code>. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">itemP</span></tt></code> is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>, which means that the search for <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount_policy</span></tt></code> starts in class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class has no member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount_policy</span></tt></code>, so we cannot call that member on an object, reference, or pointer of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Name Collisions and Inheritance</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Like any other scope, a derived class can reuse a name defined in one of its direct or indirect base classes. As usual, names defined in an inner scope (e.g., a derived class) hide uses of that name in the outer scope (e.g., a base class) (&#167;<a href="022-2.2._variables.html#filepos382972">2.2.4</a>, p. <a href="022-2.2._variables.html#filepos382972">48</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;Base(): mem(0) { }<br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;int mem;<br class="calibre6"/>};<br class="calibre6"/>struct Derived : Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;Derived(int i): mem(i) { } // <span><span class="calibre45"><span class="calibre16">initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived::mem</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::mem</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is default initialized</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int get_mem() { return mem; }&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived::mem</span></span></tt></span><br class="calibre6"/>protected:<br class="calibre6"/>&#160;&#160;&#160;&#160;int mem;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">mem</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the base</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_mem</span></tt></code> is resolved to the name inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>. Were we to write</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Derived d(42);<br class="calibre6"/>cout &lt;&lt; d.get_mem() &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">then the output would be <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A derived-class member with the same name as a member of the base class hides direct use of the base-class member.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using the Scope Operator to Use Hidden Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">We can use a hidden base-class member by using the scope operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct Derived : Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;int get_base_mem() { return Base::mem; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The scope operator overrides the normal lookup and directs the compiler to look for <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> starting in the scope of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>. If we ran the code above with this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>, the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">d.get_mem()</span></tt></code> would be <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Aside from overriding inherited virtual functions, a derived class usually should not reuse names defined in its base class.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos3953912"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Name Lookup and Inheritance</span></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Understanding how function calls are resolved is crucial to understanding inheritance in C++. Given the call <code class="calibre23"><tt class="calibre23"><span class="calibre24">p-&gt;mem()</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj.mem()</span></tt></code>), the following four steps happen:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; First determine the static type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code>). Because we&#8217;re calling a member, that type must be a class type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Look for <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> in the class that corresponds to the static type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code>). If <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is not found, look in the direct base class and continue up the chain of classes until <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is found or the last class is searched. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is not found in the class or its enclosing base classes, then the call will not compile.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Once <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is found, do normal type checking (&#167;<a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">203</a>) to see if this call is legal given the definition that was found.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Assuming the call is legal, the compiler generates code, which varies depending on whether the call is virtual or not:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; If <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code> is virtual and the call is made through a reference or pointer, then the compiler generates code to determine at run time which version to run based on the dynamic type of the object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; Otherwise, if the function is nonvirtual, or if the call is on an object (not a reference or pointer), the compiler generates a normal function call.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">As Usual, Name Lookup Happens before Type Checking</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, functions declared in an inner scope do not overload functions declared in an outer scope (&#167;<a href="066-6.4._overloaded_functions.html#filepos1621309">6.4.1</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1621309">234</a>). As a result, functions defined in a derived class do <em class="calibre16">not</em> overload members defined in its base class(es). As in any other scope, if a member in a derived class (i.e., in an inner scope) has the same name as a base-class member (i.e., a name defined in an outer scope), then the derived member hides the base-class member within the scope of the derived class. The base member is hidden even if the functions have different parameter lists:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;int memfcn();<br class="calibre6"/>};<br class="calibre6"/>struct Derived : Base {<br class="calibre6"/>&#160;&#160;&#160;&#160;int memfcn(int);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">memfcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the base</span></span></span><br class="calibre6"/>};<br class="calibre6"/>Derived d; Base b;<br class="calibre6"/>b.memfcn();&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::memfcn</span></span></tt></span><br class="calibre6"/>d.memfcn(10);&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived::memfcn</span></span></tt></span><br class="calibre6"/>d.memfcn();&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">memfcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with no arguments is hidden</span></span></span><br class="calibre6"/>d.Base::memfcn(); //&#160;&#160;<span><span class="calibre45"><span class="calibre16">ok: calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::memfcn</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">memfcn</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> hides the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">memfcn</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>. Not surprisingly, the first call through <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, which is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> object, calls the version in the base class. Similarly, the second call (through <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code>) calls the one from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>. What can be surprising is that the third call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">d.memfcn()</span></tt></code>, is illegal.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos3960207"/>To resolve this call, the compiler looks for the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">memfcn</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code>. That class defines a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">memfcn</span></tt></code> and the search stops. Once the name is found, the compiler looks no further. The version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">memfcn</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Derived</span></tt></code> expects an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> argument. This call provides no such argument; it is in error.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Virtual Functions and Scope</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">We can now understand why virtual functions must have the same parameter list in the base and derived classes (&#167;<a href="144-15.3._virtual_functions.html#filepos3853256">15.3</a>, p. <a href="144-15.3._virtual_functions.html#filepos3853256">605</a>). If the base and derived members took arguments that differed from one another, there would be no way to call the derived version through a reference or pointer to the base class. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual int fcn();<br class="calibre6"/>};<br class="calibre6"/>class D1 : public Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the base; this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not virtual</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inherits the definition of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::fcn()</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int fcn(int);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">parameter list differs from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual void f2(); // <span><span class="calibre45"><span class="calibre16">new virtual function that does not exist in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>};<br class="calibre6"/>class D2 : public D1 {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;int fcn(int); // <span><span class="calibre45"><span class="calibre16">nonvirtual function hides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D1::fcn(int)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int fcn();&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">overrides virtual</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f2();&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">overrides virtual</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D1</span></span></tt></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> function in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> does not override the virtual <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> because they have different parameter lists. Instead, it <em class="calibre16">hides</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> from the base. Effectively, <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> has two functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code>: <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> inherits a virtual named <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> and defines its own, nonvirtual member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Calling a Hidden Virtual through the Base Class</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Given the classes above, let&#8217;s look at several different ways to call these functions:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Base bobj;&#160;&#160;D1 d1obj; D2 d2obj;<br class="calibre6"/>Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;<br class="calibre6"/>bp1-&gt;fcn(); // <span><span class="calibre45"><span class="calibre16">virtual call, will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">at run time</span></span></span><br class="calibre6"/>bp2-&gt;fcn(); // <span><span class="calibre45"><span class="calibre16">virtual call, will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">at run time</span></span></span><br class="calibre6"/>bp3-&gt;fcn(); // <span><span class="calibre45"><span class="calibre16">virtual call, will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D2::fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">at run time</span></span></span><br class="calibre6"/>D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;<br class="calibre6"/>bp2-&gt;f2(); // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has no member named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span><br class="calibre6"/>d1p-&gt;f2(); // <span><span class="calibre45"><span class="calibre16">virtual call, will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D1::f2(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">at run time</span></span></span><br class="calibre6"/>d2p-&gt;f2(); // <span><span class="calibre45"><span class="calibre16">virtual call, will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D2::f2(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">at run time</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first three calls are all made through pointers to the base class. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> is virtual, the compiler generates code to decide at run time which version to call. <a id="filepos3967935"/>That decision will be based on the actual type of the object to which the pointer is bound. In the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp2</span></tt></code>, the underlying object is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code>. That class did not override the <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> function that takes no arguments. Thus, the call through <code class="calibre23"><tt class="calibre23"><span class="calibre24">bp2</span></tt></code> is resolved (at run time) to the version defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The next three calls are made through pointers with differing types. Each pointer points to one of the types in this hierarchy. The first call is illegal because there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2()</span></tt></code> in class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>. The fact that the pointer happens to point to a derived object is irrelevant.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For completeness, let&#8217;s look at calls to the nonvirtual function <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn(int)</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 =&#160;&#160;&amp;d2obj;<br class="calibre6"/>p1-&gt;fcn(42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has no version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that takes an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>p2-&gt;fcn(42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">statically bound, calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D1::fcn(int)</span></span></tt></span><br class="calibre6"/>p3-&gt;fcn(42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">statically bound, calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D2::fcn(int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In each call the pointer happens to point to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">D2</span></tt></code>. However, the dynamic type doesn&#8217;t matter when we call a nonvirtual function. The version that is called depends only on the static type of the pointer.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Overriding Overloaded Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with any other function, a member function (virtual or otherwise) can be overloaded. A derived class can override zero or more instances of the overloaded functions it inherits. If a derived class wants to make all the overloaded versions available through its type, then it must override all of them or none of them.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Sometimes a class needs to override some, but not all, of the functions in an overloaded set. It would be tedious in such cases to have to override every base-class version in order to override the ones that the class needs to specialize.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Instead of overriding every base-class version that it inherits, a derived class can provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration (&#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">615</a>) for the overloaded member. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration specifies only a name; it may not specify a parameter list. Thus, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for a base-class member function adds all the overloaded instances of that function to the scope of the derived class. Having brought all the names into its scope, the derived class needs to define only those functions that truly depend on its type. It can use the inherited definitions for the others.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The normal rules for a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration inside a class apply to names of overloaded functions (&#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">615</a>); every overloaded instance of the function in the base class must be accessible to the derived class. The access to the overloaded versions that are not otherwise redefined by the derived class will be the access in effect at the point of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.23:</strong> Assuming class <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> on page <a href="147-15.6._class_scope_under_inheritance.html#filepos3960207">620</a> had intended to override its inherited <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> function, how would you fix that class? Assuming you fixed the class so that <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> matched the definition in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>, how would the calls in that section be resolved?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="146-15.5._access_control_and_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="148-15.7._constructors_and_copy_control.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
