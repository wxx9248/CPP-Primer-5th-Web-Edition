<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>2.4. const Qualifier</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="023-2.3._compound_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="025-2.5._dealing_with_types.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos462256" class="calibre29"><span class="bold">2.4. <code class="calibre54"><tt class="calibre54"><span class="calibre55"><span class="calibre2"><tt class="calibre54"><span class="calibre56"><span class="bold">const</span></span></tt></span></span></tt></code> Qualifier</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Sometimes we want to define a variable whose value we know cannot be changed. For example, we might want to use a variable to refer to the size of a buffer size. Using a variable makes it easy for us to change the size of the buffer if we decided the original size wasn&#8217;t what we needed. On the other hand, we&#8217;d also like to prevent code from inadvertently giving a new value to the variable we use to represent the buffer size. We can make a variable unchangeable by defining the variable&#8217;s type as <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos463173" href="028-defined_terms.html#filepos614496">const</a></span></span></tt></span></span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int bufSize = 512;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">input buffer size</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code> as a constant. Any attempt to assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code> is an error:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bufSize = 512; // <span><span class="calibre45"><span class="calibre16">error: attempt to write to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because we can&#8217;t change the value of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object after we create it, it must be initialized. As usual, the initializer may be an arbitrarily complicated expression:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int i = get_size();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: initialized at run time</span></span></span><br class="calibre6"/>const int j = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: initialized at compile time</span></span></span><br class="calibre6"/>const int k;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Initialization and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we have observed many times, the type of an object defines the operations that can be performed by that object. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type can use most but not all of the same operations as its non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version. The one restriction is that we may use only those operations that cannot change an object. So, for example, we can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code> in arithmetic expressions in exactly the same way as a plain, non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code>. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code> converts to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> the same way as a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, and so on.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Among the operations that don&#8217;t change the value of an object is initialization&#8212;when we use an object to initialize another object, it doesn&#8217;t matter whether either or both of the objects are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>const int ci = i;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: the value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is copied into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><br class="calibre6"/>int j = ci;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: the value in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is copied into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code>, the value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> matters only for operations that might change <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code>. When we copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>, we don&#8217;t care that <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Copying an object doesn&#8217;t change that object. Once the copy is made, the new object has no further access to the original object.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos469506"/>By Default, <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Objects Are Local to a File</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object is initialized from a compile-time constant, such as in our definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int bufSize = 512;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">input buffer size</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the compiler will usually replace uses of the variable with its corresponding value during compilation. That is, the compiler will generate code using the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">512</span></tt></code> in the places that our code uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To substitute the value for the variable, the compiler has to see the variable&#8217;s initializer. When we split a program into multiple files, every file that uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> must have access to its initializer. In order to see the initializer, the variable must be defined in every file that wants to use the variable&#8217;s value (&#167; <a href="022-2.2._variables.html#filepos368323">2.2.2</a>, p. <a href="022-2.2._variables.html#filepos368323">45</a>). To support this usage, yet avoid multiple definitions of the same variable, <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> variables are defined as local to the file. When we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> with the same name in multiple files, it is as if we had written definitions for separate variables in each file.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Sometimes we have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> variable that we want to share across multiple files but whose initializer is not a constant expression. In this case, we don&#8217;t want the compiler to generate a separate variable in each file. Instead, we want the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object to behave like other (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) variables. We want to define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> in one file, and declare it in the other files that use that object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To define a single instance of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> variable, we use the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> on both its definition and declaration(s):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">file_1.cc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">defines and initializes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that is accessible to other files</span></span></span><br class="calibre6"/>extern const int bufSize = fcn();<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">file_1.h</span></span></tt></span><br class="calibre6"/>extern const int bufSize; // <span><span class="calibre45"><span class="calibre16">same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bufSize</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as defined in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">file_1.cc</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this program, <code class="calibre23"><tt class="calibre23"><span class="calibre24">file_1.cc</span></tt></code> defines and initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code>. Because this declaration includes an initializer, it is (as usual) a definition. However, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we must specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> in order for <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code> to be used in other files.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The declaration in <code class="calibre23"><tt class="calibre23"><span class="calibre24">file_1.h</span></tt></code> is also <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code>. In this case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> signifies that <code class="calibre23"><tt class="calibre23"><span class="calibre24">bufSize</span></tt></code> is not local to this file and that its definition will occur elsewhere.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">To share a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object among multiple files, you must define the variable as <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.26:</strong> Which of the following are legal? For those that are illegal, explain why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int buf;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int cnt = 0;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int sz = cnt;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">++cnt; ++sz;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos476737" class="calibre37"><span class="calibre5"><a id="filepos476770"/>2.4.1. References to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As with any other object, we can bind a reference to an object of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. To do so we use a <strong class="calibre5"><a id="filepos477231" href="028-defined_terms.html#filepos624795">reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></a></strong>, which is a reference that refers to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. Unlike an ordinary reference, a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> cannot be used to change the object to which the reference is bound:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int ci = 1024;<br class="calibre6"/>const int &amp;r1 = ci;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: both reference and underlying object are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>r1 = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>int &amp;r2 = ci;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: non</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because we cannot assign directly to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code>, we also should not be able to use a reference to change <code class="calibre23"><tt class="calibre23"><span class="calibre24">ci</span></tt></code>. Therefore, the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">r2</span></tt></code> is an error. If this initialization were legal, we could use <code class="calibre23"><tt class="calibre23"><span class="calibre24">r2</span></tt></code> to change the value of its underlying object.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Terminology: <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> Reference is a Reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code></span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">C++ programmers tend to abbreviate the phrase &#8220;reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>&#8221; as &#8220;<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> reference.&#8221; This abbreviation makes sense&#8212;if you remember that it is an abbreviation.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Technically speaking, there are no <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> references. A reference is not an object, so we cannot make a reference itself <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Indeed, because there is no way to make a reference refer to a different object, in some sense all references are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Whether a reference refers to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type affects what we can do with that reference, not whether we can alter the binding of the reference itself.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Initialization and References to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a> (p. <a href="023-2.3._compound_types.html#filepos396246">51</a>) we noted that there are two exceptions to the rule that the type of a reference must match the type of the object to which it refers. The first exception is that we can initialize a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> from any expression that can be converted (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>) to the type of the reference. In particular, we can bind a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, a literal, or a more general expression:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>const int &amp;r1 = i;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we can bind a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a plain</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>const int &amp;r2 = 42;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>const int &amp;r3 = r1 * 2; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>int &amp;r4 = r * 2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a plain, non</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The easiest way to understand this difference in initialization rules is to consider what happens when we bind a reference to an object of a different type:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double dval = 3.14;<br class="calibre6"/>const int &amp;ri = dval;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> refers to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> will be integer operations, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">dval</span></tt></code> is a floating-point number, not an integer. To ensure that the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> is bound is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, the compiler transforms this code into something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos485357"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int temp = dval;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">create a temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>const int &amp;ri = temp;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">bind</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ri</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to that temporary</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> is bound to a <strong class="calibre5"><a id="filepos486375" href="028-defined_terms.html#filepos627457">temporary</a></strong> object. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. C++ programmers often use the word temporary as an abbreviation for temporary object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Now consider what could happen if this initialization were allowed but <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> was not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> weren&#8217;t <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we could assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code>. Doing so would change the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> is bound. That object is a temporary, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">dval</span></tt></code>. The programmer who made <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> refer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dval</span></tt></code> would probably expect that assigning to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> would change <code class="calibre23"><tt class="calibre23"><span class="calibre24">dval</span></tt></code>. After all, why assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> unless the intent is to change the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ri</span></tt></code> is bound? Because binding a reference to a temporary is almost surely <em class="calibre16">not</em> what the programmer intended, the language makes it illegal.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">A Reference to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> May Refer to an Object That Is Not <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is important to realize that a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> restricts only what we can do through that reference. Binding a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to an object says nothing about whether the underlying object itself is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Because the underlying object might be non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, it might be changed by other means:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int &amp;r1 = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>const int &amp;r2 = i;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">also bound to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; but cannot be used to change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>r1 = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const; i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is now</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>r2 = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Binding <code class="calibre23"><tt class="calibre23"><span class="calibre24">r2</span></tt></code> to the (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">int i</span></tt></code> is legal. However, we cannot use <code class="calibre23"><tt class="calibre23"><span class="calibre24">r2</span></tt></code> to change <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>. Even so, the value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> still might change. We can change <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> by assigning to it directly, or by assigning to another reference bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">r1</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos491891" class="calibre37"><span class="calibre5">2.4.2. Pointers and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As with references, we can define pointers that point to either <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> types. Like a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, a <strong class="calibre5"><a id="filepos492522" href="028-defined_terms.html#filepos623589">pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></a></strong> (&#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, p. <a href="024-2.4._const_qualifier.html#filepos476737">61</a>) may not be used to change the object to which the pointer points. We may store the address of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object only in a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const double pi = 3.14;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; its value may not be changed</span></span></span><br class="calibre6"/>double *ptr = &amp;pi;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a plain pointer</span></span></span><br class="calibre6"/>const double *cptr = &amp;pi; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">may point to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>*cptr = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*cptr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">In &#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a> (p. <a href="023-2.3._compound_types.html#filepos409391">52</a>) we noted that there are two exceptions to the rule that the types of a pointer and the object to which it points must match. The first exception is that we can use a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to point to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double dval = 3.14;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; its value can be changed</span></span></span><br class="calibre6"/>cptr = &amp;dval;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but can't change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cptr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos496349"/>Like a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> says nothing about whether the object to which the pointer points is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Defining a pointer as a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> affects only what we can do with the pointer. It is important to remember that there is no guarantee that an object pointed to by a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> won&#8217;t change.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It may be helpful to think of pointers and references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> as pointers or references &#8220;that <em class="calibre16">think</em> they point or refer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.&#8221;</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Pointers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Like any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code>
<strong class="calibre5">pointer</strong> must be initialized, and once initialized, its value (i.e., the address that it holds) may not be changed. We indicate that the pointer is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> by putting the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> after the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>. This placement indicates that it is the pointer, not the pointed-to type, that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int errNumb = 0;<br class="calibre6"/>int *const curErr = &amp;errNumb;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curErr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will always point to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">errNumb</span></span></tt></span><br class="calibre6"/>const double pi = 3.14159;<br class="calibre6"/>const double *const pip = &amp;pi; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we saw in &#167; <a href="023-2.3._compound_types.html#filepos445809">2.3.3</a> (p. <a href="023-2.3._compound_types.html#filepos445809">58</a>), the easiest way to understand these declarations is to read them from right to left. In this case, the symbol closest to <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, which means that <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code> itself will be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. The type of that object is formed from the rest of the declarator. The next symbol in the declarator is <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, which means that <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer. Finally, the base type of the declaration completes the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code>, which is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">pip</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const double</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fact that a pointer is itself <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> says nothing about whether we can use the pointer to change the underlying object. Whether we can change that object depends entirely on the type to which the pointer points. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">pip</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Neither the value of the object addressed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">pip</span></tt></code> nor the address stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">pip</span></tt></code> can be changed. On the other hand, <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code> addresses a plain, non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code>. We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">curErr</span></tt></code> to change the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">errNumb</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">*pip = 2.72;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">if the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curErr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points (i.e.,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">errNumb</span></span></tt></span><span><span class="calibre45"><span class="calibre16">) is nonzero</span></span></span><br class="calibre6"/>if (*curErr) {<br class="calibre6"/>&#160;&#160;&#160;&#160;errorHandler();<br class="calibre6"/>&#160;&#160;&#160;&#160;*curErr = 0; // <span><span class="calibre45"><span class="calibre16">ok: reset the value of the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curErr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 id="filepos504024" class="calibre37"><span class="calibre5">2.4.3. Top-Level <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, a pointer is an object that can point to a different object. As a result, we can talk independently about whether a pointer is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and whether <a id="filepos504566"/>the objects to which it can point are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. We use the term <strong class="calibre5"><a id="filepos504706" href="028-defined_terms.html#filepos627813">top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></a></strong> to indicate that the pointer itself is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. When a pointer can point to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, we refer to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> as a <strong class="calibre5"><a id="filepos505221" href="028-defined_terms.html#filepos621521">low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></a></strong>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.4.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.27:</strong> Which of the following initializations are legal? Explain why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int i = -1, &amp;r = 0;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int *const p2 = &amp;i2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int i = -1, &amp;r = 0;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int *const p3 = &amp;i2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int *p1 = &amp;i2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int &amp;const r2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(g)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int i2 = i, &amp;r = i;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.28:</strong> Explain the following definitions. Identify any that are illegal.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int i, *const cp;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int *p1, *const p2;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int ic, &amp;r = ic;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int *const p3;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const int *p;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.29:</strong> Uing the variables in the previous exercise, which of the following assignments are legal? Explain why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">i = ic;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">p1 = p3;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">p1 = &amp;ic;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">p3 = &amp;ic;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">p2 = p1;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ic = *p3;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">More generally, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> indicates that an object itself is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> can appear in any object type, i.e., one of the built-in arithmetic types, a class type, or a pointer type. Low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> appears in the base type of compound types such as pointers or references. Note that pointer types, unlike most other types, can have both top-level and low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> independently:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0;<br class="calibre6"/>int *const p1 = &amp;i;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we can'</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">change the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1; const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level</span></span></span><br class="calibre6"/>const int ci = 42;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we cannot change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci; const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level</span></span></span><br class="calibre6"/>const int *p2 = &amp;ci;&#160;// <span><span class="calibre45"><span class="calibre16">we can change</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2; const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is low-level</span></span></span><br class="calibre6"/>const int *const p3 = p2; // <span><span class="calibre45"><span class="calibre16">right-most</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is top-level, left-most is not</span></span></span><br class="calibre6"/>const int &amp;r = ci;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in reference types is always low-level</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre25">The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are ignored:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">i = ci;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: copying the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; top-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is ignored</span></span></span><br class="calibre6"/>p2 = p3; // <span><span class="calibre45"><span class="calibre16">ok: pointed-to type matches; top-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is ignored</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Copying an object doesn&#8217;t change the copied object. As a result, it is immaterial whether the object copied from or copied into is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">On the other hand, low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> is never ignored. When we copy an object, both objects must have the same low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> qualification or there must be a conversion between the types of the two objects. In general, we can convert a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> but not the other way round:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos514745"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p = p3; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has a low-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">doesn'</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span><br class="calibre6"/>p2 = p3;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has the same low-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">qualification as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p3</span></span></tt></span><br class="calibre6"/>p2 = &amp;i;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: we can convert</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int*</span></span></tt></span><br class="calibre6"/>int &amp;r = ci; // <span><span class="calibre45"><span class="calibre16">error: can'</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">bind an ordinary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>const int &amp;r2 = i; // <span><span class="calibre45"><span class="calibre16">ok: can bind</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to plain</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> has both a top-level and low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. When we copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code>, we can ignore its top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> but not the fact that it points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. Hence, we cannot use <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>, which points to a plain (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. On the other hand, we can assign <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code>. Both pointers have the same (low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) type. The fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer (i.e., that it has a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) doesn&#8217;t matter.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.4.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.30:</strong> For each of the following declarations indicate whether the object being declared has top-level or low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int v2 = 0;&#160;&#160;&#160;&#160;int v1 = v2;<br class="calibre6"/>int *p1 = &amp;v1, &amp;r1 = v1;<br class="calibre6"/>const int *p2 = &amp;v2, *const p3 = &amp;i, &amp;r2 = v2;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.31:</strong> Given the declarations in the previous exercise determine whether the following assignments are legal. Explain how the top-level or low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> applies in each case.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">r1 = v2;<br class="calibre6"/>p1 = p2;&#160;&#160;&#160;&#160;p2 = p1;<br class="calibre6"/>p1 = p3;&#160;&#160;&#160;&#160;p2 = p3;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos520427" class="calibre37"><span class="calibre5">2.4.4. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">constexpr</span></span></tt></span></span></tt></code> and Constant Expressions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos520769" href="028-defined_terms.html#filepos615363">constant expression</a></strong> is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object that is initialized from a constant expression is also a constant expression. As we&#8217;ll see, there are several contexts in the language that require constant expressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Whether a given object (or expression) is a constant expression depends on the types and the initializers. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int max_files = 20;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">max_files</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant expression</span></span></span><br class="calibre6"/>const int limit = max_files + 1; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">limit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant expression</span></span></span><br class="calibre6"/>int staff_size = 27;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">staff_size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a constant expression</span></span></span><br class="calibre6"/>const int sz = get_size(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sz</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a constant expression</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">staff_size</span></tt></code> is initialized from a literal, it is not a constant expression because it is a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code>. On the other hand, even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the value of its initializer is not known until run time. Hence, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> is not a constant expression.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos523317"/><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">constexpr</span></span></tt></span></span></tt></code> Variables</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In a large system, it can be difficult to determine (for certain) that an initializer is a constant expression. We might define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> variable with an initializer that we think is a constant expression. However, when we use that variable in a context that requires a constant expression we may discover that the initializer was not a constant expression. In general, the definition of an object and its use in such a context can be widely separated.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos524101"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Under the new standard, we can ask the compiler to verify that a variable is a constant expression by declaring the variable in a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos524406" href="028-defined_terms.html#filepos615594">constexpr</a></span></span></tt></span></span></tt></code> declaration. Variables declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> are implicitly <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and must be initialized by constant expressions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr int mf = 20;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">20</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant expression</span></span></span><br class="calibre6"/>constexpr int limit = mf + 1; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">mf + 1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant expression</span></span></span><br class="calibre6"/>constexpr int sz = size();&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok only if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">constexpr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although we cannot use an ordinary function as an initializer for a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> variable, we&#8217;ll see in &#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a> (p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">239</a>) that the new standard lets us define certain functions as <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>. Such functions must be simple enough that the compiler can evaluate them at compile time. We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> functions in the initializer of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> variable.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Generally, it is a good idea to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> for variables that you intend to use as constant expressions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Literal Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Because a constant expression is one that can be evaluated at compile time, there are limits on the types that we can use in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> declaration. The types we can use in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> are known as &#8220;literal types&#8221; because they are simple enough to have literal values.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Of the types we have used so far, the arithmetic, reference, and pointer types are literal types. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_item</span></tt></code> class and the library IO and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> types are not literal types. Hence, we cannot define variables of these types as <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>s. We&#8217;ll see other kinds of literal types in &#167; <a href="077-7.5._constructors_revisited.html#filepos2019288">7.5.6</a> (p. <a href="077-7.5._constructors_revisited.html#filepos2019288">299</a>) and &#167; <a href="179-19.3._enumerations.html#filepos5202480">19.3</a> (p. <a href="179-19.3._enumerations.html#filepos5202480">832</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Although we can define both pointers and reference as <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>s, the objects we use to initialize them are strictly limited. We can initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> pointer from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> literal or the literal (i.e., constant expression) <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>. We can also point to (or bind to) an object that remains at a fixed address.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For reasons we&#8217;ll cover in &#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a> (p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>), variables defined inside a function ordinarily are not stored at a fixed address. Hence, we cannot use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> pointer to point to such variables. On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> pointer. We&#8217;ll see in &#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a> (p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>), that functions may define variables that exist across calls to that function. Like an object defined outside any function, these special local objects also have fixed addresses. Therefore, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> reference may be bound to, and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> pointer may address, such variables.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos530182"/>Pointers and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">constexpr</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is important to understand that when we define a pointer in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> declaration, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> specifier applies to the pointer, not the type to which the pointer points:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int *p = nullptr;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>constexpr int *q = nullptr; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Despite appearances, the types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> are quite different; <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, whereas <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> is a constant pointer. The difference is a consequence of the fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> imposes a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) on the objects it defines.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like any other constant pointer, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> pointer may point to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr int *np = nullptr; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">np</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that is null</span></span></span><br class="calibre6"/>int j = 0;<br class="calibre6"/>constexpr int i = 42;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must be defined outside any function</span></span></span><br class="calibre6"/>constexpr const int *p = &amp;i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant pointer to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int i</span></span></tt></span><br class="calibre6"/>constexpr int *p1 = &amp;j;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a constant pointer to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int j</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.4.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.32:</strong> Is the following code legal or not? If not, how might you make it legal?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int null = 0, *p = null;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="023-2.3._compound_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="025-2.5._dealing_with_types.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
