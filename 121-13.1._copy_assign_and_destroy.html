<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>13.1. Copy, Assign, and Destroy</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="120-chapter_13._copy_control.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="122-13.2._copy_control_and_resource_management.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3202630" class="calibre29"><span class="bold">13.1. Copy, Assign, and Destroy</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">We&#8217;ll start by covering the most basic operations, which are the copy constructor, copy-assignment operator, and destructor. We&#8217;ll cover the move operations (which were introduced by the new standard) in &#167; <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>).</p><div class="calibre15">&#160;</div>
<h4 id="filepos3203084" class="calibre37"><span class="calibre5">13.1.1. The Copy Constructor</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A constructor is the copy constructor if its first parameter is a reference to the class type and any additional parameters have default values:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;Foo();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;Foo(const Foo&amp;);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For reasons we&#8217;ll explain shortly, the first parameter must be a reference type. That parameter is almost always a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, although we can define the copy constructor to take a reference to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. The copy constructor is used implicitly in several circumstances. Hence, the copy constructor usually should not be <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3204898"/>The Synthesized Copy Constructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we do not define a copy constructor for a class, the compiler synthesizes one for us. Unlike the synthesized default constructor (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>), a copy constructor is synthesized even if we define other constructors.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ll see in &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>), the <strong class="calibre5"><a id="filepos3205471" href="128-defined_terms.html#filepos3543566">synthesized copy constructor</a></strong> for some classes prevents us from copying objects of that class type. Otherwise, the synthesized copy constructor <strong class="calibre5"><a id="filepos3205675" href="128-defined_terms.html#filepos3538527">memberwise copies</a></strong> the members of its argument into the object being created (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). The compiler copies each non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member in turn from the given object into the one being created.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The type of each member determines how that member is copied: Members of class type are copied by the copy constructor for that class; members of built-in type are copied directly. Although we cannot directly copy an array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), the synthesized copy constructor copies members of array type by copying each element. Elements of class type are copied by using the elements&#8217; copy constructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, the synthesized copy constructor for our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class is equivalent to:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members and constructors as before</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declaration equivalent to the synthesized copy constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(const Sales_data&amp;);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string bookNo;<br class="calibre6"/>&#160;&#160;&#160;&#160;int units_sold = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;double revenue = 0.0;<br class="calibre6"/>};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">equivalent to the copy constructor that would be synthesized for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>Sales_data::Sales_data(const Sales_data &amp;orig):<br class="calibre6"/>&#160;&#160;&#160;&#160;bookNo(orig.bookNo),&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold(orig.units_sold), // <span><span class="calibre45"><span class="calibre16">copies</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">orig.units_sold</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;revenue(orig.revenue)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copies</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">orig.revenue</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty body</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Copy Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We are now in a position to fully understand the differences between direct initialization and copy initialization (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string dots(10, '.');&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">direct initialization</span></span></span><br class="calibre6"/>string s(dots);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">direct initialization</span></span></span><br class="calibre6"/>string s2 = dots;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy initialization</span></span></span><br class="calibre6"/>string null_book = "9-999-99999-9"; // <span><span class="calibre45"><span class="calibre16">copy initialization</span></span></span><br class="calibre6"/>string nines = string(100, '9');&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy initialization</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we use direct initialization, we are asking the compiler to use ordinary function matching (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) to select the constructor that best matches the arguments we provide. When we use <strong class="calibre5"><a id="filepos3210850" href="128-defined_terms.html#filepos3536714">copy initialization</a></strong>, we are asking the compiler to copy the right-hand operand into the object being created, converting that operand if necessary (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">294</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos3211194"/>Copy initialization ordinarily uses the copy constructor. However, as we&#8217;ll see in &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>), if a class has a move constructor, then copy initialization sometimes uses the move constructor instead of the copy constructor. For now, what&#8217;s useful to know is when copy initialization happens and that copy initialization requires either the copy constructor or the move constructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Copy initialization happens not only when we define variables using an <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code>, but also when we</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Pass an object as an argument to a parameter of nonreference type</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Return an object from a function that has a nonreference return type</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Brace initialize the elements in an array or the members of an aggregate class (&#167; <a href="077-7.5._constructors_revisited.html#filepos2013562">7.5.5</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2013562">298</a>)</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Some class types also use copy initialization for the objects they allocate. For example, the library containers copy initialize their elements when we initialize the container, or when we call an <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">push</span></tt></code> member (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">342</a>). By contrast, elements created by an <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace</span></tt></code> member are direct initialized (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">345</a>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Parameters and Return Values</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">During a function call, parameters that have a nonreference type are copy initialized (&#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>). Similarly, when a function has a nonreference return type, the return value is used to copy initialize the result of the call operator at the call site (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fact that the copy constructor is used to initialize nonreference parameters of class type explains why the copy constructor&#8217;s own parameter must be a reference. If that parameter were not a reference, then the call would never succeed&#8212;to call the copy constructor, we&#8217;d need to use the copy constructor to copy the argument, but to copy the argument, we&#8217;d need to call the copy constructor, and so on indefinitely.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Constraints on Copy Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, whether we use copy or direct initialization matters if we use an initializer that requires conversion by an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; v1(10);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: direct initialization</span></span></span><br class="calibre6"/>vector&lt;int&gt; v2 = 10; // <span><span class="calibre45"><span class="calibre16">error: constructor that takes a size is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span><br class="calibre6"/>void f(vector&lt;int&gt;); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s parameter is copy initialized</span></span></span><br class="calibre6"/>f(10); // <span><span class="calibre45"><span class="calibre16">error: can't use an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">explicit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor to copy an argument</span></span></span><br class="calibre6"/>f(vector&lt;int&gt;(10));&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: directly construct a temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Directly initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> is fine, but the seemingly equivalent copy initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> is an error, because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> constructor that takes a single size parameter is <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code>. For the same reasons that we cannot copy initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>, we cannot implicitly use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor when we pass an argument or return a value from a function. If we want to use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> constructor, we must do so explicitly, as in the last line of the example above.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3217170"/>The Compiler Can Bypass the Copy Constructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">During copy initialization, the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly. That is, the compiler is permitted to rewrite</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string null_book = "9-999-99999-9"; // <span><span class="calibre45"><span class="calibre16">copy initialization</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">into</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string null_book("9-999-99999-9"); // <span><span class="calibre45"><span class="calibre16">compiler omits the copy constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, even if the compiler omits the call to the copy/move constructor, the copy/move constructor must exist and must be accessible (e.g., not <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>) at that point in the program.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.1:</strong> What is a copy constructor? When is it used?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.2:</strong> Explain why the following declaration is illegal:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data::Sales_data(Sales_data rhs);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.3:</strong> What happens when we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob?</span></tt></code> What about <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>s?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.4:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">Point</span></tt></code> is a class type with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> copy constructor, identify each use of the copy constructor in this program fragment:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>Point global;<br class="calibre6"/>Point foo_bar(Point arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Point local = arg, *heap = new Point(global);<br class="calibre6"/>&#160;&#160;&#160;&#160;*heap = local;<br class="calibre6"/>&#160;&#160;&#160;&#160;Point pa[ 4 ] = { local, *heap };<br class="calibre6"/>&#160;&#160;&#160;&#160;return *heap;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos3220860"/><strong class="calibre5">Exercise 13.5:</strong> Given the following sketch of a class, write a copy constructor that copies all the members. Your constructor should dynamically allocate a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">458</a>) and copy the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> points, rather than copying <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> itself.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>class HasPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const std::string &amp;s = std::string()):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps(new std::string(s)), i(0) { }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *ps;<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;i;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3222083" class="calibre37"><span class="calibre5"><a id="filepos3222116"/>13.1.2. The Copy-Assignment Operator</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Just as a class controls how objects of that class are initialized, it also controls how objects of its class are assigned:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data trans, accum;<br class="calibre6"/>trans = accum; // <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">copy-assignment operator</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with the copy constructor, the compiler synthesizes a copy-assignment operator if the class does not define its own.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Introducing Overloaded Assignment</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Before we look at the synthesized assignment operator, we need to know a bit about <strong class="calibre5"><a id="filepos3223421" href="128-defined_terms.html#filepos3540925">overloaded operators</a></strong>, which we cover in detail in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Overloaded operators are functions that have the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator</span></tt></code> followed by the symbol for the operator being defined. Hence, the assignment operator is a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator=</span></tt></code>. Like any other function, an operator function has a return type and a parameter list.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The parameters in an overloaded operator represent the operands of the operator. Some operators, assignment among them, must be defined as member functions. When an operator is a member function, the left-hand operand is bound to the implicit <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> parameter (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">257</a>). The right-hand operand in a binary operator, such as assignment, is passed as an explicit parameter.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The copy-assignment operator takes an argument of the same type as the class:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo&amp; operator=(const Foo&amp;); // <span><span class="calibre45"><span class="calibre16">assignment operator</span></span></span><br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To be consistent with assignment for the built-in types (&#167; <a href="042-4.4._assignment_operators.html#filepos1066463">4.4</a>, p. <a href="042-4.4._assignment_operators.html#filepos1066463">145</a>), assignment operators usually return a reference to their left-hand operand. It is also worth noting that the library generally requires that types stored in a container have assignment operators that return a reference to the left-hand operand.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Assignment operators ordinarily should return a reference to their left-hand operand.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Synthesized Copy-Assignment Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as it does for the copy constructor, the compiler generates a <strong class="calibre5"><a id="filepos3226399" href="128-defined_terms.html#filepos3543090">synthesized copy-assignment operator</a></strong> for a class if the class does not define its own. Analogously to the copy constructor, for some classes the synthesized copy-assignment operator disallows assignment (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>). Otherwise, it assigns each non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> member of the right-hand object to the corresponding member of the left-hand object using the copy-assignment operator for the type of that member. Array members are assigned by assigning each element of the array. The synthesized copy-assignment operator returns a reference to its left-hand object.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos3227201"/>As an example, the following is equivalent to the synthesized <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> copy-assignment operator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">equivalent to the synthesized copy-assignment operator</span></span></span><br class="calibre6"/>Sales_data&amp;<br class="calibre6"/>Sales_data::operator=(const Sales_data &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;bookNo = rhs.bookNo;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string::operator=</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold = rhs.units_sold;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the built-in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;revenue = rhs.revenue;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the built-in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return a reference to this object</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.6:</strong> What is a copy-assignment operator? When is this operator used? What does the synthesized copy-assignment operator do? When is it synthesized?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.7:</strong> What happens when we assign one <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> to another? What about <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>s?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.8:</strong> Write the assignment operator for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class from <a href="121-13.1._copy_assign_and_destroy.html#filepos3220860">exercise 13.5</a> in &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">499</a>). As with the copy constructor, your assignment operator should copy the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> points.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3230370" class="calibre37"><span class="calibre5">13.1.3. The Destructor</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The destructor operates inversely to the constructors: Constructors initialize the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members of an object and may do other work; destructors do whatever work is needed to free the resources used by an object and destroy the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members of the object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The destructor is a member function with the name of the class prefixed by a tilde (<code class="calibre23"><tt class="calibre23"><span class="calibre24">~</span></tt></code>). It has no return value and takes no parameters:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Foo {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;~Foo();&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">What a Destructor Does</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as a constructor has an initialization part and a function body (&#167; <a href="077-7.5._constructors_revisited.html#filepos1953073">7.5.1</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1953073">288</a>), a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized <a id="filepos3232251"/>in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The function body of a destructor does whatever operations the class designer wishes to have executed subsequent to the last use of an object. Typically, the destructor frees resources an object allocated during its lifetime.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In a destructor, there is nothing akin to the constructor initializer list to control how members are destroyed; the destruction part is implicit. What happens when a member is destroyed depends on the type of the member. Members of class type are destroyed by running the member&#8217;s own destructor. The built-in types do not have destructors, so nothing is done to destroy members of built-in type.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The implicit destruction of a member of built-in pointer type does <em class="calibre16">not</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the object to which that pointer points.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Unlike ordinary pointers, the smart pointers (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>) are class types and have destructors. As a result, unlike ordinary pointers, members that are smart pointers are automatically destroyed during the destruction phase.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">When a Destructor Is Called</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The destructor is used automatically whenever an object of its type is destroyed:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Variables are destroyed when they go out of scope.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Members of an object are destroyed when the object of which they are a part is destroyed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Elements in a container&#8212;whether a library container or an array&#8212;are destroyed when the container is destroyed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Dynamically allocated objects are destroyed when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> operator is applied to a pointer to the object (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Temporary objects are destroyed at the end of the full expression in which the temporary was created.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, the following fragment defines four <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">{ // <span><span class="calibre45"><span class="calibre16">new scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to dynamically allocated objects</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data&#160;&#160;*p = new Sales_data;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">built-in pointer</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto p2 = make_shared&lt;Sales_data&gt;(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data item(*p);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor copies</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;Sales_data&gt; vec;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">local object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;vec.push_back(*p2);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copies the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;delete p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destructor called on the object pointed to by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>} // <span><span class="calibre45"><span class="calibre16">exit local scope; destructor called on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span><br class="calibre6"/>&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">decrements its use count; if the count goes to 0, the object is freed</span></span></span><br class="calibre6"/>&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">destroys the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3239490"/>Each of these objects contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member, which allocates dynamic memory to contain the characters in its <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> member. However, the only memory our code has to manage directly is the object we directly allocated. Our code directly frees only the dynamically allocated object bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The other <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects are automatically destroyed when they go out of scope. When the block ends, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec, p2</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> all go out of scope, which means that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector, shared_ptr</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> destructors will be run on those objects, respectively. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> destructor will destroy the element we pushed onto <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> destructor will decrement the reference count of the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> points. In this example, that count will go to zero, so the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> destructor will <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> object that <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> allocated.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In all cases, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> destructor implicitly destroys the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> member. Destroying <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> runs the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor, which frees the memory used to store the <small class="calibre48">ISBN</small>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The destructor is <em class="calibre16">not</em> run when a reference or a pointer to an object goes out of scope.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Synthesized Destructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The compiler defines a <strong class="calibre5"><a id="filepos3242525" href="128-defined_terms.html#filepos3544086">synthesized destructor</a></strong> for any class that does not define its own destructor. As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type from being destroyed (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>). Otherwise, the synthesized destructor has an empty function body.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, the synthesized <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> destructor is equivalent to:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no work to do other than destroying the members, which happens automatically</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~Sales_data() { }<br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The members are automatically destroyed after the (empty) destructor body is run. In particular, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor will be run to free the memory used by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is important to realize that the destructor body does not directly destroy the members themselves. Members are destroyed as part of the implicit destruction phase that follows the destructor body. A destructor body executes <em class="calibre16">in addition to</em> the memberwise destruction that takes place as part of destroying an object.</p><div class="calibre22">&#160;</div>
<h4 id="filepos3244603" class="calibre37"><span class="calibre5">13.1.4. The Rule of Three/Five</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, there are three basic operations to control copies of class objects: the copy constructor, copy-assignment operator, and destructor. Moreover, as we&#8217;ll see in &#167; <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>), under the new standard, a class can also define a move constructor and move-assignment operator.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.9:</strong> What is a destructor? What does the synthesized destructor do? When is a destructor synthesized?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.10:</strong> What happens when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> object is destroyed? What about a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.11:</strong> Add a destructor to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class from the previous exercises.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.12:</strong> How many destructor calls occur in the following code fragment?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>bool fcn(const Sales_data *trans, Sales_data accum)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data item1(*trans), item2(accum);<br class="calibre6"/>&#160;&#160;&#160;&#160;return item1.isbn() != item2.isbn();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.13:</strong> A good way to understand copy-control members and constructors is to define a simple class with these members in which each member prints its name:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>struct X {<br class="calibre6"/>&#160;&#160;&#160;&#160;X() {std::cout &lt;&lt; "X()" &lt;&lt; std::endl;}<br class="calibre6"/>&#160;&#160;&#160;&#160;X(const X&amp;) {std::cout &lt;&lt; "X(const X&amp;)" &lt;&lt; std::endl;}<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Add the copy-assignment operator and destructor to <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> and write a program using <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> objects in various ways: Pass them as nonreference and reference parameters; dynamically allocate them; put them in containers; and so forth. Study the output until you are certain you understand when and why each copy-control member is used. As you read the output, remember that the compiler can omit calls to the copy constructor.</p><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">There is no requirement that we define all of these operations: We can define one or two of them without having to define all of them. However, ordinarily these operations should be thought of as a unit. In general, it is unusual to need one without needing to define them all.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Classes That Need Destructors Need Copy and Assignment</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One rule of thumb to use when you decide whether a class needs to define its own versions of the copy-control members is to decide first whether the class needs a destructor. Often, the need for a destructor is more obvious than the need for the copy constructor or assignment operator. If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class that we have used in the exercises is a good example (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">499</a>). That class allocates dynamic memory in its constructor. The synthesized destructor will not <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a data member that is a pointer. Therefore, this class needs to define a destructor to free the memory allocated by its constructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">What may be less clear&#8212;but what our rule of thumb tells us&#8212;is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> also needs a copy constructor and copy-assignment operator.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3250064"/>Consider what would happen if we gave <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> a destructor but used the synthesized versions of the copy constructor and copy-assignment operator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class HasPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const std::string &amp;s = std::string()):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps(new std::string(s)), i(0) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;~HasPtr() { delete ps; }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">WRONG:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">needs a copy constructor and copy-assignment operator</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this version of the class, the memory allocated in the constructor will be freed when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> object is destroyed. Unfortunately, we have introduced a serious bug! This version of the class uses the synthesized versions of copy and assignment. Those functions copy the pointer member, meaning that multiple <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> objects may be pointing to the same memory:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr f(HasPtr hp)&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">passed by value, so it is copied</span></span></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr ret = hp; // <span><span class="calibre45"><span class="calibre16">copies the given</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are destroyed</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> returns, both <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code> are destroyed and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> destructor is run on each of these objects. That destructor will <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the pointer member in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret</span></tt></code> and in <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp</span></tt></code>. But these objects contain the same pointer value. This code will <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> that pointer twice, which is an error (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">462</a>). What happens is undefined.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In addition, the caller of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> may still be using the object that was passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr p("some values");<br class="calibre6"/>f(p);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">completes, the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p.ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points is freed</span></span></span><br class="calibre6"/>HasPtr q(p); // <span><span class="calibre45"><span class="calibre16">now both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to invalid memory!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code>) points is no longer valid. It was returned to the system when <code class="calibre23"><tt class="calibre23"><span class="calibre24">hp</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">ret!)</span></tt></code> was destroyed.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a class needs a destructor, it almost surely also needs the copy-assignment operator and a copy constructor.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Classes That Need Copy Need Assignment, and Vice Versa</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although many classes need to define all of (or none of) the copy-control members, some classes have work that needs to be done to copy or assign objects but has no need for the destructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, consider a class that gives each object its own, unique serial number. Such a class would need a copy constructor to generate a new, distinct serial number for the object being created. That constructor would copy all the other data members from the given object. This class would also need its own <a id="filepos3257021"/>copy-assignment operator to avoid assigning to the serial number of the left-hand object. However, this class would have no need for a destructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This example gives rise to a second rule of thumb: If a class needs a copy constructor, it almost surely needs a copy-assignment operator. And vice versa&#8212;if the class needs an assignment operator, it almost surely needs a copy constructor as well. Nevertheless, needing either the copy constructor or the copy-assignment operator does not (necessarily) indicate the need for a destructor.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.1.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.14:</strong> Assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">numbered</span></tt></code> is a class with a default constructor that generates a unique serial number for each object, which is stored in a data member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">mysn</span></tt></code>. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">numbered</span></tt></code> uses the synthesized copy-control members and given the following function:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>void f (numbered s) { cout &lt;&lt; s.mysn &lt;&lt; endl; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">what output does the following code produce?</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>numbered a, b = a, c = b;<br class="calibre6"/>f(a); f(b); f(c);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.15:</strong> Assume <code class="calibre23"><tt class="calibre23"><span class="calibre24">numbered</span></tt></code> has a copy constructor that generates a new serial number. Does that change the output of the calls in the previous exercise? If so, why? What output gets generated?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.16:</strong> What if the parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> were <code class="calibre23"><tt class="calibre23"><span class="calibre24">const numbered&amp;?</span></tt></code> Does that change the output? If so, why? What output gets generated?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.17:</strong> Write versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">numbered</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> corresponding to the previous three exercises and check whether you correctly predicted the output.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3260372" class="calibre37"><span class="calibre5">13.1.5. Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">= default</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3260607"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">We can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Sales_data {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy control; use defaults</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data(const Sales_data&amp;) = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;Sales_data&amp; operator=(const Sales_data &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;~Sales_data() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>Sales_data&amp; Sales_data::operator=(const Sales_data&amp;) = default;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> on the declaration of the member inside the class body, the synthesized function is implicitly inline (just as is any other member <a id="filepos3262148"/>function defined in the body of the class). If we do not want the synthesized member to be an inline function, we can specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> on the member&#8217;s definition, as we do in the definition of the copy-assignment operator.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> only on member functions that have a synthesized version (i.e., the default constructor or a copy-control member).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3263004" class="calibre37"><span class="calibre5">13.1.6. Preventing Copies</span></h4><div class="calibre38">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Most classes should define&#8212;either implicitly or explicitly&#8212;the default and copy constructors and the copy-assignment operator.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Although most classes should (and generally do) define a copy constructor and a copy-assignment operator, for some classes, there really is no sensible meaning for these operations. In such cases, the class must be defined so as to prevent copies or assignments from being made. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostream</span></tt></code> classes prevent copying to avoid letting multiple objects write to or read from the same IO buffer. It might seem that we could prevent copies by not defining the copy-control members. However, this strategy doesn&#8217;t work: If our class doesn&#8217;t define these operations, the compiler will synthesize them.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Function as Deleted</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3264432"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can prevent copies by defining the copy constructor and copy-assignment operator as <strong class="calibre5"><a id="filepos3264638" href="128-defined_terms.html#filepos3537295">deleted functions</a></strong>. A deleted function is one that is declared but may not be used in any other way. We indicate that we want to define a function as deleted by following its parameter list with <code class="calibre23"><tt class="calibre23"><span class="calibre24">= delete</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct NoCopy {<br class="calibre6"/>&#160;&#160;&#160;&#160;NoCopy() = default;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the synthesized default constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;NoCopy(const NoCopy&amp;) = delete;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no copy</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;NoCopy &amp;operator=(const NoCopy&amp;) = delete; // <span><span class="calibre45"><span class="calibre16">no assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~NoCopy() = default;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the synthesized destructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">= delete</span></tt></code> signals to the compiler (and to readers of our code) that we are intentionally <em class="calibre16">not defining</em> these members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default, = delete</span></tt></code> must appear on the first declaration of a deleted function. This difference follows logically from the meaning of these declarations. A defaulted member affects only what code the compiler generates; hence the <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> is not needed until the compiler generates code. On the other hand, the compiler needs to know that a function is deleted in order to prohibit operations that attempt to use it.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Also unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code>, we can specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">= delete</span></tt></code> on any function (we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> only on the default constructor or a copy-control member that the compiler can synthesize). Although the primary use of deleted functions is to <a id="filepos3267436"/>suppress the copy-control members, deleted functions are sometimes also useful when we want to guide the function-matching process.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Destructor Should Not be a Deleted Member</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is worth noting that we did not delete the destructor. If the destructor is deleted, then there is no way to destroy objects of that type. The compiler will not let us define variables or create temporaries of a type that has a deleted destructor. Moreover, we cannot define variables or temporaries of a class that has a member whose type has a deleted destructor. If a member has a deleted destructor, then that member cannot be destroyed. If a member can&#8217;t be destroyed, the object as a whole can&#8217;t be destroyed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although we cannot define variables or members of such types, we can dynamically allocate objects with a deleted destructor. However, we cannot free them:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct NoDtor {<br class="calibre6"/>&#160;&#160;&#160;&#160;NoDtor() =&#160;&#160;default;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the synthesized default constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~NoDtor() = delete;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we can't destroy objects of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NoDtor</span></span></tt></span><br class="calibre6"/>};<br class="calibre6"/>NoDtor nd;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NoDtor</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">destructor is deleted</span></span></span><br class="calibre6"/>NoDtor *p = new NoDtor();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but we can't</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete p</span></span></tt></span><br class="calibre6"/>delete p; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">NoDtor</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">destructor is deleted</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is not possible to define an object or delete a pointer to a dynamically allocated object of a type with a deleted destructor.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Copy-Control Members May Be Synthesized as Deleted</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, if we do not define the copy-control members, the compiler defines them for us. Similarly, if a class defines no constructors, the compiler synthesizes a default constructor for that class (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>). For some classes, the compiler defines these synthesized members as deleted functions:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The synthesized destructor is defined as deleted if the class has a member whose own destructor is deleted or is inaccessible (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. It is also deleted if the class has a member with a deleted or inaccessible destructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, or if the class has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference member.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; or has a reference member that does not have an in-class initializer (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>); or has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member whose type does not explicitly define a default constructor and that member does not have an in-class initializer.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos3272556"/>In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, then the corresponding member will be a deleted function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It may be surprising that a member that has a deleted or inaccessible destructor causes the synthesized default and copy constructors to be defined as deleted. The reason for this rule is that without it, we could create objects that we could not destroy.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It should not be surprising that the compiler will not synthesize a default constructor for a class with a reference member or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member that cannot be default constructed. Nor should it be surprising that a class with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member cannot use the synthesized copy-assignment operator: After all, that operator attempts to assign to every member. It is not possible to assign a new value to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Although we can assign a new value to a reference, doing so changes the value of the object to which the reference refers. If the copy-assignment operator were synthesized for such classes, the left-hand operand would continue to refer to the same object as it did before the assignment. It would not refer to the same object as the right-hand operand. Because this behavior is unlikely to be desired, the synthesized copy-assignment operator is defined as deleted if the class has a reference member.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We&#8217;ll see in &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">539</a>), &#167; <a href="148-15.7._constructors_and_copy_control.html#filepos3980968">15.7.2</a> (p. <a href="148-15.7._constructors_and_copy_control.html#filepos3980968">624</a>), and &#167; <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">19.6</a> (p. <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">849</a>) that there are other aspects of a class that can cause its copy members to be defined as deleted.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In essence, the copy-control members are synthesized as deleted when it is impossible to copy, assign, or destroy a member of the class.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">private</span></span></tt></span></span></tt></code> Copy Control</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Prior to the new standard, classes prevented copies by declaring their copy constructor and copy-assignment operator as <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class PrivateCopy {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no access specifier; following members are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">private</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by default; see &#167; 7.2 (p. 268)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy control is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">private</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and so is inaccessible to ordinary user code</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;PrivateCopy(const PrivateCopy&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;PrivateCopy &amp;operator=(const PrivateCopy&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members</span></span></span><br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;PrivateCopy() = default; // <span><span class="calibre45"><span class="calibre16">use the synthesized default constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~PrivateCopy(); // <span><span class="calibre45"><span class="calibre16">users can define objects of this type but not copy them</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the destructor is <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code>, users will be able to define <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrivateCopy</span></tt></code> objects. However, because the copy constructor and copy-assignment operator are <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, user code will not be able to copy such objects. However, friends and members of the class can still make copies. To prevent copies by friends and members, we declare these members as <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> but do not define them.</p><div class="calibre15">&#160;</div>
<p class="calibre25">With one exception, which we&#8217;ll cover in &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">15.2.1</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">594</a>), it is legal to declare, but not define, a member function (&#167; <a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>). An attempt to <em class="calibre16">use</em> an undefined <a/>member results in a link-time failure. By declaring (but not defining) a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> copy constructor, we can forestall any attempt to copy an object of the class type: User code that tries to make a copy will be flagged as an error at compile time; copies made in member functions or friends will result in an error at link time.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Classes that want to prevent copying should define their copy constructor and copy-assignment operators using <code class="calibre23"><tt class="calibre23"><span class="calibre24">= delete</span></tt></code> rather than making those members <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.1.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.18:</strong> Define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">Employee</span></tt></code> class that contains an employee name and a unique employee identifier. Give the class a default constructor and a constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representing the employee&#8217;s name. Each constructor should generate a unique ID by incrementing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data member.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.19:</strong> Does your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Employee</span></tt></code> class need to define its own versions of the copy-control members? If so, why? If not, why not? Implement whatever copy-control members you think <code class="calibre23"><tt class="calibre23"><span class="calibre24">Employee</span></tt></code> needs.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.20:</strong> Explain what happens when we copy, assign, or destroy objects of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> classes from &#167; <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.21:</strong> Do you think the <code class="calibre23"><tt class="calibre23"><span class="calibre24">TextQuery</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">QueryResult</span></tt></code> classes need to define their own versions of the copy-control members? If so, why? If not, why not? Implement whichever copy-control operations you think these classes require.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="120-chapter_13._copy_control.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="122-13.2._copy_control_and_resource_management.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
