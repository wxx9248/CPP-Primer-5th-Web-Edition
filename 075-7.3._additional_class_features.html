<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>7.3. Additional Class Features</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="074-7.2._access_control_and_encapsulation.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="076-7.4._class_scope.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1851857" class="calibre29"><span class="bold">7.3. Additional Class Features</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class is pretty simple, yet it allowed us to explore quite a bit of the language support for classes. In this section, we&#8217;ll cover some additional class-related features that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> doesn&#8217;t need to use. These features include type members, in-class initializers for members of class type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code> data members, <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> member functions, returning <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> from a member function, more about how we define and use class types, and class friendship.</p><div class="calibre15">&#160;</div>
<h4 id="filepos1852806" class="calibre37"><span class="calibre5">7.3.1. Class Members Revisited</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">To explore several of these additional features, we&#8217;ll define a pair of cooperating classes named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Type Member</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> represents a window on a display. Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member that holds the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>&#8217;s contents, and three <code class="calibre23"><tt class="calibre23"><span class="calibre24">string::size_type</span></tt></code> members that represent the position of the cursor, and the height and width of the screen.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::string::size_type pos;<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;pos cursor = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;pos height = 0, width = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string contents;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1854918"/>We defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> because we want users to use that name. Users of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> shouldn&#8217;t know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to hold its data. By defining <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> member, we can hide this detail of how <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> is implemented.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There are two points to note about the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code>. First, although we used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>), we can equivalently use a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">68</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">alternative way to declare a type member using a type alias</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;using pos = std::string::size_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The second point is that, for reasons we&#8217;ll explain in &#167; <a href="076-7.4._class_scope.html#filepos1931587">7.4.1</a> (p. <a href="076-7.4._class_scope.html#filepos1931587">284</a>), unlike ordinary members, members that define types must appear before they are used. As a result, type members usually appear at the beginning of the class.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Member Functions of class <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Screen</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To make our class more useful, we&#8217;ll add a constructor that will let users define the size and contents of the screen, along with members to move the cursor and to get the character at a given location:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::string::size_type pos;<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen() = default; // <span><span class="calibre45"><span class="calibre16">needed because</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has another constructor</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cursor</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">initialized to 0 by its in-class initializer</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen(pos ht, pos wd, char c): height(ht), width(wd),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;contents(ht * wd, c) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;char get() const&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get the character at the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cursor</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return contents[cursor]; }&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">implicitly</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;inline char get(pos ht, pos wd) const; // <span><span class="calibre45"><span class="calibre16">explicitly</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;move(pos r, pos c);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">can be made</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">later</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;pos cursor = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;pos height = 0, width = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string contents;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because we have provided a constructor, the compiler will not automatically generate a default constructor for us. If our class is to have a default constructor, we must say so explicitly. In this case, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> to ask the compiler to synthesize the default constructor&#8217;s definition for us (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">It&#8217;s also worth noting that our second constructor (that takes three arguments) implicitly uses the in-class initializer for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cursor</span></tt></code> member (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">266</a>). If our class did not have an in-class initializer for <code class="calibre23"><tt class="calibre23"><span class="calibre24">cursor</span></tt></code>, we would have explicitly initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">cursor</span></tt></code> along with the other members.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1861412"/>Making Members <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inline</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Classes often have small functions that can benefit from being inlined. As we&#8217;ve seen, member functions defined inside the class are automatically <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">238</a>). Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>&#8217;s constructors and the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> that returns the character denoted by the cursor are <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> by default.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can explicitly declare a member function as <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> as part of its declaration inside the class body. Alternatively, we can specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> on the function definition that appears outside the class body:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">inline&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">we can specify</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on the definition</span></span></span><br class="calibre6"/>Screen &amp;Screen::move(pos&#160;r,&#160;pos c)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;pos row = r * width;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">compute the row location</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cursor = row + c ;&#160;&#160;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">move</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cursor</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the column within that row</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;<span><span class="calibre45"><span class="calibre16">return this object as an lvalue</span></span></span><br class="calibre6"/>}<br class="calibre6"/>char Screen::get(pos r, pos c) const // <span><span class="calibre45"><span class="calibre16">declared as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">inline</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the class</span></span></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;pos row = r * width;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">compute row location</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return contents[row + c]; // <span><span class="calibre45"><span class="calibre16">return character at the given column</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although we are not required to do so, it is legal to specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> on both the declaration and the definition. However, specifying <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> only on the definition outside the class can make the class easier to read.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">For the same reasons that we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> functions in headers (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">240</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> member functions should be defined in the same header as the corresponding class definition.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading Member Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As with nonmember functions, member functions may be overloaded (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">230</a>) so long as the functions differ by the number and/or types of parameters. The same function-matching (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) process is used for calls to member functions as for nonmember functions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class defined two versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code>. One version returns the character currently denoted by the cursor; the other returns the character at a given position specified by its row and column. The compiler uses the number of arguments to determine which version to run:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myscreen;<br class="calibre6"/>char ch = myscreen.get();// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen::get()</span></span></tt></span><br class="calibre6"/>ch = myscreen.get(0,0);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen::get(pos, pos</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">mutable</span></span></tt></span></span></tt></code> Data Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function. We indicate such members by including the <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code> keyword in their declaration.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1868141"/>A <a id="filepos1868151" href="080-defined_terms.html#filepos2063603"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">mutable</span></span></tt></span></span></tt></code>
<strong class="calibre5">data member</strong></a> is never <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, even when it is a member of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. Accordingly, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function may change a <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code> member. As an example, we&#8217;ll give <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code> member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">access_ctr</span></tt></code>, which we&#8217;ll use to track how often each <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> member function is called:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;void some_member() const;<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;mutable size_t access_ctr; // <span><span class="calibre45"><span class="calibre16">may change even in a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>void Screen::some_member() const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;++access_ctr;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">keep a count of the calls to any member function</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">whatever other work this member needs to do</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Despite the fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">some_member</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function, it can change the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">access_ctr</span></tt></code>. That member is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code> member, so any member function, including <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> functions, can change its value.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Initializers for Data Members of Class Type</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos1871041"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">In addition to defining the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class, we&#8217;ll define a window manager class that represents a collection of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screens</span></tt></code> on a given display. This class will have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>s in which each element represents a particular <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. By default, we&#8217;d like our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> class to start up with a single, default-initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Under the new standard, the best way to specify this default value is as an in-class initializer (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Window_mgr {<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screens</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">this</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Window_mgr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is tracking</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">by default, a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Window_mgr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has one standard sized blank</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::vector&lt;Screen&gt; screens{Screen(24, 80, ' ') };<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we initialize a member of class type, we are supplying arguments to a constructor of that member&#8217;s type. In this case, we list initialize our <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> member (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) with a single element initializer. That initializer contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> value that is passed to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;Screen&gt;</span></tt></code> constructor to create a one-element <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. That value is created by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> constructor that takes two size parameters and a character to create a blank screen of the given size.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, in-class initializers must use either the <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> form of initialization (which we used when we initialized the the data members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>) or the direct form of initialization using curly braces (as we do for <code class="calibre23"><tt class="calibre23"><span class="calibre24">screens</span></tt></code>).</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we provide an in-class initializer, we must do so following an <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> sign or inside braces.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1875136"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.23:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.24:</strong> Give your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class three constructors: a default constructor; a constructor that takes values for height and width and initializes the contents to hold the given number of blanks; and a constructor that takes values for height, width, and a character to use as the contents of the screen.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.25:</strong> Can <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> safely rely on the default versions of copy and assignment? If so, why? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.26:</strong> Define <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data::avg_price</span></tt></code> as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code> function.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1876631" class="calibre37"><span class="calibre5">7.3.2. Functions That Return <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">*this</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Next we&#8217;ll add functions to set the character at the cursor or at a given location:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;set(char);<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;set(pos, pos, char);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};<br class="calibre6"/>inline Screen &amp;Screen::set(char c)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;contents[cursor] = c; // <span><span class="calibre45"><span class="calibre16">set the new value at the current cursor location</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return this object as an lvalue</span></span></span><br class="calibre6"/>}<br class="calibre6"/>inline Screen &amp;Screen::set(pos r, pos col, char ch)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;contents[r*width + col] = ch;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">set specified location to given value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return this object as an lvalue</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> operation, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> members return a reference to the object on which they are called (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">259</a>). Functions that return a reference are lvalues (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">226</a>), which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">move the cursor to a given position, and set that character</span></span></span><br class="calibre6"/>myScreen.move(4,0).set('#');</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">these operations will execute on the same object. In this expression, we first <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cursor</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">myScreen</span></tt></code> and then <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> a character in <code class="calibre23"><tt class="calibre23"><span class="calibre24">myScreen</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member. That is, this statement is equivalent to</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">myScreen.move(4,0);<br class="calibre6"/>myScreen.set('#');</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Had we defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> to return <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>, rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen&amp;</span></tt></code>, this statement would execute quite differently. In this case it would be equivalent to:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1880963"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">move</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen&amp;</span></span></tt></span><br class="calibre6"/>Screen temp = myScreen.move(4,0);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the return value would be copied</span></span></span><br class="calibre6"/>temp.set('#'); // <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">myScreen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">would be unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> had a nonreference return type, then the return value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> would be a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> would change the temporary copy, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">myScreen</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Returning <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">*this</span></span></tt></span></span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Member Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Next, we&#8217;ll add an operation, which we&#8217;ll name <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code>, to print the contents of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. We&#8217;d like to be able to include this operation in a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> operations. Therefore, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> function will return a reference to the object on which it executes.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Logically, displaying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> doesn&#8217;t change the object, so we should make <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. Hence, the return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> must be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const Sales_data&amp;</span></tt></code>. However, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> returns a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we won&#8217;t be able to embed <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> into a series of actions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">display</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference, the call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">set</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an error</span></span></span><br class="calibre6"/>myScreen.display(cout).set('*');</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">myScreen</span></tt></code> is a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> won&#8217;t compile. The problem is that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> returns a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and we cannot call <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function that returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> as a reference should have a return type that is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloading Based on <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can overload a member function based on whether it is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> for the same reasons that we can overload a function based on whether a pointer parameter points to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">232</a>). The non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version will not be viable for <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> objects; we can only call <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member functions on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. We can call either version on a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, but the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version will be a better match.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this example, we&#8217;ll define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> to do the actual work of printing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Each of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> operations will call this function and then return the object on which it is executing:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">display overloaded on whether the object is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or not</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;display(std::ostream &amp;os)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ do_display(os); return *this; }<br class="calibre6"/>&#160;&#160;&#160;&#160;const Screen &amp;display(std::ostream &amp;os) const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ do_display(os); return *this; }<br class="calibre6"/><a id="filepos1890369"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function to do the work of displaying a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;void do_display(std::ostream &amp;os) const {os &lt;&lt; contents;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in any other context, when one member calls another the <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer is passed implicitly. Thus, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code>, its own <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer is implicitly passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code>. When the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code>, its <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer is implicitly converted from a pointer to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> completes, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> functions each return the object on which they execute by dereferencing <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code>. In the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version, <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> points to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, so that version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> returns an ordinary (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) reference; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member returns a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> on an object, whether that object is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> determines which version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> is called:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen(5,3);<br class="calibre6"/>const Screen blank(5, 3);<br class="calibre6"/>myScreen.set('#').display(cout);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls non</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version</span></span></span><br class="calibre6"/>blank.display(cout);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/>Advice: Use Private Utility Functions for Common Code</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some readers might be surprised that we bothered to define a separate <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> operation. After all, the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> aren&#8217;t much simpler than the action done inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code>. Why bother? We do so for several reasons:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A general desire to avoid writing the same code in more than one place.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We expect that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> operation will become more complicated as our class evolves. As the actions involved become more complicated, it makes more obvious sense to write those actions in one place, not two.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It is likely that we might want to add debugging information to <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> during development that would be eliminated in the final product version of the code. It will be easier to do so if only one definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> needs to be changed to add or remove the debugging code.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There needn&#8217;t be any overhead involved in this extra function call. We defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> inside the class body, so it is implicitly <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code>. Thus, there likely be no run-time overhead associating with calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In practice, well-designed C++ programs tend to have lots of small functions such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">do_display</span></tt></code> that are called to do the &#8220;real&#8221; work of some other set of functions.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1897012" class="calibre37"><span class="calibre5">7.3.3. Class Types</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Every class defines a unique type. Two different classes define two different types even if they define the same members. For example:</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1897322"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.27:</strong> Add the <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> operations to your version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Test your class by executing the following code:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen myScreen(5, 5, 'X');<br class="calibre6"/>myScreen.move(4,0).set('#').display(cout);<br class="calibre6"/>cout &lt;&lt; "\n";<br class="calibre6"/>myScreen.display(cout);<br class="calibre6"/>cout &lt;&lt; "\n";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.28:</strong> What would happen in the previous exercise if the return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> was <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen&amp;?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.29:</strong> Revise your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> class so that <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">display</span></tt></code> functions return <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> and check your prediction from the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.30:</strong> It is legal but redundant to refer to members through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer. Discuss the pros and cons of explicitly using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code> pointer to access members.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct First {<br class="calibre6"/>&#160;&#160;&#160;&#160;int memi;<br class="calibre6"/>&#160;&#160;&#160;&#160;int getMem();<br class="calibre6"/>};<br class="calibre6"/>struct Second {<br class="calibre6"/>&#160;&#160;&#160;&#160;int memi;<br class="calibre6"/>&#160;&#160;&#160;&#160;int getMem();<br class="calibre6"/>};<br class="calibre6"/>First obj1;<br class="calibre6"/>Second obj2 = obj1; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have different types</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Even if two classes have exactly the same member list, they are different types. The members of each class are distinct from the members of any other class (or any other scope).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">We can refer to a class type directly, by using the class name as a type name. Alternatively, we can use the class name following the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">struct</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Sales_data item1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default-initialized object of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span><br class="calibre6"/>class Sales_data item1; // <span><span class="calibre45"><span class="calibre16">equivalent declaration</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Class Declarations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as we can declare a function apart from its definition (&#167; <a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>), we can also declare a class without defining it:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen; // <span><span class="calibre45"><span class="calibre16">declaration of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1903482"/>This declaration, sometimes referred to as a <strong class="calibre5"><a id="filepos1903543" href="080-defined_terms.html#filepos2061019">forward declaration</a></strong>, introduces the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> into the program and indicates that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> refers to a class type. After a declaration and before a definition is seen, the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> is an <strong class="calibre5"><a id="filepos1903983" href="080-defined_terms.html#filepos2062145">incomplete type</a></strong>&#8212;it&#8217;s known that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> is a class type but not known what members that type contains.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use an incomplete type in only limited ways: We can define pointers or references to such types, and we can declare (but not define) functions that use an incomplete type as a parameter or return type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A class must be defined&#8212;not just declared&#8212;before we can write code that creates objects of that type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the class must be defined before a reference or pointer is used to access a member of the type. After all, if the class has not been defined, the compiler can&#8217;t know what members the class has.</p><div class="calibre22">&#160;</div>
<p class="calibre25">With one exception that we&#8217;ll describe in &#167; <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a> (p. <a href="078-7.6._static_class_members.html#filepos2028441">300</a>), data members can be specified to be of a class type only if the class has been defined. The type must be complete because the compiler needs to know how much storage the data member requires. Because a class is not defined until its class body is complete, a class cannot have data members of its own type. However, a class is considered declared (but not yet defined) as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Link_screen {<br class="calibre6"/>&#160;&#160;&#160;&#160;Screen window;<br class="calibre6"/>&#160;&#160;&#160;&#160;Link_screen *next;<br class="calibre6"/>&#160;&#160;&#160;&#160;Link_screen *prev;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.31:</strong> Define a pair of classes <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Y</span></tt></code>, in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code> has a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Y</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Y</span></tt></code> has an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1906774" class="calibre37"><span class="calibre5">7.3.4. Friendship Revisited</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class defined three ordinary nonmember functions as friends (&#167; <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">269</a>). A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In addition, a friend function can be defined inside the class body. Such functions are implicitly <code class="calibre23"><tt class="calibre23"><span class="calibre24">inline</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Friendship between Classes</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example of class friendship, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> class (&#167; <a href="075-7.3._additional_class_features.html#filepos1852806">7.3.1</a>, p. <a href="075-7.3._additional_class_features.html#filepos1852806">274</a>) will have members that will need access to the internal data of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> objects it manages. For example, let&#8217;s assume that we want to add a member, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code>
<a id="filepos1908079"/>to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> that will reset the contents of a particular <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> to all blanks. To do this job, <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> needs to access the <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> data members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. To allow this access, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> can designate <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> as its friend:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Window_mgr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">members can access the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">private</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parts of class</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend class Window_mgr;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">... rest of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The member functions of a friend class can access all the members, including the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> members, of the class granting friendship. Now that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> is a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>, we can write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Window_mgr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">location ID for each screen on the window</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;using ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reset the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">at the given position to all blanks</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void clear(ScreenIndex);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::vector&lt;Screen&gt; screens{Screen(24, 80, ' ')};<br class="calibre6"/>};<br class="calibre6"/>void Window_mgr::clear(ScreenIndex i)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">we want to clear</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Screen &amp;s = screens[i];<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reset the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">contents</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to all blanks</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;s.contents = string(s.height * s.width, ' ');<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by defining <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> as a reference to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> at position <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">screens vector</span></tt></code>. We then use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">height</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">width</span></tt></code> members of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> to compute anew <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that has the appropriate number of blank characters. We assign that string of blanks to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> were not a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>, this code would not compile. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> function would not be allowed to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">height width</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">contents</span></tt></code> members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> grants friendship to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>, all the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> are accessible to the functions in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is important to understand that friendship is not transitive. That is, if class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> has its own friends, those friends have no special access to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Each class controls which classes or functions are its friends.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Making A Member Function a Friend</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Rather than making the entire <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> class a friend, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> can instead specify that only the <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> member is allowed access. When we declare a member function to be a friend, we must specify the class of which that function is a member:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1915600"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Screen {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Window_mgr::clear</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must have been declared before class</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend void Window_mgr::clear(ScreenIndex);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">... rest of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Screen</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">class</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions. In this example, we must order our program as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; First, define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> class, which declares, but cannot define, <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear. Screen</span></tt></code> must be declared before <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> can use the members of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Next, define class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>, including a friend declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Finally, define <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code>, which can now refer to the members in <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloaded Functions and Friendship</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">overloaded</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">storeOn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">functions</span></span></span><br class="calibre6"/>extern std::ostream&amp; storeOn(std::ostream &amp;, Screen &amp;);<br class="calibre6"/>extern BitMap&amp; storeOn(BitMap &amp;, Screen &amp;);<br class="calibre6"/>class Screen {<br class="calibre6"/>&#160;&#160;&#160;&#160;// ostream <span><span class="calibre45"><span class="calibre16">version of</span></span></span> storeOn <span><span class="calibre45"><span class="calibre16">may access the</span></span></span> private <span><span class="calibre45"><span class="calibre16">parts of</span></span></span> Screen <span><span class="calibre45"><span class="calibre16">objects</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;friend std::ostream&amp; storeOn(std::ostream &amp;, Screen &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// . . .<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> makes the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">storeOn</span></tt></code> that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code> its friend. The version that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">BitMap&amp;</span></tt></code> has no special access to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Friend Declarations and Scope</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly <em class="calibre16">assumed</em> to be part of the surrounding scope. However, the friend itself is not actually declared in that scope (&#167; <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">270</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible. A declaration must exist even if we only call the friend from members of the friendship granting class:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct X {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend void f() { /* <span><span class="calibre45"><span class="calibre16">friend function can be defined in the class body</span></span></span>&#160;&#160;&#160;*/ }<br class="calibre6"/>&#160;&#160;&#160;&#160;X() { f(); } // <span><span class="calibre45"><span class="calibre16">error: no declaration for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void g();<br class="calibre6"/>&#160;&#160;&#160;&#160;void h();<br class="calibre6"/>};<br class="calibre6"/>void X::g() { return f(); } // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">hasn't been declared</span></span></span><br class="calibre6"/><a id="filepos1921738"/>void f();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declares the function defined inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">X</span></span></tt></span><br class="calibre6"/>void X::h() { return f(); } // <span><span class="calibre45"><span class="calibre16">ok: declaration for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is now in scope</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">It is important to understand that a friend declaration affects access but is not a declaration in an ordinary sense.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Remember, some compilers do not enforce the lookup rules for friends (&#167; <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">270</a>).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 7.3.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 7.32:</strong> Define your own versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> is a member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Window_mgr</span></tt></code> and a friend of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="074-7.2._access_control_and_encapsulation.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="076-7.4._class_scope.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
