<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>A.2. A Brief Tour of the Algorithms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="188-a.1._library_names_and_headers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="190-a.3._random_numbers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5414819" class="calibre29"><span class="bold">A.2. A Brief Tour of the Algorithms</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The library defines more than 100 algorithms. Learning to use these algorithms effectively requires understanding their structure rather than memorizing the details of each algorithm. Accordingly, in <a href="097-chapter_10._generic_algorithms.html#filepos2454824">Chapter 10</a> we concentrated on describing and understanding that architecture. In this section we&#8217;ll briefly describe every algorithm. In the following descriptions,</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> are iterators that denote a range of elements (&#167; <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>). Almost all of the algorithms operate on a sequence denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> is an iterator denoting the beginning of a second input sequence. If present, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2</span></tt></code> denotes the end of the second sequence. When there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">end2</span></tt></code>, the sequence denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> is assumed to be as large as the input sequence denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. The types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> need not match. However, it must be possible to apply the specified operation or given callable object to elements in the two sequences.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> is an iterator denoting a destination. The destination sequence must be able to hold as many elements as necessary given the input sequence.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">binaryPred</span></tt></code> are unary and binary predicates (&#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a>, p. <a href="100-10.3._customizing_operations.html#filepos2520495">386</a>) that return a type that can be used as a condition and take one and two arguments, respectively, that are elements in the input range.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27"><a id="filepos5417816"/>&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">comp</span></tt></code> is a binary predicate that meets the ordering requirements for key in an associative container (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryOp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">binaryOp</span></tt></code> are callable objects (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) that can be called with one and two arguments from the input range, respectively.</p></blockquote><div class="calibre15">&#160;</div>
<h4 id="filepos5418543" class="calibre37"><span class="calibre5">A.2.1. Algorithms to Find an Object</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms search an input range for a specific value or sequence of values.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each algorithm provides two overloaded versions. The first version uses equality (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>) operator of the underlying type to compare elements; the second version compares elements using the user-supplied <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">binaryPred</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Simple Find Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms look for specific values and require <em class="calibre16"><strong class="calibre5">input iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_if(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_if_not(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">count(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">count_if(beg, end, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">find</span></tt></code> returns an iterator to the first element in the input range equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if</span></tt></code> returns an iterator to the first element for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds; <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_if_not</span></tt></code> returns an iterator to the first element for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. All three return <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> if no such element exists.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> returns a count of how many times <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> occurs; <code class="calibre23"><tt class="calibre23"><span class="calibre24">count_if</span></tt></code> counts elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">all_of(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">any_of(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">none_of(beg, end, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeded for all of the elements, any element, or no element respectively. If the sequence is empty, <code class="calibre23"><tt class="calibre23"><span class="calibre24">any_of</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">all_of</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">none_of</span></tt></code> return <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms to Find One of Many Values</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require <em class="calibre16"><strong class="calibre5">forward iterators</strong></em>. They look for a repeated elements in the input sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">adjacent_find(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">adjacent_find(beg, end, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator to the first adjacent pair of duplicate elements. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> if there are no adjacent duplicate elements.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">search_n(beg, end, count, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">search_n(beg, end, count, val, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator to the beginning of a subsequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">count</span></tt></code> equal elements. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> if no such subsequence exists.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5424713"/>Algorithms to Find Subsequences</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">With the exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_first_of</span></tt></code>, these algorithms require two pairs of <em class="calibre16"><strong class="calibre5">forward iterators</strong></em>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">find_first_of</span></tt></code> uses <em class="calibre16"><strong class="calibre5">input iterators</strong></em> to denote its first sequence and <em class="calibre16"><strong class="calibre5">forward iterators</strong></em> for its second. These algorithms search for subsequences rather than for a single element.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">search(beg1, end1, beg2, end2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">search(beg1, end1, beg2, end2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator to the first position in the input range at which the second range occurs as a subsequence. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">end1</span></tt></code> if the subsequence is not found.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_first_of(beg1, end1, beg2, end2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_first_of(beg1, end1, beg2, end2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator to the first occurrence in the first range of any element from the second range. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">end1</span></tt></code> if no match is found.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_end(beg1, end1, beg2, end2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">find_end(beg1, end1, beg2, end2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">search</span></tt></code>, but returns an iterator to the last position in the input range at which the second range occurs as a subsequence. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">end1</span></tt></code> if the second subsequence is empty or is not found.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5427759" class="calibre37"><span class="calibre5">A.2.2. Other Read-Only Algorithms</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require <em class="calibre16"><strong class="calibre5">input iterators</strong></em> for their first two arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">mismatch</span></tt></code> algorithms also take an additional <em class="calibre16"><strong class="calibre5">input iterator</strong></em> that denotes the start of a second range. They also provide two overloaded versions. The first version uses equality (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>) operator of the underlying type to compare elements; the second version compares elements using the user-supplied <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">binaryPred</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">for_each(beg, end, unaryOp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Applies the callable object (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryOp</span></tt></code> to each element in its input range. The return value from <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryOp</span></tt></code> (if any) is ignored. If the iterators allow writing to elements through the dereference operator, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryOp</span></tt></code> may modify the elements.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">mismatch(beg1, end1, beg2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">mismatch(beg1, end1, beg2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Compares the elements in two sequences. Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) of iterators denoting the first elements in each sequence that do not match. If all the elements match, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> returned is <code class="calibre23"><tt class="calibre23"><span class="calibre24">end1</span></tt></code>, and an iterator into <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> offset by the size of the first sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal(beg1, end1, beg2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal(beg1, end1, beg2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Determines whether two sequences are equal. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if each element in the input range equals the corresponding element in the sequence that begins at <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5431685" class="calibre37"><span class="calibre5"><a id="filepos5431718"/>A.2.3. Binary Search Algorithms</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require <em class="calibre16"><strong class="calibre5">forward iterators</strong></em> but are optimized so that they execute much more quickly if they are called with <em class="calibre16"><strong class="calibre5">random-access iterators</strong></em>. Technically speaking, regardless of the iterator type, these algorithms execute a logarithmic number of comparisons. However, when used with forward iterators, they must make a linear number of iterator operations to move among the elements in the sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These algorithms require that the elements in the input sequence are already in order. These algorithms behave similarly to the associative container members of the same name (&#167; <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">438</a>). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_range</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> algorithms return iterators that refer to positions in the sequence at which the given element can be inserted while still preserving the sequence&#8217;s ordering. If the element is larger than any other in the sequence, then the iterator that is returned might be the off-the-end iterator.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Each algorithm provides two versions: The first uses the element type&#8217;s less-than operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>) to test elements; the second uses the given comparison operation. In the following algorithms, &#8220;<code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> is less than <code class="calibre23"><tt class="calibre23"><span class="calibre24">y</span></tt></code>&#8221; means <code class="calibre23"><tt class="calibre23"><span class="calibre24">x &lt; y</span></tt></code> or that <code class="calibre23"><tt class="calibre23"><span class="calibre24">comp(x, y)</span></tt></code> succeeds.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lower_bound(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lower_bound(beg, end, val, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator denoting the first element such that <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is not less than that element, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> if no such element exists.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">upper_bound(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">upper_bound(beg, end, val, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns an iterator denoting the first element such that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is less than that element, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> if no such element exists.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal_range(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">equal_range(beg, end, val, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member is the iterator that would be returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">lower_bound</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> is the iterator <code class="calibre23"><tt class="calibre23"><span class="calibre24">upper_bound</span></tt></code> would return.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">binary_search(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">binary_search(beg, end, val, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether the sequence contains an element that is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. Two values <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">y</span></tt></code> are considered equal if <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> is not less than <code class="calibre23"><tt class="calibre23"><span class="calibre24">y</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">y</span></tt></code> is not less than <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5437730" class="calibre37"><span class="calibre5">A.2.4. Algorithms That Write Container Elements</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Many algorithms write new values to the elements in the given sequence. These algorithms can be distinguished from one another both by the kinds of iterators they use to denote their input sequence and by whether they write elements in the input range or write to a given destination.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5438223"/>Algorithms That Write but Do Not Read Elements</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require an <em class="calibre16"><strong class="calibre5">output iterator</strong></em> that denotes a destination. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">_n</span></tt></code> versions take a second argument that specifies a count and write the given number of elements to the destination.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">fill(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">fill_n(dest, cnt, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">generate(beg, end, Gen)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">generate_n(dest, cnt, Gen</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Assigns a new value to each element in the input sequence. <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill</span></tt></code> assigns the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">generate</span></tt></code> executes the generator object <code class="calibre23"><tt class="calibre23"><span class="calibre24">Gen()</span></tt></code>. A generator is a callable object (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) that is expected to produce a different return value each time it is called. <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">generate</span></tt></code> return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">_n</span></tt></code> versions return an iterator that refers to the position immediately following the last element written to the output sequence.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Write Algorithms with Input Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Each of these algorithms reads an input sequence and writes to an output sequence. They require <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> to be an <em class="calibre16"><strong class="calibre5">output iterator</strong></em>, and the iterators denoting the input range must be <em class="calibre16"><strong class="calibre5">input iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">copy(beg, end, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">copy_if(beg, end, dest, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">copy_n(beg, n, dest</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Copies from the input range to the sequence denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> copies all elements, <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy_if</span></tt></code> copies those for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy_n</span></tt></code> copies the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> elements. The input sequence must have at least <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> elements.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">move(beg, end, dest</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> (&#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>) on each element in the input sequence to move that element to the sequence beginning at iterator <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">transform(beg, end, dest, unaryOp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">transform(beg, end, beg2, dest, binaryOp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Calls the given operation and writes the result of that operation to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>. The first version applies a unary operation to each element in the input range. The second applies a binary operation to elements from the two input sequences.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">replace_copy(beg, end, dest, old_val, new_val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">replace_copy_if(beg, end, dest, unaryPred, new_val</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Copies each element to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>, replacing the specified elements with <code class="calibre23"><tt class="calibre23"><span class="calibre24">new_val</span></tt></code>. The first version replaces those elements that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">== old_val</span></tt></code>. The second version replaces those elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">merge(beg1, end1, beg2, end2, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">merge(beg1, end1, beg2, end2, dest, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both input sequences must be sorted. Writes a merged sequence to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>. The first version compares elements using the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator; the second version uses the given comparison operation.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5445574"/>Write Algorithms with Forward Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require <em class="calibre16"><strong class="calibre5">forward iterators</strong></em> because they write to elements in their input sequence. The iterators must give write access to the elements.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">iter_swap(iter1, iter2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap_ranges(beg1, end1, beg2</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Swaps the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter1</span></tt></code> with the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter2</span></tt></code>; or swaps all of the elements in the input range with those in the second sequence beginning at <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code>. The ranges must not overlap. <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter_swap</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap_ranges</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg2</span></tt></code> incremented to denote the element just after the last one swapped.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">replace(beg, end, old_val, new_val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">replace_if(beg, end, unaryPred, new_val</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Replaces each matching element with <code class="calibre23"><tt class="calibre23"><span class="calibre24">new_val</span></tt></code>. The first version uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> to compare elements with <code class="calibre23"><tt class="calibre23"><span class="calibre24">old_val</span></tt></code>; the second version replaces those elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Write Algorithms with Bidirectional Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require the ability to go backward in the sequence, so they require <em class="calibre16"><strong class="calibre5">bidirectional iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">copy_backward(beg, end, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">move_backward(beg, end, dest</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Copies or moves elements from the input range to the given destination. Unlike other algorithms, <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> is the off-the-end iterator for the output sequence (i.e., the destination sequence will end immediately <em class="calibre16">before</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>). The last element in the input range is copied or moved to the last element in the destination, then the second-to-last element is copied/moved, and so on. Elements in the destination have the same order as those in the input range. If the range is empty, the return value is <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>; otherwise, the return denotes the element that was copied or moved from <code class="calibre23"><tt class="calibre23"><span class="calibre24">*beg</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inplace_merge(beg, mid, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inplace_merge(beg, mid, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Merges two sorted subsequences from the same sequence into a single, ordered sequence. The subsequences from <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> and from <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> are merged and written back into the original sequence. The first version uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> to compare elements; the second version uses a given comparison operation. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5451118" class="calibre37"><span class="calibre5">A.2.5. Partitioning and Sorting Algorithms</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The sorting and partitioning algorithms provide various strategies for ordering the elements of a sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each of the sorting and partitioning algorithms provides stable and unstable versions (&#167; <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a>, p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>). A stable algorithm maintains the relative order of equal elements. The stable algorithms do more work and so may run more slowly and use more memory than the unstable counterparts.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5451841"/>Partitioning Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">partition</span></tt></code> divides elements in the input range into two groups. The first group consists of those elements that satisfy the specified predicate; the second, those that do not. For example, we can partition elements in a sequence based on whether the elements are odd, or on whether a word begins with a capital letter, and so forth. These algorithms require <em class="calibre16"><strong class="calibre5">bidirectional iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_partitioned(beg, end, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if all the elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds precede those for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. Alsoreturns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the sequence is empty.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partition_copy(beg, end, dest1, dest2, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Copies elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest1</span></tt></code> and copies those for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> fails to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest2</span></tt></code>. Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) of iterators. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member denotes the end of the elements copied to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest1</span></tt></code>, and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> denotes the end of the elements copied to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest2</span></tt></code>. The input sequence may not overlap either of the destination sequences.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partition_point(beg, end, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The input sequence must be partitioned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code>. Returns an iterator one past the subrange for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds. If the returned iterator is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> must be <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> for the returned iterator and for all elements that follow that point.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">stable_partition(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partition(beg, end, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> to partition the input sequence. Elements for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds are put at the beginning of the sequence; those for which the predicate is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> are at the end. Returns an iterator just past the last element for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> if there are no such elements.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Sorting Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms require <em class="calibre16"><strong class="calibre5">random-access iterators</strong></em>. Each of the sorting algorithms provides two overloaded versions. One version uses the element&#8217;s operator <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> to compare elements; the other takes an extra parameter that specifies an ordering relation (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). <code class="calibre23"><tt class="calibre23"><span class="calibre24">partial_sort_copy</span></tt></code> returns an iterator into the destination; the other sorting algorithms return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">partial_sort</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth_element</span></tt></code> algorithms do only part of the job of sorting the sequence. They are often used to solve problems that might otherwise be handled by sorting the entire sequence. Because these algorithms do less work, they typically are faster than sorting the entire input range.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sort(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">stable_sort(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sort(beg, end, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">stable_sort(beg, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Sorts the entire range.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5459072"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_sorted(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_sorted(beg, end, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_sorted_until(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_sorted_until(beg, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">is_sorted</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether the entire input sequence is sorted. <code class="calibre23"><tt class="calibre23"><span class="calibre24">is_sorted_until</span></tt></code> finds the longest initial sorted subsequence in the input and returns an iterator just after the last element of that subsequence.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sort(beg, mid, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sort(beg, mid, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Sorts a number of elements equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> &#8211; <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> &#8211; <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> is equal to 42, then this function puts the lowest-valued elements in sorted order in the first 42 positions in the sequence. After <code class="calibre23"><tt class="calibre23"><span class="calibre24">partial_sort</span></tt></code> completes, the elements in the range from <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> up to but not including <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> are sorted. No element in the sorted range is larger than any element in the range after <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. The order among the unsorted elements is unspecified.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sort_copy(beg, end, destBeg, destEnd)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sort_copy(beg, end, destBeg, destEnd, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Sorts elements from the input range and puts as much of the sorted sequence as fits into the sequence denoted by the iterators <code class="calibre23"><tt class="calibre23"><span class="calibre24">destBeg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">destEnd</span></tt></code>. If the destination range is the same size or has more elements than the input range, then the entire input range is sorted and stored starting at <code class="calibre23"><tt class="calibre23"><span class="calibre24">destBeg</span></tt></code>. If the destination size is smaller, then only as many sorted elements as will fit are copied.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Returns an iterator into the destination that refers just past the last element that was sorted. The returned iterator will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">destEnd</span></tt></code> if that destination sequence is smaller than or equal in size to the input range.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">nth_element(beg, nth, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">nth_element(beg, nth, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The argument <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth</span></tt></code> must be an iterator positioned on an element in the input sequence. After <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth_element</span></tt></code>, the element denoted by that iterator has the value that would be there if the entire sequence were sorted. The elements in the sequence are partitioned around <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth</span></tt></code>: Those before <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth</span></tt></code> are all smaller than or equal to the value denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">nth</span></tt></code>, and the ones after it are greater than or equal to it.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5464459" class="calibre37"><span class="calibre5">A.2.6. General Reordering Operations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Several algorithms reorder the elements of the input sequence. The first two, <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code>, reorder the sequence so that the elements in the first part of the sequence meet some criteria. They return an iterator marking the end of this subsequence. Others, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">reverse</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">rotate</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">random_shuffle</span></tt></code>, rearrange the entire sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The base versions of these algorithms operate &#8220;in place&#8221;; they rearrange the elements in the input sequence itself. Three of the reordering algorithms offer &#8220;copying&#8221; versions. These <code class="calibre23"><tt class="calibre23"><span class="calibre24">_copy</span></tt></code> versions perform the same reordering but write the reordered elements to a specified destination sequence rather than changing the input sequence. These algorithms require <em class="calibre16"><strong class="calibre5">output iterator</strong></em> for the destination.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos5465884"/>Reordering Algorithms Using Forward Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms reorder the input sequence. They require that the iterators be at least <em class="calibre16"><strong class="calibre5">forward iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">remove(beg, end, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">remove_if(beg, end, unaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">remove_copy(beg, end, dest, val)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">remove_copy_if(beg, end, dest, unaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">&#8220;Removes&#8221; elements from the sequence by overwriting them with elements that are to be kept. The removed elements are those that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">== val</span></tt></code> or for which <code class="calibre23"><tt class="calibre23"><span class="calibre24">unaryPred</span></tt></code> succeeds. Returns an iterator just past the last element that was not removed.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique(beg, end, binaryPred)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_copy(beg, end, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_copy_if(beg, end, dest, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Reorders the sequence so that adjacent duplicate elements are &#8220;removed&#8221; by overwriting them. Returns an iterator just past the last unique element. The first version uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> to determine whether two elements are the same; the second version uses the predicate to test adjacent elements.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">rotate(beg, mid, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">rotate_copy(beg, mid, end, dest</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Rotates the elements around the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. The element at <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> becomes the first element; elements from <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid + 1</span></tt></code> up to but not including <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> come next, followed by the range from <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> up to but not including <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. Returns an iterator denoting the element that was originally at <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Reordering Algorithms Using Bidirectional Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Because these algorithms process the input sequence backward, they require <em class="calibre16"><strong class="calibre5">bidirectional iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">reverse(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">reverse_copy(beg, end, dest</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Reverses the elements in the sequence. <code class="calibre23"><tt class="calibre23"><span class="calibre24">reverse</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">reverse_copy</span></tt></code> returns an iterator just past the element copied to the destination.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Reordering Algorithms Using Random-Access Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Because these algorithms rearrange the elements in a random order, they require <em class="calibre16"><strong class="calibre5">random-access iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">random_shuffle(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">random_shuffle(beg, end, rand)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shuffle(beg, end, Uniform_rand</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Shuffles the elements in the input sequence. The second version takes a callable that must take a positive integer value and produce a uniformly distributed random integer in the exclusive range from 0 to the given value. The third argument <a id="filepos5472017"/>to <code class="calibre23"><tt class="calibre23"><span class="calibre24">shuffle</span></tt></code> must meet the requirements of a uniform random number generator (&#167; <a href="166-17.4._random_numbers.html#filepos4713529">17.4</a>, p. <a href="166-17.4._random_numbers.html#filepos4713529">745</a>). All three versions return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5472363" class="calibre37"><span class="calibre5">A.2.7. Permutation Algorithms</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The permutation algorithms generate lexicographical permutations of a sequence. These algorithms reorder a permutation to produce the (lexicographically) next or previous permutation of the given sequence. They return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> that indicates whether there was a next or previous permutation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To understand what is meant by next or previous permutaion, consider the following sequence of three characters: <code class="calibre23"><tt class="calibre23"><span class="calibre24">abc</span></tt></code>. There are six possible permutations on this sequence: <code class="calibre23"><tt class="calibre23"><span class="calibre24">abc</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">acb</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">bac</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">bca</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cab</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cba</span></tt></code>. These permutations are listed in lexicographical order based on the less-than operator. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">abc</span></tt></code> is the first permutation because its first element is less than or equal to the first element in every other permutation, and its second element is smaller than any permutation sharing the same first element. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">acb</span></tt></code> is the next permutation because it begins with <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>, which is smaller than the first element in any remaining permutation. Permutations that begin with <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> come before those that begin with <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For any given permutation, we can say which permutation comes before it and which after it, assuming a particular ordering between individual elements. Given the permutation <code class="calibre23"><tt class="calibre23"><span class="calibre24">bca</span></tt></code>, we can say that its previous permutation is <code class="calibre23"><tt class="calibre23"><span class="calibre24">bac</span></tt></code> and that its next permutation is <code class="calibre23"><tt class="calibre23"><span class="calibre24">cab</span></tt></code>. There is no previous permutation of the sequence <code class="calibre23"><tt class="calibre23"><span class="calibre24">abc</span></tt></code>, nor is there a next permutation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">cba</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">These algorithms assume that the elements in the sequence are unique. That is, the algorithms assume that no two elements in the sequence have the same value.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To produce the permutation, the sequence must be processed both forward and backward, thus requiring <em class="calibre16"><strong class="calibre5">bidirectional iterators</strong></em>.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_permutation(beg1, end1, beg2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">is_permutation(beg1, end1, beg2, binaryPred</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if there is a permutation of the second sequence with the same number of elements as are in the first sequence and for which the elements in the permutation and in the input sequence are equal. The first version compares elements using <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code>; the second uses the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">binaryPred</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">next_permutation(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">next_permutation(beg, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the sequence is already in its last permutation, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">next_permutation</span></tt></code> reorders the sequence to be the lowest permutation and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. Otherwise, it transforms the input sequence into the lexicographically next ordered sequence, and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The first version uses the element&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator to compare elements; the second version uses the given comparison operation.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">prev_permutation(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">prev_permutation(beg, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">next_permutation</span></tt></code>, but transforms the sequence to form the previous permutation. If this is the smallest permutation, then it reorders the sequence to be the largest permutation and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5478694" class="calibre37"><span class="calibre5"><a id="filepos5478727"/>A.2.8. Set Algorithms for Sorted Sequences</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The set algorithms implement general set operations on a sequence that is in sorted order. These algorithms are distinct from the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> container and should not be confused with operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code>s. Instead, these algorithms provide setlike behavior on an ordinary sequential container (<code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>, etc.) or other sequence, such as an input stream.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These algorithms process elements sequentially, requiring <em class="calibre16"><strong class="calibre5">input iterators</strong></em>. With the exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">includes</span></tt></code>, they also take an <em class="calibre16"><strong class="calibre5">output iterator</strong></em> denoting a destination. These algorithms return their <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> iterator incremented to denote the element just after the last one that was written to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Each algorithm is overloaded. The first version uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator for the element type. The second uses a given comparison operation.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">includes(beg, end, beg2, end2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">includes(beg, end, beg2, end2, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if every element in the second sequence is contained in the input sequence. Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> otherwise.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_union(beg, end, beg2, end2, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_union(beg, end, beg2, end2, dest, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Creates a sorted sequence of the elements that are in either sequence. Elements that are in both sequences occur in the output sequence only once. Stores the sequence in <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_intersection(beg, end, beg2, end2, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_intersection(beg, end, beg2, end2, dest, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Creates a sorted sequence of elements present in both sequences. Stores the sequence in <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_difference(beg, end, beg2, end2, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_difference(beg, end, beg2, end2, dest, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Creates a sorted sequence of elements present in the first sequence but not in the second.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_symmetric_difference(beg, end, beg2, end2, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">set_symmetric_difference(beg, end, beg2, end2, dest, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Creates a sorted sequence of elements present in either sequence but not in both.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5484033" class="calibre37"><span class="calibre5">A.2.9. Minimum and Maximum Values</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">These algorithms use either the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator for the element type or the given comparison operation. The algorithms in the first group operate on values rather than sequences. The algorithms in the second set take a sequence that is denoted by <em class="calibre16"><strong class="calibre5">input iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min(val1, val2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min(val1, val2, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min(init_list)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min(init_list, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><a id="filepos5485114"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max(val1, val2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max(val1, val2, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max(init_list)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max(init_list, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns the minimum/maximum of <code class="calibre23"><tt class="calibre23"><span class="calibre24">val1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">val2</span></tt></code> or the minimum/maximum value in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code>. The arguments must have exactly the same type as each other. Arguments and the return type are both references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, meaning that objects are not copied.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax(val1, val2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax(val1, val2, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax(init_list)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax(init_list, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">11.2.3</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2764131">426</a>) where the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member is the smaller of the supplied values and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> is the larger. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> version returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> in which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member is the smallest value in the list and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> member is the largest.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min_element(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min_element(beg, end, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max_element(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">max_element(beg, end, comp)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax_element(beg, end)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">minmax_element(beg, end, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">min_element</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">max_element</span></tt></code> return iterators referring to the smallest and largest element in the input sequence, respectively. <code class="calibre23"><tt class="calibre23"><span class="calibre24">minmax_element</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">pair</span></tt></code> whose <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> member is the smallest element and whose <code class="calibre23"><tt class="calibre23"><span class="calibre24">second</span></tt></code> member is the largest.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Lexicographical Comparison</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">This algorithm compares two sequences based on the first unequal pair of elements. Uses either the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator for the element type or the given comparison operation. Both sequences are denoted by <em class="calibre16"><strong class="calibre5">input iterators</strong></em>.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lexicographical_compare(beg1, end1, beg2, end2)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lexicographical_compare(beg1, end1, beg2, end2, comp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the first sequence is lexicographically less than the second. Otherwise, returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>. If one sequence is shorter than the other and all its elements match the corresponding elements in the longer sequence, then the shorter sequence is lexicographically smaller. If the sequences are the same size and the corresponding elements match, then neither is lexicographically less than the other.</p><div class="calibre15">&#160;</div>
<h4 id="filepos5490698" class="calibre37"><span class="calibre5">A.2.10. Numeric Algorithms</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The numeric algorithms are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">numeric</span></tt></code> header. These algorithms require <em class="calibre16"><strong class="calibre5">input iterators</strong></em>; if the algorithm writes output, it uses an <em class="calibre16"><strong class="calibre5">output iterator</strong></em> for the destination.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos5491189"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">accumulate(beg, end, init)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">accumulate(beg, end, init, binaryOp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns the sum of all the values in the input range. The summation starts with the initial value specified by <code class="calibre23"><tt class="calibre23"><span class="calibre24">init</span></tt></code>. The return type is the same type as the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">init</span></tt></code>. The first version applies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator for the element type; the second version applies the specified binary operation.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inner_product(beg1, end1, beg2, init)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">inner_product(beg1, end1, beg2, init, binOp1, binOp2</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Returns the sum of the elements generated as the product of two sequences. The two sequences are processed in tandem, and the elements from each sequence are multiplied. The product of that multiplication is summed. The initial value of the sum is specified by <code class="calibre23"><tt class="calibre23"><span class="calibre24">init</span></tt></code>. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">init</span></tt></code> determines the return type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The first version uses the element&#8217;s multiplication (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>) and addition (<code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code>) operators. The second version applies the specified binary operations, using the first operation in place of addition and the second in place of multiplication.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sum(beg, end, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">partial_sum(beg, end, dest, binaryOp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Writes a new sequence to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> in which the value of each new element represents the sum of all the previous elements up to and including its position within the input range. The first version uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> operator for the element type; the second version applies the specified binary operation. Returns the <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> iterator incremented to refer just past the last element written.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">adjacent_difference(beg, end, dest)</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">adjacent_difference(beg, end, dest, binaryOp</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Writes a new sequence to <code class="calibre23"><tt class="calibre23"><span class="calibre24">dest</span></tt></code> in which the value of each new element other than the first represents the difference between the current and previous elements. The first version uses the element type&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">-</span></tt></code> operation; the second version applies the specified binary operation.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">iota(beg, end, val</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Assigns <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> to the first element and increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. Assigns the incremented value to the next element, and again increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>, and assigns the incremented value to the next element in the sequence. Continues incrementing <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> and assigning its new value to successive elements in the input sequence.</p><div class="calibre15">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="188-a.1._library_names_and_headers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="190-a.3._random_numbers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
