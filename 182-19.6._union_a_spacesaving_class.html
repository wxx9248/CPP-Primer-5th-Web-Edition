<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.6. union: A Space-Saving Class</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="181-19.5._nested_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="183-19.7._local_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5306482" class="calibre29"><span class="bold">19.6. <code class="calibre54"><tt class="calibre54"><span class="calibre55"><span class="calibre2"><tt class="calibre54"><span class="calibre56"><span class="bold">union</span></span></tt></span></span></tt></code>: A Space-Saving Class</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos5306836" href="186-defined_terms.html#filepos5410654">union</a></span></span></tt></span></span></tt></code> is a special kind of class. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> may have multiple data members, but at any point in time, only one of the members may have a value. When a value is assigned to one member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>, all other members become undefined. The amount of storage allocated for a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> is at least as much as is needed to contain its largest data member. Like any class, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> defines a new type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Some, but not all, class features apply equally to <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> cannot have a member that is a reference, but it can have members of most other types, including, under the new standard, class types that have constructors or destructors. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> can specify protection labels to make members <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">protected</span></tt></code>. By default, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">struct</span></tt></code>s, members of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> may define member functions, including constructors and destructors. However, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> may not inherit from another class, nor may a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> be used as a base class. As a result, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> may not have virtual functions.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Defining a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s offer a convenient way to represent a set of mutually exclusive values of different types. As an example, we might have a process that handles different kinds of numeric or character data. That process might define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> to hold these values:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">objects of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Token</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have a single member, which could be of any of the listed types</span></span></span><br class="calibre6"/>union Token {<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">members are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">public</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by default</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;cval;<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;ival;<br class="calibre6"/>&#160;&#160;&#160;&#160;double dval;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> is defined starting with the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>, followed by an (optional) name for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> and a set of member declarations enclosed in curly braces. This code defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> that can hold a value that is either a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos5311636"/>Using a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code> Type</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The name of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> is a type name. Like the built-in types, by default <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s are uninitialized. We can explicitly initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> in the same way that we can explicitly initialize aggregate classes (&#167; <a href="077-7.5._constructors_revisited.html#filepos2013562">7.5.5</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2013562">298</a>) by enclosing the initializer in a pair of curly braces:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Token first_token = {'a'}; // <span><span class="calibre45"><span class="calibre16">initializes the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span><br class="calibre6"/>Token last_token; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Token</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>Token *pt = new Token;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">pointer to an uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Token</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If an initializer is present, it is used to initialize the first member. Hence, the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_token</span></tt></code> gives a value to its <code class="calibre23"><tt class="calibre23"><span class="calibre24">cval</span></tt></code> member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The members of an object of <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> type are accessed using the normal member access operators:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">last_token.cval = <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">'z';</span></span></tt></span><br class="calibre6"/>pt-&gt;ival = 42;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Assigning a value to a data member of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> object makes the other data members undefined. As a result, when we use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>, we must always know what type of value is currently stored in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>. Depending on the types of the members, retrieving or assigning to the value stored in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> through the wrong data member can lead to a crash or other incorrect program behavior.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code>s</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">An <a id="filepos5315300" href="186-defined_terms.html#filepos5398786"><strong class="calibre5">anonymous</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code></a> is an unnamed <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> that does not include any declarations between the close curly that ends its body and the semicolon that ends the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> definition (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>). When we define an anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> the compiler automatically creates an unnamed object of the newly defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">union {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">anonymous</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;char&#160;&#160;&#160;cval;<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;ival;<br class="calibre6"/>&#160;&#160;&#160;&#160;double dval;<br class="calibre6"/>};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defines an unnamed object, whose members we can access directly</span></span></span><br class="calibre6"/>cval = 'c'; // <span><span class="calibre45"><span class="calibre16">assigns a new value to the unnamed, anonymous</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>ival = 42;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">that object now holds the value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The members of an anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> are directly accessible in the scope where the anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> is defined.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> cannot have <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">protected</span></tt></code> members, nor can an anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> define member functions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code>s with Members of Class Type</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos5318655"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under earlier versions of C++, <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s could not have members of a class type that defined its own constructors or copy-control members. Under the new standard, this restriction is lifted. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s with members that define their <a id="filepos5319103"/>own constructors and/or copy-control members are more complicated to use than <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s that have members of built-in type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> has members of built-in type, we can use ordinary assignment to change the value that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> holds. Not so for <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s that have members of nontrivial class types. When we switch the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>&#8217;s value to and from a member of class type, we must construct or destroy that member, respectively: When we switch the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> to a member of class type, we must run a constructor for that member&#8217;s type; when we switch from that member, we must run its destructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> has members of built-in type, the compiler will synthesize the memberwise versions of the default constructor or copy-control members. The same is not true for <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s that have members of a class type that defines its own default constructor or one or more of the copy-control members. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member&#8217;s type defines one of these members, the compiler synthesizes the corresponding member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> as deleted (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class defines all five copy-control members and the default constructor. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and does not define its own default constructor or one of the copy-control members, then the compiler will synthesize that missing member as deleted. If a class has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member that has a deleted copy-control member, then that corresponding copy-control operation(s) of the class itself will be deleted as well.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using a Class to Manage <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">union</span></span></tt></span></span></tt></code> Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Because of the complexities involved in constructing and destroying members of class type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s with class-type members ordinarily are embedded inside another class. That way the class can manage the state transitions to and from the member of class type. As an example, we&#8217;ll add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>. We&#8217;ll define our <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> as an anonymous <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> and make it a member of a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> class will manage the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>&#8217;s members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To keep track of what type of value the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> holds, we usually define a separate object known as a <strong class="calibre5"><a id="filepos5323244" href="186-defined_terms.html#filepos5399553">discriminant</a></strong>. A discriminant lets us discriminate among the values that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> can hold. In order to keep the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> and its discriminant in sync, we&#8217;ll make the discriminant a member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> as well. Our class will define a member of an enumeration type (&#167; <a href="179-19.3._enumerations.html#filepos5202480">19.3</a>, p. <a href="179-19.3._enumerations.html#filepos5202480">832</a>) to keep track of the state of its <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The only functions our class will define are the default constructor, the copy-control members, and a set of assignment operators that can assign a value of one of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>&#8217;s types to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Token {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy control needed because our class has a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defining the move constructor and move-assignment operator is left as an exercise</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Token(): tok(INT), ival{0} { }<br class="calibre6"/>&#160;&#160;&#160;&#160;Token(const Token &amp;t): tok(t.tok) { copyUnion(t); }<br class="calibre6"/>&#160;&#160;&#160;&#160;Token &amp;operator=(const Token&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, we must destroy it; see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 19.1.2 (p. 824)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~Token() { if (tok == STR) sval.~string(); }<br class="calibre6"/><a id="filepos5326012"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assignment operators to set the differing members of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Token &amp;operator=(const std::string&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;Token &amp;operator=(char);<br class="calibre6"/>&#160;&#160;&#160;&#160;Token &amp;operator=(int);<br class="calibre6"/>&#160;&#160;&#160;&#160;Token &amp;operator=(double);<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;enum {INT, CHAR, DBL, STR} tok; // <span><span class="calibre45"><span class="calibre16">discriminant</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;union {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">anonymous</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char&#160;&#160;&#160;cval;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;ival;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double dval;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::string sval;<br class="calibre6"/>&#160;&#160;&#160;&#160;}; // <span><span class="calibre45"><span class="calibre16">each</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Token</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object has an unnamed member of this unnamed</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">check the discriminant and copy the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">union</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member as appropriate</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void copyUnion(const Token&amp;);<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our class defines a nested, unnamed, unscoped enumeration (&#167; <a href="179-19.3._enumerations.html#filepos5202480">19.3</a>, p. <a href="179-19.3._enumerations.html#filepos5202480">832</a>) that we use as the type for the member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code>. We defined <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> following the close curly and before the semicolon that ends the definition of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>, which defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> to have this unnamed <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> type (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">We&#8217;ll use <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> as our discriminant. When the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> holds an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value, <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> will have the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">INT</span></tt></code>; if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">STR</span></tt></code>; and so on.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The default constructor initializes the discriminant and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member to hold an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because our <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> has a member with a destructor, we must define our own destructor to (conditionally) destroy the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member. Unlike ordinary members of a class type, class members that are part of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> are not automatically destroyed. The destructor has no way to know which type the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> holds, so it cannot know which member to destroy.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our destructor checks whether the object being destroyed holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. If so, the destructor explicitly calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor (&#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">19.1.2</a>, p. <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">824</a>) to free the memory used by that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The destructor has no work to do if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> holds a member of any of the built-in types.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Managing the Discriminant and Destroying the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">string</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The assignment operators will set <code class="calibre23"><tt class="calibre23"><span class="calibre24">tok</span></tt></code> and assign the corresponding member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>. Like the destructor, these members must conditionally destroy the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> before assigning a new value to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Token &amp;Token::operator=(int i)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (tok == STR) sval.~string(); // <span><span class="calibre45"><span class="calibre16">if we have a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, free it</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ival = i;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign to the appropriate member</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;tok = INT;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">update the discriminant</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the current value in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we must destroy that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> before assigning a new value to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>. We do so by calling the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor. <a id="filepos5333845"/>Once we&#8217;ve cleaned up the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member, we assign the given value to the member that corresponds to the parameter type of the operator. In this case, our parameter is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, so we assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>. We update the discriminant and return.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> assignment operators behave identically to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> version and are left as an exercise. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> version differs from the others because it must manage the transition to and from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Token &amp;Token::operator=(const std::string &amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (tok == STR) // <span><span class="calibre45"><span class="calibre16">if we already hold a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, just do an assignment</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sval = s;<br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;new(&amp;sval) string(s); // <span><span class="calibre45"><span class="calibre16">otherwise construct a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;tok = STR;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">update the discriminant</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> already holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we can use the normal <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> assignment operator to give a new value to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Otherwise, there is no existing <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> object on which to invoke the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> assignment operator. Instead, we must construct a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in the memory that holds the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>. We do so using placement <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> (&#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">19.1.2</a>, p. <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">824</a>) to construct a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> at the location in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">sval</span></tt></code> resides. We initialize that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> as a copy of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> parameter. We next update the discriminant and return.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Managing Union Members That Require Copy Control</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Like the type-specific assignment operators, the copy constructor and assignment operators have to test the discriminant to know how to copy the given value. To do this common work, we&#8217;ll define a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code> from the copy constructor, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member will have been default-initialized, meaning that the first member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> will have been initialized. Because our <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is not the first member, we know that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member doesn&#8217;t hold a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. In the assignment operator, it is possible that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> already holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We&#8217;ll handle that case directly in the assignment operator. That way <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code> can assume that if its parameter holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code> must construct its own <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void Token::copyUnion(const Token &amp;t)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;switch (t.tok) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case Token::INT: ival = t.ival; break;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case Token::CHAR: cval = t.cval; break;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case Token::DBL: dval = t.dval; break;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">to copy a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, construct it using placement</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">new</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; see (</span></span></span><span><span class="calibre45"><span class="calibre16">&#167; 19.1.2 (p. 824))</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;case Token::STR: new(&amp;sval) string(t.sval); break;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This function uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">switch</span></tt></code> statement (&#167; <a href="056-5.3._conditional_statements.html#filepos1278126">5.3.2</a>, p. <a href="056-5.3._conditional_statements.html#filepos1278126">178</a>) to test the discriminant. For <a id="filepos5341005"/>the built-in types, we assign the value to the corresponding member; if the member we are copying is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we construct it.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The assignment operator must handle three possibilities for its <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member: Both the left-hand and right-hand operands might be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>; neither operand might be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>; or one but not both operands might be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Token &amp;Token::operator=(const Token &amp;t)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if this object holds a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">doesn't, we have to free the old</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (tok == STR &amp;&amp; t.tok != STR) sval.~string();<br class="calibre6"/>&#160;&#160;&#160;&#160;if (tok == STR &amp;&amp; t.tok == STR)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sval = t.sval;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no need to construct a new</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;copyUnion(t);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">will construct a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t.tok</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">STR</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;tok = t.tok;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> in the left-hand operand holds a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, but the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> in the right-hand does not, then we have to first free the old <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> before assigning a new value to the union member. If both <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>s hold a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we can use the normal <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> assignment operator to do the copy. Otherwise, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code> to do the assignment. Inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">copyUnion</span></tt></code>, if the right-hand operand is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we&#8217;ll construct a new <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code> member of the left-hand operand. If neither operand is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, then ordinary assignment will suffice.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 19.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.21:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.22:</strong> Add a member of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> class.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.23:</strong> Add a move constructor and move assignment to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.24:</strong> Explain what happens if we assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Token</span></tt></code> object to itself.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 19.25:</strong> Write assignment operators that take values of each type in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">union</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="181-19.5._nested_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="183-19.7._local_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
