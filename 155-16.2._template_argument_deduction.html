<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>16.2. Template Argument Deduction</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="154-16.1._defining_a_template.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="156-16.3._overloading_and_templates.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4324217" class="calibre29"><span class="bold">16.2. Template Argument Deduction</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">We&#8217;ve seen that, by default, the compiler uses the arguments in a call to determine the template parameters for a function template. The process of determining the template arguments from the function arguments is known as <strong class="calibre5"><a id="filepos4324590" href="160-defined_terms.html#filepos4554571">template argument deduction</a></strong>. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call.</p><div class="calibre15">&#160;</div>
<h4 id="filepos4324892" class="calibre37"><span class="calibre5"><a id="filepos4324925"/>16.2.1. Conversions and Template Type Parameters</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As with a nontemplate function, the arguments we pass in a call to a function template are used to initialize that function&#8217;s parameters. Function parameters whose type uses a template type parameter have special initialization rules. Only a very limited number of conversions are automatically applied to such arguments. Rather than converting the arguments, the compiler generates a new instantiation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As usual, top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) in either the parameter or the argument are ignored. The only other conversions performed in a call to a function template are</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> conversions: A function parameter that is a reference (or pointer) to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> can be passed a reference (or pointer) to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Array- or function-to-pointer conversions: If the function parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be converted to a pointer to its first element. Similarly, a function argument will be converted to a pointer to the function&#8217;s type (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">161</a>).</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Other conversions, such as the arithmetic conversions (&#167; <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">159</a>), derived-to-base (&#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), and user-defined conversions (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">294</a>, and &#167; <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">14.9</a>, p. <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">579</a>), are not performed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As examples, consider calls to the functions <code class="calibre23"><tt class="calibre23"><span class="calibre24">fobj</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">fref</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">fobj</span></tt></code> function copies its parameters, whereas <code class="calibre23"><tt class="calibre23"><span class="calibre24">fref</span></tt></code>&#8217;s parameters are references:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; T fobj(T, T); // <span><span class="calibre45"><span class="calibre16">arguments are copied</span></span></span><br class="calibre6"/>template &lt;typename T&gt; T fref(const T&amp;, const T&amp;); // <span><span class="calibre45"><span class="calibre16">references</span></span></span><br class="calibre6"/>string s1("a value");<br class="calibre6"/>const string s2("another value");<br class="calibre6"/>fobj(s1, s2); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fobj(string, string); const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is ignored</span></span></span><br class="calibre6"/>fref(s1, s2); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fref(const string&amp;, const string&amp;)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses premissible conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s1</span></span></tt></span><br class="calibre6"/>int a[10], b[42];<br class="calibre6"/>fobj(a, b); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f(int*, int*)</span></span></tt></span><br class="calibre6"/>fref(a, b); // <span><span class="calibre45"><span class="calibre16">error: array types don't match</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first pair of calls, we pass a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>. Even though these types do not match exactly, both calls are legal. In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fobj</span></tt></code>, the arguments are copied, so whether the original object is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> doesn&#8217;t matter. In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fref</span></tt></code>, the parameter type is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> for a reference parameter is a permitted conversion, so this call is legal.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the next pair of calls, we pass array arguments in which the arrays are different sizes and hence have different types. In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fobj</span></tt></code>, the fact that the array types differ doesn&#8217;t matter. Both arrays are converted to pointers. The template parameter type in <code class="calibre23"><tt class="calibre23"><span class="calibre24">fobj</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code>. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fref</span></tt></code>, however, is illegal. When the parameter is a reference, the arrays are not converted to pointers (&#167; <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a>, p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>). The types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> don&#8217;t match, so the call is in error.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos4331654"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> conversions and array or function to pointer are the only automatic conversions for arguments to parameters with template types.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Function Parameters That Use the Same Template Parameter Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A template type parameter can be used as the type of more than one function parameter. Because there are limited conversions, the arguments to such parameters must have essentially the same type. If the deduced types do not match, then the call is an error. For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> function (&#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">652</a>) takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code> parameters. Its arguments must have essentially the same type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">long lng;<br class="calibre6"/>compare(lng, 1024); // <span><span class="calibre45"><span class="calibre16">error: cannot instantiate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare(long, int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call is in error because the arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> don&#8217;t have the same type. The template argument deduced from the first argument is <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>; the one for the second is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. These types don&#8217;t match, so template argument deduction fails.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we want to allow normal conversions on the arguments, we can define the function with two type parameters:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">argument types can differ but must be compatible</span></span></span><br class="calibre6"/>template &lt;typename A, typename B&gt;<br class="calibre6"/>int flexibleCompare(const A&amp; v1, const B&amp; v2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v1 &lt; v2) return -1;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (v2 &lt; v1) return 1;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Now the user may supply arguments of different types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">long lng;<br class="calibre6"/>flexibleCompare(lng, 1024); // <span><span class="calibre45"><span class="calibre16">ok: calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flexibleCompare(long, int</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Of course, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator must exist that can compare values of those types.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Normal Conversions Apply for Ordinary Arguments</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A function template can have parameters that are defined using ordinary types&#8212;that is, types that do not involve a template type parameter. Such arguments have no special processing; they are converted as usual to the corresponding type of the parameter (&#167; <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">203</a>). For example, consider the following template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; ostream &amp;print(ostream &amp;os, const T &amp;obj)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return os &lt;&lt; obj;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first function parameter has a known type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code>. The second parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code>, has a template parameter type. Because the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code> is fixed, normal conversions are applied to arguments passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">os</span></tt></code> when <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> is called:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(cout, 42); // <span><span class="calibre45"><span class="calibre16">instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(ostream&amp;, int)</span></span></tt></span><br class="calibre6"/>ofstream f("output");<br class="calibre6"/>print(f, 10);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(ostream&amp;, int);</span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">converts f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ostream&amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first call, the type of the first argument exactly matches the type of the first parameter. This call will cause a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code> and an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> to be instantiated. In the second call, the first argument is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ofstream</span></tt></code> and there is a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">ofstream</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code> (&#167; <a href="084-8.2._file_input_and_output.html#filepos2114912">8.2.1</a>, p. <a href="084-8.2._file_input_and_output.html#filepos2114912">317</a>). Because the type of this parameter does not depend on a template parameter, the compiler will implicitly convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Normal conversions are applied to arguments whose type is not a template parameter.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.32:</strong> What happens during template argument deduction?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.33:</strong> Name two type conversions allowed on function arguments involved in template argument deduction.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.34:</strong> Given only the following code, explain whether each of these calls is legal. If so, what is the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;class T&gt; int compare(const T&amp;, const T&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(a) <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare("hi", "world");</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(b) <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare("bye", "dad");</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.35:</strong> Which, if any, of the following calls are errors? If the call is legal, what is the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>? If the call is not legal, what is the problem?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; T calc(T, int);<br class="calibre6"/>template &lt;typename T&gt; T fcn(T, T);<br class="calibre6"/>double d;&#160;&#160;&#160;&#160;float f;&#160;&#160;&#160;&#160;char c;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(a) <code class="calibre23"><tt class="calibre23"><span class="calibre24">calc(c, 'c');</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(b) <code class="calibre23"><tt class="calibre23"><span class="calibre24">calc(d, f);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(c) <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn(c, 'c');</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(d) <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn(d, f);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.36:</strong> What happens in the following calls:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; f1(T, T);<br class="calibre6"/>template &lt;typename T1, typename T2) f2(T1, T2);<br class="calibre6"/>int i = 0, j = 42, *p1 = &amp;i, *p2 = &amp;j;<br class="calibre6"/>const int *cp1 = &amp;i, *cp2 = &amp;j;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(a) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1(p1, p2);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(b) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2(p1, p2);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(c) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1(cp1, cp2);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(d) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2(cp1, cp2);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(e) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1(p1, cp1);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(f) <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2(p1, cp1);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4344365" class="calibre37"><span class="calibre5">16.2.2. Function-Template Explicit Arguments</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">In some situations, it is not possible for the compiler to deduce the types of the template arguments. In others, we want to allow the user to control the template <a id="filepos4344735"/>instantiation. Both cases arise most often when a function return type differs from any of those used in the parameter list.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Specifying an Explicit Template Argument</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example in which we want to let the user specify which type to use, we&#8217;ll define a function template named <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> that takes arguments of two different types. We&#8217;d like to let the user specify the type of the result. That way the user can choose whatever precision is appropriate.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can let the user control the type of the return by defining a third template parameter to represent the return type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">cannot be deduced: it doesn't appear in the function parameter list</span></span></span><br class="calibre6"/>template &lt;typename T1, typename T2, typename T3&gt;<br class="calibre6"/>T1 sum(T2, T3);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, there is no argument whose type can be used to deduce the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T1</span></tt></code>. The caller must provide an <strong class="calibre5"><a id="filepos4346395" href="160-defined_terms.html#filepos4550678">explicit template argument</a></strong> for this parameter on each call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We supply an explicit template argument to a call the same way that we define an instance of a class template. Explicit template arguments are specified inside angle brackets after the function name and before the argument list:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is explicitly specified;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are inferred from the argument types</span></span></span><br class="calibre6"/>auto val3 = sum&lt;long long&gt;(i, lng); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">long long sum(int, long</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call explicitly specifies the type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T1</span></tt></code>. The compiler will deduce the types for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T2</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">T3</span></tt></code> from the types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">lng</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter, the second argument to the second parameter, and so on. An explicit template argument may be omitted only for the trailing (right-most) parameters, and then only if these can be deduced from the function parameters. If our <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> function had been written as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">poor design: users must explicitly specify all three template parameters</span></span></span><br class="calibre6"/>template &lt;typename T1, typename T2, typename T3&gt;<br class="calibre6"/>T3 alternative_sum(T2, T1);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">then we would always have to specify arguments for all three parameters:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: can't infer initial template parameters</span></span></span><br class="calibre6"/>auto val3 = alternative_sum&lt;long long&gt;(i, lng);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: all three parameters are explicitly specified</span></span></span><br class="calibre6"/>auto val2 = alternative_sum&lt;long long, int, long&gt;(i, lng);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Normal Conversions Apply for Explicitly Specified Arguments</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">For the same reasons that normal conversions are permitted for parameters that are defined using ordinary types (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4324892">16.2.1</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4324892">680</a>), normal conversions also apply for arguments whose template type parameter is explicitly specified:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4350678"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">long lng;<br class="calibre6"/>compare(lng, 1024);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: template parameters don't match</span></span></span><br class="calibre6"/>compare&lt;long&gt;(lng, 1024); // <span><span class="calibre45"><span class="calibre16">ok: instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare(long, long)</span></span></tt></span><br class="calibre6"/>compare&lt;int&gt;(lng, 1024);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: instantiates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare(int, int)</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, the first call is in error because the arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> must have the same type. If we explicitly specify the template parameter type, normal conversions apply. Thus, the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare&lt;long&gt;</span></tt></code> is equivalent to calling a function taking two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const long&amp;</span></tt></code> parameters. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter is automatically converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>. In the second call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is explicitly specified as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">lng</span></tt></code> is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.37:</strong> The library <code class="calibre23"><tt class="calibre23"><span class="calibre24">max</span></tt></code> function has two function parameters and returns the larger of its arguments. This function has one template type parameter. Could you call <code class="calibre23"><tt class="calibre23"><span class="calibre24">max</span></tt></code> passing it an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>? If so, how? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.38:</strong> When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">451</a>), we have to provide an explicit template argument. Explain why that argument is needed and how it is used.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.39:</strong> Use an explicit template argument to make it sensible to pass two string literals to the original version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> from &#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a> (p. <a href="154-16.1._defining_a_template.html#filepos4156441">652</a>).</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4354202" class="calibre37"><span class="calibre5">16.2.3. Trailing Return Types and Type Transformation</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Using an explicit template argument to represent a template function&#8217;s return type works well when we want to let the user determine the return type. In other cases, requiring an explicit template argument imposes a burden on the user with no compensating advantage. For example, we might want to write a function that takes a pair of iterators denoting a sequence and returns a reference to an element in the sequence:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename It&gt;<br class="calibre6"/>??? &amp;fcn(It beg, It end)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process the range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *beg;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return a reference to an element from the range</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We don&#8217;t know the exact type we want to return, but we do know that we want that type to be a reference to the element type of the sequence we&#8217;re processing:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; vi = {1,2,3,4,5};<br class="calibre6"/>Blob&lt;string&gt; ca = { "hi", "bye" };<br class="calibre6"/>auto &amp;i = fcn(vi.begin(), vi.end()); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should return</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><br class="calibre6"/>auto &amp;s = fcn(ca.begin(), ca.end()); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should return</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string&amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos4356678"/><a id="filepos4356686"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Here, we know that our function will return <code class="calibre23"><tt class="calibre23"><span class="calibre24">*beg</span></tt></code>, and we know that we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(*beg)</span></tt></code> to obtain the type of that expression. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> doesn&#8217;t exist until the parameter list has been seen. To define this function, we must use a trailing return type (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>). Because a trailing return appears after the parameter list, it can use the function&#8217;s parameters:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">a trailing return lets us declare the return type after the parameter list is seen</span></span></span><br class="calibre6"/>template &lt;typename It&gt;<br class="calibre6"/>auto fcn(It beg, It end) -&gt; decltype(*beg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process the range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *beg;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return a reference to an element from the range</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve told the compiler that <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code>&#8217;s return type is the same as the type returned by dereferencing its <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> parameter. The dereference operator returns an lvalue (&#167; <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">136</a>), so the type deduced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> is a reference to the type of the element that <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> denotes. Thus, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> is called on a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, the return type will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>. If the sequence is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, the return will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Type Transformation Library Template Classes</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes we do not have direct access to the type that we need. For example, we might want to write a function similar to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fcn</span></tt></code> that returns an element by value (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>), rather than a reference to an element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The problem we face in writing this function is that we know almost nothing about the types we&#8217;re passed. In this function, the only operations we know we can use are iterator operations, and there are no iterator operations that yield elements (as opposed to references to elements).</p><div class="calibre22">&#160;</div>
<p class="calibre25">To obtain the element type, we can use a library <strong class="calibre5"><a id="filepos4360331" href="160-defined_terms.html#filepos4557460">type transformation</a></strong> template. These templates are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_traits</span></tt></code> header. In general the classes in <code class="calibre23"><tt class="calibre23"><span class="calibre24">type_traits</span></tt></code> are used for so-called template metaprogramming, a topic that is beyond the scope of this Primer. However, the type transformation templates are useful in ordinary programming as well. These templates are described in <a href="155-16.2._template_argument_deduction.html#filepos4361085">Table 16.1</a> and we&#8217;ll see how they are implemented in &#167; <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a> (p. <a href="158-16.5._template_specializations.html#filepos4508634">710</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4361085"/>Table 16.1. Standard Type Transformation Templates</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00106.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">In this case, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> to obtain the element type. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> template has one template type parameter and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">(public)</span></tt></code> type member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code>. If we instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> with a reference type, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> will be the referred-to type. For example, if we instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference&lt;int&amp;&gt;</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> member will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Similarly, if we instantiate <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference&lt;string&amp;&gt;, type</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and so on. More generally, given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> is an iterator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">remove_reference&lt;decltype(*beg)&gt;::type</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">will be the type of the element to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> refers: <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(*beg)</span></tt></code> returns the reference type of the element type. <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference::type</span></tt></code> strips off the reference, leaving the element type itself.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> and a trailing return with <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code>, we can write our function to return a copy of an element&#8217;s value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4363733"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">must use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">typename</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to use a type member of a template parameter; see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 16.1.3 (p. 670)</span></span></span><br class="calibre6"/>template &lt;typename It&gt;<br class="calibre6"/>auto fcn2(It beg, It end) -&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;typename remove_reference&lt;decltype(*beg)&gt;::type<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process the range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *beg;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return a copy of an element from the range</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Note that <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> is member of a class that depends on a template parameter. As a result, we must use <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename</span></tt></code> in the declaration of the return type to tell the compiler that <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> represents a type (&#167; <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">670</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each of the type transformation templates described in <a href="155-16.2._template_argument_deduction.html#filepos4361085">Table 16.1</a> works similarly to <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code>. Each template has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> that represents a type. That type may be related to the template&#8217;s own template type parameter in a way that is indicated by the template&#8217;s name. If it is not possible (or not necessary) to transform the template&#8217;s parameter, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> member is the template parameter type itself. For example, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is a pointer type, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_pointer&lt;T&gt;::type</span></tt></code> is the type to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> points. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> isn&#8217;t a pointer, then no transformation is needed. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> is the same type as <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4366706"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.40:</strong> Is the following function legal? If not, why not? If it is legal, what, if any, are the restrictions on the argument type(s) that can be passed, and what is the return type?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename It&gt;<br class="calibre6"/>auto fcn3(It beg, It end) -&gt; decltype(*beg + 0)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process the range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *beg;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return a copy of an element from the range</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.41:</strong> Write a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> with a return type that is guaranteed to be large enough to hold the result of the addition.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4368159" class="calibre37"><span class="calibre5">16.2.4. Function Pointers and Argument Deduction</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">When we initialize or assign a function pointer (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>) from a function template, the compiler uses the type of the pointer to deduce the template argument(s).</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, assume we have a function pointer that points to a function returning an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> that takes two parameters, each of which is a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int</span></tt></code>. We can use that pointer to point to an instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the instantiation</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int compare(const int&amp;, const int&amp;)</span></span></tt></span><br class="calibre6"/>int (*pf1)(const int&amp;, const int&amp;) = compare;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of the parameters in <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf1</span></tt></code> determines the type of the template argument for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>. The template argument for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. The pointer <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf1</span></tt></code> points to the instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. It is an error if the template arguments cannot be determined from the function pointer type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">overloaded versions of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">func</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">each takes a different function pointer type</span></span></span><br class="calibre6"/>void func(int(*)(const string&amp;, const string&amp;));<br class="calibre6"/>void func(int(*)(const int&amp;, const int&amp;));<br class="calibre6"/>func(compare); // <span><span class="calibre45"><span class="calibre16">error: which instantiation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span><span><span class="calibre45"><span class="calibre16">?</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem is that by looking at the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code>&#8217;s parameter, it is not possible to determine a unique type for the template argument. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> could instantiate the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">compare</span></tt></code> that takes <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s or the version that takes <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Because it is not possible to identify a unique instantiation for the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code>, this call won&#8217;t compile.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can disambiguate the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> by using explicit template arguments:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: explicitly specify which version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to instantiate</span></span></span><br class="calibre6"/>func(compare&lt;int&gt;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">passing</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">compare(const int&amp;, const int&amp;</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This expression calls the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">func</span></tt></code> that takes a function pointer with two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const int&amp;</span></tt></code> parameters.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos4373730"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When the address of a function-template instantiation is taken, the context must be such that it allows a unique type or value to be determined for each template parameter.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4374182" class="calibre37"><span class="calibre5">16.2.5. Template Argument Deduction and References</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In order to understand type deduction from a call to a function such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f(T &amp;p);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">in which the function&#8217;s parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a reference to a template type parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>, it is important to keep in mind two points: Normal reference binding rules apply; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are low level, not top level.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Type Deduction from Lvalue Reference Function Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a function parameter is an ordinary (lvalue) reference to a template type parameter (i.e., that has the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;</span></tt></code>), the binding rules say that we can pass only an lvalue (e.g., a variable or an expression that returns a reference type). That argument might or might not have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. If the argument is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> will be deduced as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f1(T&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">argument must be an lvalue</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">calls to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">use the referred-to type of the argument as the template parameter type</span></span></span><br class="calibre6"/>f1(i);&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>f1(ci);&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>f1(5);&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">error: argument to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter must be an lvalue</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">If a function parameter has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code>, normal binding rules say that we can pass any kind of argument&#8212;an object (<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or otherwise), a temporary, or a literal value. When the function parameter is itself <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the type deduced for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> will not be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> is already part of the <em class="calibre16">function</em> parameter type; therefore, it does not also become part of the <em class="calibre16">template</em> parameter type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f2(const T&amp;); // <span><span class="calibre45"><span class="calibre16">can take an rvalue</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">parameter in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">&amp;;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the argument is irrelevant</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">in each of these three calls,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s function parameter is inferred as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span><br class="calibre6"/>f2(i);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>f2(ci); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ci</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, but template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>f2(5);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const &amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter can be bound to an rvalue;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Type Deduction from Rvalue Reference Function Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When a function parameter is an rvalue reference (&#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>) (i.e., has the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code>, normal binding rules say that we can pass an rvalue to this parameter. When we do so, type deduction behaves similarly to deduction for an ordinary lvalue reference function parameter. The deduced type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is the type of the rvalue:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f3(T&amp;&amp;);<br class="calibre6"/>f3(42); // <span><span class="calibre45"><span class="calibre16">argument is an rvalue of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4383510"/>Reference Collapsing and Rvalue Reference Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> object, we might think that a call such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3(i)</span></tt></code> would be illegal. After all, <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is an lvalue, and normally we cannot bind an rvalue reference to an lvalue. However, the language defines two exceptions to normal binding rules that allow this kind of usage. These exceptions are the foundation for how library facilities such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> operate.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The first exception affects how type deduction is done for rvalue reference parameters. When we pass an lvalue (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>) to a function parameter that is an rvalue reference to a template type parameter (e.g, <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code>, the compiler deduces the template type parameter as the argument&#8217;s lvalue reference type. So, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3(i)</span></tt></code>, the compiler deduces the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Deducing <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code> would seem to mean that <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code>&#8217;s function parameter would be an rvalue reference to the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. Ordinarily, we cannot (directly) define a reference to a reference (&#167; <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">51</a>). However, it is possible to do so indirectly through a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) or through a template type parameter.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos4385972"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">In such contexts, we see the second exception to the normal binding rules: If we indirectly create a reference to a reference, then those references &#8220;collapse.&#8221; In all but one case, the references collapse to form an ordinary lvalue reference type. The new standard, expanded the collapsing rules to include rvalue references. References collapse to form an rvalue reference only in the specific case of an rvalue reference to an rvalue reference. That is, for a given type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X</span></tt></code>:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp; &amp;, X&amp; &amp;&amp;</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;&amp; &amp;</span></tt></code> all collapse to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The type <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;&amp; &amp;&amp;</span></tt></code> collapses to <code class="calibre23"><tt class="calibre23"><span class="calibre24">X&amp;&amp;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Reference collapsing applies only when a reference to a reference is created indirectly, such as in a type alias or a template parameter.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The combination of the reference collapsing rule and the special rule for type deduction for rvalue reference parameters means that we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> on an lvalue. When we pass an lvalue to <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code>&#8217;s (rvalue reference) function parameter, the compiler will deduce <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> as an lvalue reference type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f3(i);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">argument is an lvalue; template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><br class="calibre6"/>f3(ci); // <span><span class="calibre45"><span class="calibre16">argument is an lvalue; template parameter</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int&amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When a <em class="calibre16">template</em> parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is deduced as a reference type, the collapsing rule says that the <em class="calibre16">function</em> parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code> collapses to an lvalue reference type. For example, the resulting instantiation for <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3(i)</span></tt></code> would be something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">invalid code, for illustration purposes only</span></span></span><br class="calibre6"/>void f3&lt;int&amp;&gt;(int&amp; &amp;&amp;); // <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, function parameter is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp; &amp;&amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The function parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp; &amp;&amp;</span></tt></code>, which collapses to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. Thus, even though the form of the function parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> is an rvalue reference (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code>, this call instantiates <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> with an lvalue reference type (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;)</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f3&lt;int&amp;&gt;(int&amp;); // <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, function parameter collapses to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4392563"/>There are two important consequences from these rules:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A function parameter that is an rvalue reference to a template type parameter (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code> can be bound to an lvalue; and</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the argument is an lvalue, then the deduced template argument type will be an lvalue reference type and the function parameter will be instantiated as an (ordinary) lvalue reference parameter (<code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;</span></tt></code>)</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">It is also worth noting that by implication, we can pass any type of argument to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code> function parameter. A parameter of such a type can (obviously) be used with rvalues, and as we&#8217;ve just seen, can be used by lvalues as well.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An argument of any type can be passed to a function parameter that is an rvalue reference to a template parameter type (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code>. When an lvalue is passed to such a parameter, the function parameter is instantiated as an ordinary, lvalue reference (<code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;</span></tt></code>).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Writing Template Functions with Rvalue Reference Parameters</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that the template parameter can be deduced to a reference type can have surprising impacts on the code inside the template:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f3(T&amp;&amp; val)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;T t = val;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy or binding a reference?</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;t = fcn(t); // <span><span class="calibre45"><span class="calibre16">does the assignment change only</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span><span><span class="calibre45"><span class="calibre16">?</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (val == t) { /* <span><span class="calibre45"><span class="calibre16">...</span></span></span> */ } // <span><span class="calibre45"><span class="calibre16">always</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference type</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> on an rvalue, such as the literal 42, <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. In this case, the local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and is initialized by copying the value of the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. When we assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>, the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> remains unchanged.</p><div class="calibre15">&#160;</div>
<p class="calibre25">On the other hand, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> on the lvalue <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. When we define and initialize the local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>, that variable has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. The initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> binds <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>. When we assign to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>, we change <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> at the same time. In this instantiation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> test will always yield <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is surprisingly hard to write code that is correct when the types involved might be plain (nonreference) types or reference types (although the type transformation classes such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> can help (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4354202">16.2.3</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4354202">684</a>)).</p><div class="calibre22">&#160;</div>
<p class="calibre25">In practice, rvalue reference parameters are used in one of two contexts: Either the template is forwarding its arguments, or the template is overloaded. We&#8217;ll look at forwarding in &#167; <a href="155-16.2._template_argument_deduction.html#filepos4417678">16.2.7</a> (p. <a href="155-16.2._template_argument_deduction.html#filepos4417678">692</a>) and at template overloading in &#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">694</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">For now, it&#8217;s worth noting that function templates that use rvalue references often use overloading in the same way as we saw in &#167; <a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a> (p. <a href="126-13.6._moving_objects.html#filepos3505762">544</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f(T&amp;&amp;);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">binds to</span></span></span>
<span><span class="calibre45"><span class="calibre16">non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">rvalues</span></span></span><br class="calibre6"/>template &lt;typename T&gt; void f(const T&amp;); // <span><span class="calibre45"><span class="calibre16">lvalues and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">rvalues</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with nontemplate functions, the first version will bind to modifiable rvalues and the second to lvalues or to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> rvalues.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4400661"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.42:</strong> Determine the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> and of <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> in each of the following calls:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void g(T&amp;&amp; val);<br class="calibre6"/>int i = 0; const int ci = i;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(a) <code class="calibre23"><tt class="calibre23"><span class="calibre24">g(i);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(b) <code class="calibre23"><tt class="calibre23"><span class="calibre24">g(ci);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(c) <code class="calibre23"><tt class="calibre23"><span class="calibre24">g(i * ci);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.43:</strong> Using the function defined in the previous exercise, what would the template parameter of <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> be if we called <code class="calibre23"><tt class="calibre23"><span class="calibre24">g(i = ci)?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.44:</strong> Using the same three calls as in the first exercise, determine the types for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> if <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s function parameter is declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> (not <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;)</span></tt></code>. What if <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s function parameter is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.45:</strong> Given the following template, explain what happens if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> on a literal value such as 42. What if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> on a variable of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void g(T&amp;&amp; val) { vector&lt;T&gt; v; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4403933" class="calibre37"><span class="calibre5">16.2.6. Understanding <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::move</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">The library <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> function (&#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>) is a good illustration of a template that uses rvalue references. Fortunately, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> without understanding the template mechanisms that it uses. However, looking at how <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> works can help cement our general understanding, and use, of templates.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>) we noted that although we cannot directly bind an rvalue reference to an lvalue, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> to obtain an rvalue reference bound to an lvalue. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> can take arguments of essentially any type, it should not be surprising that <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is a function template.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">How <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::move</span></span></tt></span></span></tt></code> Is Defined</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The standard defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">for the use of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">typename</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the return type and the cast see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 16.1.3 (p. 670)</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">remove_reference</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is covered in</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 16.2.3 (p. 684)</span></span></span><br class="calibre6"/>template &lt;typename T&gt;<br class="calibre6"/>typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static_cast</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">covered in</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 4.11.3 (p. 163)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code is short but subtle. First, <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>&#8217;s function parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code>, is an rvalue reference to a template parameter type. Through reference collapsing, this parameter can match arguments of any type. In particular, we can pass either an lvalue or an rvalue to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s1("hi!"), s2;<br class="calibre6"/>s2 = std::move(string("bye!")); // <span><span class="calibre45"><span class="calibre16">ok: moving from an rvalue</span></span></span><br class="calibre6"/>s2 = std::move(s1);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but after the assigment</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has indeterminate value</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4408477"/>How <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::move</span></span></tt></span></span></tt></code> Works</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">In the first assignment, the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is the rvalue result of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> constructor, <code class="calibre23"><tt class="calibre23"><span class="calibre24">string("bye")</span></tt></code>. As we&#8217;ve seen, when we pass an rvalue to an rvalue reference function parameter, the type deduced from that argument is the referred-to type (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">687</a>). Thus, in <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move(string("bye!"))</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The deduced type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Therefore, <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> is instantiated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference&lt;string&gt;</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>&#8217;s function parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>, has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">Accordingly, this call instantiates <code class="calibre23"><tt class="calibre23"><span class="calibre24">move&lt;string&gt;</span></tt></code>, which is the function</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string&amp;&amp; move(string &amp;&amp;t)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The body of this function returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast&lt;string&amp;&amp;&gt;(t)</span></tt></code>. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> is already <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>, so the cast does nothing. Therefore, the result of this call is the rvalue reference it was given.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Now consider the second assignment, which calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move(s1)</span></tt></code>. In this call, the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is an lvalue. This time:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The deduced type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code> (reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, not plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Therefore, <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference</span></tt></code> is instantiated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">type</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">remove_reference&lt;string&amp;&gt;</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>,</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> is still <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>&#8217;s function parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>, instantiates as <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp; &amp;&amp;</span></tt></code>, which collapses to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Thus, this call instantiates <code class="calibre23"><tt class="calibre23"><span class="calibre24">move&lt;string&amp;&gt;</span></tt></code>, which is</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string&amp;&amp; move(string &amp;t)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">and which is exactly what we&#8217;re after&#8212;we want to bind an rvalue reference to an lvalue. The body of this instantiation returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast&lt;string&amp;&amp;&gt;(t)</span></tt></code>. In this case, the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code>, which the cast converts to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static_cast</span></span></tt></span></span></tt></code> from an Lvalue to an Rvalue Reference Is Permitted</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ordinarily, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> can perform only otherwise legitimate conversions (&#167; <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a>, p. <a href="049-4.11._type_conversions.html#filepos1189032">163</a>). However, there is again a special dispensation for rvalue references: Even though we cannot implicitly convert an lvalue to an rvalue reference, we can <em class="calibre16">explicitly</em> cast an lvalue to an rvalue reference using <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4415674"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Binding an rvalue reference to an lvalue gives code that operates on the rvalue reference permission to clobber the lvalue. There are times, such as in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec reallocate</span></tt></code>
<a id="filepos4415999"/>function in &#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>), when we know it is safe to clobber an lvalue. By <em class="calibre16">letting</em> us do the cast, the language allows this usage. By <em class="calibre16">forcing</em> us to use a cast, the language tries to prevent us from doing so accidentally.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Finally, although we can write such casts directly, it is much easier to use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code> function. Moreover, using <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code> consistently makes it easy to find the places in our code that might potentially clobber lvalues.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.46:</strong> Explain this loop from <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec::reallocate</span></tt></code> in &#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a> (p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>):</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (size_t i = 0; i != size(); ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.construct(dest++, std::move(*elem++));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4417678" class="calibre37"><span class="calibre5">16.2.7. Forwarding</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Some functions need to forward one or more of their arguments with their types <em class="calibre16">unchanged</em> to another, forwarded-to, function. In such cases, we need to preserve everything about the forwarded arguments, including whether or not the argument type is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, and whether the argument is an lvalue or an rvalue.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll write a function that takes a callable expression and two additional arguments. Our function will call the given callable with the other two arguments in reverse order. The following is a first cut at our flip function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">template that takes a callable and two parameters</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">and calls the given callable with the parameters ''flipped''</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flip1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an incomplete implementation: top-level</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and references are lost</span></span></span><br class="calibre6"/>template &lt;typename F, typename T1, typename T2&gt;<br class="calibre6"/>void flip1(F f, T1 t1, T2 t2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;f(t2, t1);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This template works fine until we want to use it to call a function that has a reference parameter:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f(int v1, int &amp;v2) // <span><span class="calibre45"><span class="calibre16">note</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference</span></span></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; v1 &lt;&lt; " " &lt;&lt; ++v2 &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> changes the value of the argument bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>. However, if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> through <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip1</span></tt></code>, the changes made by <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> do not affect the original argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">f(42, i);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">changes its argument</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>flip1(f, j, 42); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">called through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flip1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">leaves</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is passed to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code> parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip1</span></tt></code>. That parameter has is a plain, nonreference type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, not an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. That is, the instantiation of this call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip1</span></tt></code> is</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4422623"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void flip1(void(*fcn)(int, int&amp;), int t1, int t2);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is copied into <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code>. The reference parameter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code>, not to <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining Function Parameters That Retain Type Information</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">To pass a reference through our flip function, we need to rewrite our function so that its parameters preserve the &#8220;lvalueness&#8221; of its given arguments. Thinking ahead a bit, we can imagine that we&#8217;d also like to preserve the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of the arguments as well.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can preserve all the type information in an argument by defining its corresponding function parameter as an rvalue reference to a template type parameter. Using a reference parameter (either lvalue or rvalue) lets us preserve <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness, because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> in a reference type is low-level. Through reference collapsing (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">688</a>), if we define the function parameters as <code class="calibre23"><tt class="calibre23"><span class="calibre24">T1&amp;&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">T2&amp;&amp;</span></tt></code>, we can preserve the lvalue/rvalue property of flip&#8217;s arguments (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">687</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename F, typename T1, typename T2&gt;<br class="calibre6"/>void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;f(t2, t1);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in our earlier call, if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2(f, j, 42)</span></tt></code>, the lvalue <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is passed to the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code>. However, in <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code>, the type deduced for <code class="calibre23"><tt class="calibre23"><span class="calibre24">T1</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>, which means that the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code> collapses to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code>. The reference <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code> is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, the reference parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t1</span></tt></code>, which in turn is bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code>, it is changing the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A function parameter that is an rvalue reference to a template type parameter (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code>) preserves the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness and lvalue/rvalue property of its corresponding argument.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">This version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code> solves one half of our problem. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code> function works fine for functions that take lvalue references but cannot be used to call a function that has an rvalue reference parameter. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void g(int &amp;&amp;i, int&amp; j)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we try to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> through <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code>, we will be passing the parameter <code class="calibre23"><tt class="calibre23"><span class="calibre24">t2</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s rvalue reference parameter. Even if we pass an rvalue to <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">flip2(g, i, 42); // <span><span class="calibre45"><span class="calibre16">error: can't initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int&amp;&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from an lvalue</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">what is passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> will be the parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">t2</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code>. A function parameter, like any other variable, is an lvalue expression (&#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>). As a result, the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code> passes an lvalue to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code>&#8217;s rvalue reference parameter.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4430345"/>Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">std::forward</span></span></tt></span></span></tt></code> to Preserve Type Information in a Call</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">We can use a new library facility named <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> to pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip2</span></tt></code>&#8217;s parameters in a way that preserves the types of the original arguments. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">move, forward</span></tt></code> is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">utility</span></tt></code> header. Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">move, forward</span></tt></code> must be called with an explicit template argument (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4344365">16.2.2</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4344365">682</a>). <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> returns an rvalue reference to that explicit argument type. That is, the return type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward&lt;T&gt;</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4431692"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Ordinarily, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> to pass a function parameter that is defined as an rvalue reference to a template type parameter. Through reference collapsing on its return type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> preserves the lvalue/rvalue nature of its given argument:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename Type&gt; intermediary(Type &amp;&amp;arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;finalFcn(std::forward&lt;Type&gt;(arg));<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">Type</span></tt></code>&#8212;which is deduced from <code class="calibre23"><tt class="calibre23"><span class="calibre24">arg</span></tt></code>&#8212;as <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code>&#8217;s explicit template argument type. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">arg</span></tt></code> is an rvalue reference to a template type parameter, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Type</span></tt></code> will represent all the type information in the argument passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">arg</span></tt></code>. If that argument was an rvalue, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">Type</span></tt></code> is an ordinary (nonreference) type and <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward&lt;Type&gt;</span></tt></code> will return <code class="calibre23"><tt class="calibre23"><span class="calibre24">Type&amp;&amp;</span></tt></code>. If the argument was an lvalue, then&#8212;through reference collapsing&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">Type</span></tt></code> itself is an lvalue reference type. In this case, the return type is an rvalue reference to an lvalue reference type. Again through reference collapsing&#8212;this time on the return type&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">forward&lt;Type&gt;</span></tt></code> will return an lvalue reference type.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When used with a function parameter that is an rvalue reference to template type parameter (<code class="calibre23"><tt class="calibre23"><span class="calibre24">T&amp;&amp;</span></tt></code>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> preserves all the details about an argument&#8217;s type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code>, we&#8217;ll rewrite our flip function once more:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename F, typename T1, typename T2&gt;<br class="calibre6"/>void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">flip(g, i, 42), i</span></tt></code> will be passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code> will be passed as an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int&amp;&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::move</span></tt></code>, it&#8217;s a good idea not to provide a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::forward</span></tt></code>. &#167; <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>) will explain why.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="154-16.1._defining_a_template.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="156-16.3._overloading_and_templates.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
