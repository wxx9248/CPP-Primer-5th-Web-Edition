<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>17.3. Regular Expressions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="164-17.2._the_bitset_type.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="166-17.4._random_numbers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4635323" class="calibre29"><span class="bold">17.3. Regular Expressions</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos4635461" href="169-defined_terms.html#filepos4849177">regular expression</a></strong> is a way of describing a sequence of characters. Regular expressions are a stunningly powerful computational device. However, describing the languages used to define regular expressions is well beyond the scope of this Primer. Instead, we&#8217;ll focus on how to use the C++ regular-expression library (RE library), which is part of the new library. The RE library, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> header, involves several components, listed in <a href="165-17.3._regular_expressions.html#filepos4636149">Table 17.4</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4636149"/>Table 17.4. Regular Expression Library Components</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00112.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos4636340"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If you are not already familiar with using regular expressions, you might want to skim this section to get an idea of the kinds of things regular expressions can do.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos4636923"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4637022" href="169-defined_terms.html#filepos4847713">regex</a></span></span></tt></span></span></tt></code> class represents a regular expression. Aside from initialization and assignment, <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> has few operations. The operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> are listed in <a href="165-17.3._regular_expressions.html#filepos4648235">Table 17.6</a> (p. <a href="165-17.3._regular_expressions.html#filepos4648235">731</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">The functions <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4637627" href="169-defined_terms.html#filepos4848171">regex_match</a></span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4637816" href="169-defined_terms.html#filepos4848848">regex_search</a></span></span></tt></span></span></tt></code> determine whether a given character sequence matches a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_match</span></tt></code> function returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the entire input sequence matches the expression; <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if there is a substring in the input sequence that matches. There is also a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_replace</span></tt></code> function that we&#8217;ll describe in &#167; <a href="165-17.3._regular_expressions.html#filepos4699978">17.3.4</a> (p. <a href="165-17.3._regular_expressions.html#filepos4699978">741</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">The arguments to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> functions are described in <a href="165-17.3._regular_expressions.html#filepos4639503">Table 17.5</a> (overleaf). These functions return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> and are overloaded: One version takes an additional argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4639167" href="169-defined_terms.html#filepos4849693">smatch</a></span></span></tt></span></span></tt></code>. If present, these functions store additional information about a successful match in the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4639503"/>Table 17.5. Arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex_search</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex_match</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00113.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h4 id="filepos4639938" class="calibre37"><span class="calibre5">17.3.1. Using the Regular Expression Library</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As a fairly simple example, we&#8217;ll look for words that violate a well-known spelling rule of thumb, &#8220;<em class="calibre16">i</em> before <em class="calibre16">e</em> except after <em class="calibre16">c</em>&#8221;:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">find the characters</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ei</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that follow a character other than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>string pattern("[^c]ei");<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">we want the whole word in which our</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pattern</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">appears</span></span></span><br class="calibre6"/>pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";<br class="calibre6"/>regex r(pattern); // <span><span class="calibre45"><span class="calibre16">construct a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pattern</span></span></tt></span><br class="calibre6"/>smatch results;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">define an object to hold the results of a search</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">define a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that has text that does and doesn't match</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pattern</span></span></tt></span><br class="calibre6"/>string test_str = "receipt freind theif receive";<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find a match to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pattern</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">test_str</span></span></tt></span><br class="calibre6"/>if (regex_search(test_str, results, r)) // <span><span class="calibre45"><span class="calibre16">if there is a match</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; results.str() &lt;&lt; endl;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the matching word</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by defining a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to hold the regular expression we want to find. The regular expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">[^c]</span></tt></code> says we want any character that is not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">'c'</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">[^c]ei</span></tt></code> says we want any such letter that is followed by the letters <code class="calibre23"><tt class="calibre23"><span class="calibre24">ei</span></tt></code>. This pattern describes strings containing exactly three characters. We want the entire word that contains this pattern. To match the word, we need a regular expression that will match the letters that come before and after our three-letter pattern.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4643761"/>That regular expression consists of zero or more letters followed by our original three-letter pattern followed by zero or more additional characters. By default, the regular-expression language used by <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> objects is ECMAScript. In ECMAScript, the pattern <code class="calibre23"><tt class="calibre23"><span class="calibre24">[[:alpha:]]</span></tt></code> matches any alphabetic character, and the symbols <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> signify that we want &#8220;one or more&#8221; or &#8220;zero or more&#8221; matches, respectively. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">[[:alpha:]]*</span></tt></code> will match zero or more characters.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Having stored our regular expression in <code class="calibre23"><tt class="calibre23"><span class="calibre24">pattern</span></tt></code>, we use it to initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code>. We next define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that we&#8217;ll use to test our regular expression. We initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">test_str</span></tt></code> with words that match our pattern (e.g., &#8220;freind&#8221; and &#8220;theif&#8221;) and words (e.g., &#8220;receipt&#8221; and &#8220;receive&#8221;) that don&#8217;t. We also define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">results</span></tt></code>, which we will pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code>. If a match is found, <code class="calibre23"><tt class="calibre23"><span class="calibre24">results</span></tt></code> will hold the details about where the match occurred.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Next we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> finds a match, it returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. We use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">str</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">results</span></tt></code> to print the part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">test_str</span></tt></code> that matched our pattern. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> function stops looking as soon as it finds a matching substring in the input sequence. Thus, the output will be</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">freind</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">&#167; <a href="165-17.3._regular_expressions.html#filepos4663827">17.3.2</a> (p. <a href="165-17.3._regular_expressions.html#filepos4663827">734</a>) will show how to find all the matches in the input.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Specifying Options for a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex</span></span></tt></span></span></tt></code> Object</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> or call <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> to give it a new value, we can specify one or more flags that affect how the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> operates. These flags control the processing done by that object. The last six flags listed in <a href="165-17.3._regular_expressions.html#filepos4648235">Table 17.6</a> indicate the language in which the regular expression is written. Exactly one of the flags that specify a language must be set. By default, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ECMAScript</span></tt></code> flag is set, which causes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> to use the ECMA-262 specification, which is the regular expression language that many Web browsers use.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4648235"/>Table 17.6. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex</span></span></tt></span></span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">wregex</span></span></tt></span></span></tt></code>) Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00114.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The other three flags let us specify language-independent aspects of the regular-expression processing. For example, we can indicate that we want the regular expression to be matched in a case-independent manner.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As one example, we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">icase</span></tt></code> flag to find file names that have a particular file extension. Most operating systems recognize extensions in a case-independent manner&#8212;we can store a C++ program in a file that ends in <code class="calibre23"><tt class="calibre23"><span class="calibre24">.cc</span></tt></code>, or <a/><code class="calibre23"><tt class="calibre23"><span class="calibre24">.Cc</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">.cC</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">.CC</span></tt></code>. We&#8217;ll write a regular expression to recognize any of these along with other common file extensions as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">one or more alphanumeric characters followed by a '.' followed by "cpp" or "cxx" or "cc"</span></span></span><br class="calibre6"/>regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);<br class="calibre6"/>smatch results;<br class="calibre6"/>string filename;<br class="calibre6"/>while (cin &gt;&gt; filename)<br class="calibre6"/>&#160;&#160;&#160;&#160;if (regex_search(filename, results, r))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; results.str() &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the current match</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This expression will match a string of one or more letters or digits followed by a period and followed by one of three file extensions. The regular expression will match the file extensions regardless of case.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Just as there are special characters in C++ (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>), regular-expression languages typically also have special characters. For example, the dot (.) character usually matches any character. As we do in C++, we can escape the special nature of a character by preceding it with a backslash. Because the backslash is also a special character in C++, we must use a second backslash inside a string literal to indicate to C++ that we want a backslash. Hence, we must write <code class="calibre23"><tt class="calibre23"><span class="calibre24">\\</span></tt></code>. to represent a regular expression that will match a period.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4651570"/>Errors in Specifying or Using a Regular Expression</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can think of a regular expression as itself a &#8220;program&#8221; in a simple programming language. That language is not interpreted by the C++ compiler. Instead, a regular expression is &#8220;compiled&#8221; at run time when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object is initialized with or assigned a new pattern. As with any programming language, it is possible that the regular expressions we write can have errors.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is important to realize that the syntactic correctness of a regular expression is evaluated at run time.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">If we make a mistake in writing a regular expression, then at <em class="calibre16">run time</em> the library will throw an exception (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>) of type <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4652948" href="169-defined_terms.html#filepos4847921">regex_error</a></span></span></tt></span></span></tt></code>. Like the standard exception types, <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_error</span></tt></code> has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> operation that describes the error that occurred (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">5.6.2</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">195</a>). A <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_error</span></tt></code> also has a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">code</span></tt></code> that returns a numeric code corresponding to the type of error that was encountered. The values <code class="calibre23"><tt class="calibre23"><span class="calibre24">code</span></tt></code> returns are implementation defined. The standard errors that the RE library can throw are listed in <a href="165-17.3._regular_expressions.html#filepos4653902">Table 17.7</a>.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4653902"/>Table 17.7. Regular Expression Error Conditions</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00115.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">For example, we might inadvertently omit a bracket in a pattern:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">try {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: missing close bracket after</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alnum;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">the constructor will throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;regex r("[[:alnum:]+\\.(cpp|cxx|cc)$", regex::icase);<br class="calibre6"/>} catch (regex_error e)<br class="calibre6"/>&#160;&#160;{ cout &lt;&lt; e.what() &lt;&lt; "\ncode: " &lt;&lt; e.code() &lt;&lt; endl; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When run on our system, this program generates</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex_error(error_brack):</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">The expression contained mismatched [ and ].</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">code: 4</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4655563"/>Our compiler defines the <code class="calibre23"><tt class="calibre23"><span class="calibre24">code</span></tt></code> member to return the position of the error as listed in <a href="165-17.3._regular_expressions.html#filepos4653902">Table 17.7</a>, counting, as usual, from zero.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Avoid Creating Unnecessary Regular Expressions</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As we&#8217;ve seen, the &#8220;program&#8221; that a regular expression represents is compiled at run time, not at compile time. Compiling a regular expression can be a surprisingly slow operation, especially if you&#8217;re using the extended regular-expression grammar or are using complicated expressions. As a result, constructing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object and assigning a new regular expression to an existing <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> can be time-consuming. To minimize this overhead, you should try to avoid creating more <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> objects than needed. In particular, if you use a regular expression in a loop, you should create it outside the loop rather than recompiling it on each iteration.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Regular Expression Classes and the Input Sequence Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can search any of several types of input sequence. The input can be ordinary <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> data or <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code> data and those characters can be stored in a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or in an array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> (or the wide character versions, <code class="calibre23"><tt class="calibre23"><span class="calibre24">wstring</span></tt></code> or array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code>). The RE library defines separate types that correspond to these differing types of input sequences.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> class holds regular expressions of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. The library also defines a <code class="calibre23"><tt class="calibre23"><span class="calibre24">wregex</span></tt></code> class that holds type <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code> and has all the same operations as <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code>. The only difference is that the initializers of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">wregex</span></tt></code> must use <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code> instead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The match and iterator types (which we will cover in the following sections) are more specific. These types differ not only by the character type, but also by whether the sequence is in a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or an array: <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> represents <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> input sequences; <code class="calibre23"><tt class="calibre23"><span class="calibre24">cmatch</span></tt></code>, character array sequences; <code class="calibre23"><tt class="calibre23"><span class="calibre24">wsmatch</span></tt></code>, wide string (<code class="calibre23"><tt class="calibre23"><span class="calibre24">wstring</span></tt></code>) input; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">wcmatch</span></tt></code>, arrays of wide characters.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The important point is that the RE library types we use must match the type of the input sequence. <a href="165-17.3._regular_expressions.html#filepos4661017">Table 17.8</a> indicates which types correspond to which kinds of input sequences. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);<br class="calibre6"/>smatch results;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">will match a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">input sequence, but not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char*</span></span></tt></span><br class="calibre6"/>if (regex_search("myfile.cc", results, r)) // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">input</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; results.str() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4661017"/>Table 17.8. Regular Expression Library Classes</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00116.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4661224"/>The (C++) compiler will reject this code because the type of the match argument and the type of the input sequence do not match. If we want to search a character array, then we must use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">cmatch</span></tt></code> object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cmatch results;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">will match character array input sequences</span></span></span><br class="calibre6"/>if (regex_search("myfile.cc", results, r))<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; results.str() &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the current match</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">In general, our programs will use <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> input sequences and the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> versions of the RE library components.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 17.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.14:</strong> Write several regular expressions designed to trigger various errors. Run your program to see what output your compiler generates for each error.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.15:</strong> Write a program using the pattern that finds words that violate the <em class="calibre16">&#8220;i</em> before <em class="calibre16">e</em> except after <em class="calibre16">c&#8221;</em> rule. Have your program prompt the user to supply a word and indicate whether the word is okay or not. Test your program with words that do and do not violate the rule.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.16:</strong> What would happen if your <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object in the previous program were initialized with <code class="calibre23"><tt class="calibre23"><span class="calibre24">"[^c]ei"?</span></tt></code> Test your program using that pattern to see whether your expectations were correct.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4663827" class="calibre37"><span class="calibre5">17.3.2. The Match and Regex Iterator Types</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The program on page <a href="165-17.3._regular_expressions.html#filepos4636923">729</a> that found violations of the &#8220;<em class="calibre16">i</em> before <em class="calibre16">e</em> except after <em class="calibre16">c</em>&#8221; grammar rule printed only the first match in its input sequence. We can get all the matches by using an <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4664310" href="169-defined_terms.html#filepos4850303">sregex_iterator</a></span></span></tt></span></span></tt></code>. The regex iterators are iterator adaptors (&#167; <a href="094-9.6._container_adaptors.html#filepos2426063">9.6</a>, p. <a href="094-9.6._container_adaptors.html#filepos2426063">368</a>) that are bound to an input sequence and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object. As described in <a href="165-17.3._regular_expressions.html#filepos4661017">Table 17.8</a> (on the previous page), there are specific regex iterator types that correspond to each of the different types of input sequences. The iterator operations are described in <a href="165-17.3._regular_expressions.html#filepos4665024">Table 17.9</a> (p. <a href="165-17.3._regular_expressions.html#filepos4665024">736</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4665024"/>Table 17.9. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sregex_iterator</span></span></tt></span></span></tt></code> Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00117.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">When we bind an <code class="calibre23"><tt class="calibre23"><span class="calibre24">sregex_iterator</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object, the iterator is automatically positioned on the first match in the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. That is, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sregex_iterator</span></tt></code> constructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> on the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code>. When we dereference the iterator, we get an <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object corresponding to the results from the most recent search. When we increment the iterator, it calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> to find the next match in the input <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using an <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sregex_iterator</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll extend our program to find all the violations of the &#8220;<em class="calibre16">i</em> before <em class="calibre16">e</em> except after <em class="calibre16">c</em>&#8221; grammar rule in a file of text. We&#8217;ll assume that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code> holds the entire contents of the input file that we want to search. This version of the program will use the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">pattern</span></tt></code> as our original one, but will use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">sregex_iterator</span></tt></code> to do the search:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4667514"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">find the characters</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ei</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that follow a character other than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>string pattern("[^c]ei");<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">we want the whole word in which our</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pattern</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">appears</span></span></span><br class="calibre6"/>pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";<br class="calibre6"/>regex r(pattern, regex::icase); // <span><span class="calibre45"><span class="calibre16">we'll ignore case in doing the match</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will repeatedly call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex_search</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find all matches in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">file</span></span></tt></span><br class="calibre6"/>for (sregex_iterator it(file.begin(), file.end(), r), end_it;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it != end_it; ++it)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; it-&gt;str() &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">matched word</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop iterates through each match to <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code>. The initializer in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end_it</span></tt></code>. When we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sregex_iterator</span></tt></code> constructor calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> to position <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> on the first match in <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code>. The empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">sregex_iterator, end_it</span></tt></code>, acts as the off-the-end iterator. The increment in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> &#8220;advances&#8221; the iterator by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code>. When we dereference the iterator, we get an <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object representing the current match. We call the <code class="calibre23"><tt class="calibre23"><span class="calibre24">str</span></tt></code> member of the match to print the matching word.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can think of this loop as jumping from match to match as illustrated in <a href="165-17.3._regular_expressions.html#filepos4671092">Figure 17.1</a>.</p><div class="calibre22">&#160;</div>
<div class="calibre52"><a id="filepos4671092"/><img alt="Image" src="images/00118.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 17.1. Using an <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sregex_iterator</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Match Data</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If we run this loop on <code class="calibre23"><tt class="calibre23"><span class="calibre24">test_str</span></tt></code> from our original program, the output would be</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">freind</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">theif</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, finding just the words that match our expression is not so useful. If we ran the program on a larger input sequence&#8212;for example, on the text of this chapter&#8212;we&#8217;d want to see the context within which the word occurs, such as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">hey read or write according to the type</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span><tt class="calibre23"><span class="calibre32"><span class="calibre5">&gt;&gt;&gt; being &lt;&lt;&lt;</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">handled. The input operators ignore whi</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In addition to letting us print the part of the input string that was matched, the match classes give us more detailed information about the match. The operations on these types are listed in <a href="165-17.3._regular_expressions.html#filepos4673403">Table 17.10</a> (p. <a href="165-17.3._regular_expressions.html#filepos4673403">737</a>) and <a href="165-17.3._regular_expressions.html#filepos4673729">Table 17.11</a> (p. <a href="165-17.3._regular_expressions.html#filepos4673729">741</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4673403"/>Table 17.10. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">smatch</span></span></tt></span></span></tt></code> Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00119.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4673729"/>Table 17.11. Submatch Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00120.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4673923"/>We&#8217;ll have more to say about the <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4674131" href="169-defined_terms.html#filepos4851291">ssub_match</a></span></span></tt></span></span></tt></code> types in the next section. For now, what we need to know is that these types let us see the context of a match. The match types have members named <code class="calibre23"><tt class="calibre23"><span class="calibre24">prefix</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">suffix</span></tt></code>, which return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> object representing the part of the input sequence ahead of and after the current match, respectively. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> object has members named <code class="calibre23"><tt class="calibre23"><span class="calibre24">str</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">length</span></tt></code>, which return the matched <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and size of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, respectively. We can use these operations to rewrite the loop of our grammar program:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">for</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">loop header as before</span></span></span><br class="calibre6"/>for (sregex_iterator it(file.begin(), file.end(), r), end_it;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it != end_it; ++it) {<br class="calibre6"/>&#160;&#160;&#160;&#160;auto pos = it-&gt;prefix().length();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">size of the prefix</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;pos = pos &gt; 40 ? pos - 40 : 0;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">we want up to 40 characters</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; it-&gt;prefix().str().substr(pos)&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">last part of the prefix</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; "\n\t\t&gt;&gt;&gt; " &lt;&lt; it-&gt;str() &lt;&lt; " &lt;&lt;&lt;\n" // <span><span class="calibre45"><span class="calibre16">matched word</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; it-&gt;suffix().str().substr(0, 40) // <span><span class="calibre45"><span class="calibre16">first part of the suffix</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The loop itself operates the same way as our previous program. What&#8217;s changed is the processing inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>, which is illustrated in <a href="165-17.3._regular_expressions.html#filepos4677271">Figure 17.2</a>.</p><div class="calibre15">&#160;</div>
<div class="calibre52"><a id="filepos4677271"/><img alt="Image" src="images/00121.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 17.2. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">smatch</span></span></tt></span></span></tt></code> Object Representing a Particular Match</span></p><div class="calibre12">&#160;</div>
<p class="calibre25">We call <code class="calibre23"><tt class="calibre23"><span class="calibre24">prefix</span></tt></code>, which returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> object that represents the part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code> ahead of the current match. We call <code class="calibre23"><tt class="calibre23"><span class="calibre24">length</span></tt></code> on that <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> to find out how many characters are in the part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code> ahead of the match. Next we adjust <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> to be the index of the character 40 from the end of the prefix. If the prefix has fewer than 40 characters, we set <code class="calibre23"><tt class="calibre23"><span class="calibre24">pos</span></tt></code> to 0, which means we&#8217;ll print the entire prefix. We use <code class="calibre23"><tt class="calibre23"><span class="calibre24">substr</span></tt></code> (&#167; <a href="093-9.5._additional_string_operations.html#filepos2374493">9.5.1</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2374493">361</a>) to print from the given position to the end of the prefix.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4678845"/>Having printed the characters that precede the match, we next print the match itself with some additional formatting so that the matched word will stand out in the output. After printing the matched portion, we print (up to) the first 40 characters in the part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">file</span></tt></code> that comes after this match.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 17.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.17:</strong> Update your program so that it finds all the words in an input sequence that violiate the &#8220;ei&#8221; grammar rule.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.18:</strong> Revise your program to ignore words that contain &#8220;ei&#8221; but are not misspellings, such as &#8220;albeit&#8221; and &#8220;neighbor.&#8221;</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4679975" class="calibre37"><span class="calibre5"><a id="filepos4680008"/>17.3.3. Using Subexpressions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">A pattern in a regular expression often contains one or more <strong class="calibre5"><a id="filepos4680182" href="169-defined_terms.html#filepos4851644">subexpressions</a></strong>. A subexpression is a part of the pattern that itself has meaning. Regular-expression grammars typically use parentheses to denote subexpressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, the pattern that we used to match C++ files (&#167; <a href="165-17.3._regular_expressions.html#filepos4639938">17.3.1</a>, p. <a href="165-17.3._regular_expressions.html#filepos4639938">730</a>) used parentheses to group the possible file extensions. Whenever we group alternatives using parentheses, we are also declaring that those alternatives form a subexpression. We can rewrite that expression so that it gives us access to the file name, which is the part of the pattern that precedes the period, as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has two subexpressions: the first is the part of the file name before the period</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the second is the file extension</span></span></span><br class="calibre6"/>regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$", regex::icase);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our pattern now has two parenthesized subexpressions:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">([[:alnum:]]+)</span></tt></code>, which is a sequence of one or more characters</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">(cpp| cxx| cc)</span></tt></code>, which is the file extension</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">We can also rewrite the program from &#167; <a href="165-17.3._regular_expressions.html#filepos4639938">17.3.1</a> (p. <a href="165-17.3._regular_expressions.html#filepos4639938">730</a>) to print just the file name by changing the output statement:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (regex_search(filename, results, r))<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; results.str(1) &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the first subexpression</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in our original program, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> to look for our pattern <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">filename</span></tt></code>, and we pass the <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object <code class="calibre23"><tt class="calibre23"><span class="calibre24">results</span></tt></code> to hold the results of the match. If the call succeeds, then we print the results. However, in this program, we print <code class="calibre23"><tt class="calibre23"><span class="calibre24">str(1)</span></tt></code>, which is the match for the first subexpression.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In addition to providing information about the overall match, the match objects provide access to each matched subexpression in the pattern. The submatches are accessed positionally. The first submatch, which is at position 0, represents the match for the entire pattern. Each subexpression appears in order thereafter. Hence, the file name, which is the first subexpression in our pattern, is at position 1, and the file extension is in position 2.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, if the file name is <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo.cpp</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">results.str(0)</span></tt></code> will hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo.cpp</span></tt></code>; <code class="calibre23"><tt class="calibre23"><span class="calibre24">results.str(1)</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code>; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">results.str(2)</span></tt></code> will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">cpp</span></tt></code>. In this program, we want the part of the name before the period, which is the first subexpression, so we print <code class="calibre23"><tt class="calibre23"><span class="calibre24">results.str(1)</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Subexpressions for Data Validation</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One common use for subexpressions is to validate data that must match a specific format. For example, U.S. phone numbers have ten digits, consisting of an area code and a seven-digit local number. The area code is often, but not always, enclosed in parentheses. The remaining seven digits can be separated by a dash, a dot, or a space; or not separated at all. We might want to allow data with any of these formats and reject numbers in other forms. We&#8217;ll do a two-step process: First, <a id="filepos4685706"/>we&#8217;ll use a regular expression to find sequences that might be phone numbers and then we&#8217;ll call a function to complete the validation of the data.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Before we write our phone number pattern, we need to describe a few more aspects of the ECMAScript regular-expression language:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">\{d}</span></tt></code> represents a single digit and <code class="calibre23"><tt class="calibre23"><span class="calibre24">\{d}{</span></tt></code><em class="calibre16">n</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">}</span></tt></code> represents a sequence of <em class="calibre16">n</em> digits. (E.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">\{d}{3}</span></tt></code> matches a sequence of three digits.)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A collection of characters inside square brackets allows a match to any of those characters. (E.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">[-. ]</span></tt></code> matches a dash, a dot, or a space. Note that a dot has no special meaning inside brackets.)</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A component followed by &#8217;?&#8217; is optional. (E.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">\{d}{3}[-. ]?\{d}{4}</span></tt></code> matches three digits followed by an optional dash, period, or space, followed by four more digits. This pattern would match <code class="calibre23"><tt class="calibre23"><span class="calibre24">555-0132</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">555.0132</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">555 0132</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">5550132.)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Like C++, ECMAScript uses a backslash to indicate that a character should represent itself, rather than its special meaning. Because our pattern includes parentheses, which are special characters in ECMAScript, we must represent the parentheses that are part of our pattern as <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code>(or <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code>).</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Because backslash is a special character in C++, each place that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">\</span></tt></code> appears in the pattern, we must use a second backslash to indicate to C++ that we want a backslash. Hence, we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">\\{d}{3}</span></tt></code> to represent the regular expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">\{d}{3}</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In order to validate our phone numbers, we&#8217;ll need access to the components of the pattern. For example, we&#8217;ll want to verify that if a number uses an opening parenthesis for the area code, it also uses a close parenthesis after the area code. That is, we&#8217;d like to reject a number such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">(908.555.1800</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To get at the components of the match, we need to define our regular expression using subexpressions. Each subexpression is marked by a pair of parentheses:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">our overall expression has seven subexpressions: ( ddd ) separator ddd separator dddd</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">subexpressions 1, 3, 4, and 6 are optional; 2, 5, and 7 hold the number</span></span></span><br class="calibre6"/>"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because our pattern uses parentheses, and because we must escape backslashes, this pattern can be hard to read (and write!). The easiest way to read it is to pick off each (parenthesized) subexpression:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(\\()?</span></tt></code> an optional open parenthesis for the area code</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(\\d{3})</span></tt></code> the area code</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(\\))?</span></tt></code> an optional close parenthesis for the area code</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">4.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">([-. ])?</span></tt></code> an optional separator after the area code</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">5.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(\\d{3})</span></tt></code> the next three digits of the number</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">6.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">([-. ])?</span></tt></code> another optional separator</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">7.</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">(\\d{4})</span></tt></code> the final four digits of the number</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4691750"/>The following code uses this pattern to read a file and find data that match our overall phone pattern. It will call a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">valid</span></tt></code> to check whether the number has a valid format:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string phone =<br class="calibre6"/>&#160;&#160;&#160;&#160;"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";<br class="calibre6"/>regex r(phone);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find our pattern</span></span></span><br class="calibre6"/>smatch m;<br class="calibre6"/>string s;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">read each record from the input file</span></span></span><br class="calibre6"/>while (getline(cin, s)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">for each matching phone number</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (sregex_iterator it(s.begin(), s.end(), r), end_it;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it != end_it; ++it)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">check whether the number's formatting is valid</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (valid(*it))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "valid: " &lt;&lt; it-&gt;str() &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "not valid: " &lt;&lt; it-&gt;str() &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Submatch Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;ll use submatch operations, which are outlined in <a href="165-17.3._regular_expressions.html#filepos4673729">Table 17.11</a>, to write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">valid</span></tt></code> function. It is important to keep in mind that our <code class="calibre23"><tt class="calibre23"><span class="calibre24">pattern</span></tt></code> has seven subexpressions. As a result, each <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code> object will contain eight <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> elements. The element at <code class="calibre23"><tt class="calibre23"><span class="calibre24">[0]</span></tt></code>represents the overall match; the elements <code class="calibre23"><tt class="calibre23"><span class="calibre24">[1]</span></tt></code>. . .<code class="calibre23"><tt class="calibre23"><span class="calibre24">[7]</span></tt></code> represent each of the corresponding subexpressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">valid</span></tt></code>, we know that we have an overall match, but we do not know which of our optional subexpressions were part of that match. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">matched</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ssub_match</span></tt></code> corresponding to a particular subexpression is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if that subexpression is part of the overall match.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In a valid phone number, the area code is either fully parenthesized or not parenthesized at all. Therefore, the work <code class="calibre23"><tt class="calibre23"><span class="calibre24">valid</span></tt></code> does depends on whether the number starts with a parenthesis or not:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool valid(const smatch&amp; m)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if there is an open parenthesis before the area code</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if(m[1].matched)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the area code must be followed by a close parenthesis</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">and followed immediately by the rest of the number or a space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return m[3].matched<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;&amp; (m[4].matched == 0 || m[4].str() == " ");<br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">then there can't be a close after the area code</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the delimiters between the other two components must match</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return !m[3].matched<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;&amp; m[4].str() == m[6].str();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a/>We start by checking whether the first subexpression (i.e., the open parenthesis) matched. That subexpression is in <code class="calibre23"><tt class="calibre23"><span class="calibre24">m[1]</span></tt></code>. If it matched, then the number starts with an open parenthesis. In this case, the overall number is valid if the subexpression following the area code also matched (meaning that there was a close parenthesis after the area code). Moreover, if the number is correctly parenthesized, then the next character must be a space or the first digit in the next part of the number.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">m[1]</span></tt></code> didn&#8217;t match (i.e., there was no open parenthesis), the subexpression following the area code must also be empty. If it&#8217;s empty, then the number is valid if the remaining separators are equal and not otherwise.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 17.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.19:</strong> Why is it okay to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">m[4].str()</span></tt></code> without first checking whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">m[4]</span></tt></code> was matched?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.20:</strong> Write your own version of the program to validate phone numbers.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.21:</strong> Rewrite your phone number program from &#167; <a href="085-8.3._string_streams.html#filepos2157138">8.3.2</a> (p. <a href="085-8.3._string_streams.html#filepos2157138">323</a>) to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">valid</span></tt></code> function defined in this section.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.22:</strong> Rewrite your phone program so that it allows any number of whitespace characters to separate the three parts of a phone number.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.23:</strong> Write a regular expression to find zip codes. A zip code can have five or nine digits. The first five digits can be separated from the remaining four by a dash.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4699978" class="calibre37"><span class="calibre5">17.3.4. Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">regex_replace</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Regular expressions are often used when we need not only to find a given sequence but also to replace that sequence with another one. For example, we might want to translate U.S. phone numbers into the form &#8220;ddd.ddd.dddd,&#8221; where the area code and next three digits are separated by a dot.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4700601"/>When we want to find and replace a regular expression in the input sequence, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4700781" href="169-defined_terms.html#filepos4848498">regex_replace</a></span></span></tt></span></span></tt></code>. Like the search functions, <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_replace</span></tt></code>, which is described in <a href="165-17.3._regular_expressions.html#filepos4701298">Table 17.12</a>, takes an input character sequence and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex</span></tt></code> object. We must also pass a string that describes the output we want.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4701298"/>Table 17.12. Regular Expression Replace Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00122.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">We compose a replacement string by including the characters we want, intermixed with subexpressions from the matched substring. In this case, we want to use the second, fifth, and seventh subexpressions in our replacement string. We&#8217;ll ignore the first, third, fourth, and sixth, because these were used in the original formatting of the number but are not part of our replacement format. We refer to a particular subexpression by using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">$</span></tt></code> symbol followed by the index number for a subexpression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string fmt = "$2.$5.$7"; // <span><span class="calibre45"><span class="calibre16">reformat numbers to ddd.ddd.dddd</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can use our regular-expression pattern and the replacement string as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">regex r(phone);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find our pattern</span></span></span><br class="calibre6"/>string number = "(908) 555-1800";<br class="calibre6"/>cout &lt;&lt; regex_replace(number, r, fmt) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The output from this program is</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">908.555.1800</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Replacing Only Part of the Input Sequence</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A more interesting use of our regular-expression processing would be to replace phone numbers that are embedded in a larger file. For example, we might have a file of names and phone number that had data like this:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4704033"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">morgan (201) 555-2368 862-555-0123</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">drew (973)555.0130</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lee (609) 555-0132 2015550175 800.555-0000</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">that we want to transform to data like this:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">morgan 201.555.2368 862.555.0123</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">drew 973.555.0130</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">lee 609.555.0132 201.555.0175 800.555.0000</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can generate this transformation with the following program:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;string phone =<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";<br class="calibre6"/>&#160;&#160;&#160;&#160;regex r(phone);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to find our pattern</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;smatch m;<br class="calibre6"/>&#160;&#160;&#160;&#160;string s;<br class="calibre6"/>&#160;&#160;&#160;&#160;string fmt = "$2.$5.$7"; // <span><span class="calibre45"><span class="calibre16">reformat numbers to ddd.ddd.dddd</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">read each record from the input file</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;while (getline(cin, s))<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; regex_replace(s, r, fmt) &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We read each record into <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> and hand that record to <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_replace</span></tt></code>. This function finds and transforms <em class="calibre16">all</em> the matches in its input sequence.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Flags to Control Matches and Formatting</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as the library defines flags to direct how to process a regular expression, the library also defines flags that we can use to control the match process or the formatting done during a replacement. These values are listed in <a href="165-17.3._regular_expressions.html#filepos4707895">Table 17.13</a> (overleaf). These flags can be passed to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_search</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_match</span></tt></code> functions or to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">format</span></tt></code> members of class <code class="calibre23"><tt class="calibre23"><span class="calibre24">smatch</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4707895"/>Table 17.13. Match Flags</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00123.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The match and format flags have type <code class="calibre23"><tt class="calibre23"><span class="calibre24">match_flag_type</span></tt></code>. These values are defined in a namespace named <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_constants</span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">placeholders</span></tt></code>, which we used with <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> (&#167; <a href="100-10.3._customizing_operations.html#filepos2586884">10.3.4</a>, p. <a href="100-10.3._customizing_operations.html#filepos2586884">399</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_constants</span></tt></code> is a namespace defined inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code> namespace. To use a name from <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_constants</span></tt></code>, we must qualify that name with the names of both namespaces:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using std::regex_constants::format_no_copy;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This declaration says that when our code uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">format_no_copy</span></tt></code>, we want the object of that name from the namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::regex_constants</span></tt></code>. We can instead provide the alternative form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> that we will cover in &#167; <a href="172-18.2._namespaces.html#filepos4964533">18.2.2</a> (p. <a href="172-18.2._namespaces.html#filepos4964533">792</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using namespace std::regex_constants;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4710182"/>Using Format Flags</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_replace</span></tt></code> outputs its entire input sequence. The parts that don&#8217;t match the regular expression are output without change; the parts that do match are formatted as indicated by the given format string. We can change this default behavior by specifying <code class="calibre23"><tt class="calibre23"><span class="calibre24">format_no_copy</span></tt></code> in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">regex_replace</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">generate just the phone numbers: use a new format string</span></span></span><br class="calibre6"/>string fmt2 = "$2.$5.$7 "; // <span><span class="calibre45"><span class="calibre16">put space after the last number as a separator</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">tell</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">regex_replace</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to copy only the text that it replaces</span></span></span><br class="calibre6"/>cout &lt;&lt; regex_replace(s, r, fmt2, format_no_copy) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Given the same input, this version of the program generates</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">201.555.2368 862.555.0123</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">973.555.0130</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">609.555.0132 201.555.0175 800.555.0000</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 17.3.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.24:</strong> Write your own version of the program to reformat phone numbers.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.25:</strong> Rewrite your phone program so that it writes only the first phone number for each person.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.26:</strong> Rewrite your phone program so that it writes only the second and subsequent phone numbers for people with more than one phone number.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.27:</strong> Write a program that reformats a nine-digit zip code as <code class="calibre23"><tt class="calibre23"><span class="calibre24">ddddd-dddd</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="164-17.2._the_bitset_type.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="166-17.4._random_numbers.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
