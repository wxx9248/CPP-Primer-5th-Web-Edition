<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>12.1. Dynamic Memory and Smart Pointers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="113-chapter_12._dynamic_memory.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="115-12.2._dynamic_arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2904799" class="calibre29"><span class="bold">12.1. Dynamic Memory and Smart Pointers</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">In C++, dynamic memory is managed through a pair of operators: <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2905091" href="118-defined_terms.html#filepos3189040">new</a></span></span></tt></span></span></tt></code>, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2905384" href="118-defined_terms.html#filepos3186948">delete</a></span></span></tt></span></span></tt></code>, which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Dynamic memory is problematic because it is surprisingly hard to ensure that we free memory at the right time. Either we forget to free the memory&#8212;in which case we have a memory leak&#8212;or we free the memory when there are still pointers referring to that memory&#8212;in which case we have a pointer that refers to memory that is no longer valid.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2906041"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">To make using dynamic memory easier (and safer), the new library provides two <strong class="calibre5"><a id="filepos2906215" href="118-defined_terms.html#filepos3191364">smart pointer</a></strong> types that manage dynamic objects. A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points. The new library defines two kinds of smart pointers that differ in how they manage their underlying pointers: <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2906648" href="118-defined_terms.html#filepos3190998">shared_ptr</a></span></span></tt></span></span></tt></code>, which allows multiple pointers to refer to the same object, and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2906897" href="118-defined_terms.html#filepos3191687">unique_ptr</a></span></span></tt></span></span></tt></code>, which &#8220;owns&#8221; the object to which it points. The library also defines a companion class named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos2907187" href="118-defined_terms.html#filepos3192162">weak_ptr</a></span></span></tt></span></span></tt></code> that is a weak reference to an object managed by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. All three are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">memory</span></tt></code> header.</p><div class="calibre22">&#160;</div>
<h4 id="filepos2907541" class="calibre37"><span class="calibre5">12.1.1. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code> Class</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos2907781"/><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s, smart pointers are templates (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). Therefore, when we create a smart pointer, we must supply additional information&#8212;in this case, the type to which the pointer can point. As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;string&gt; p1;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that can point at a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;list&lt;int&gt;&gt; p2; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that can point at a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2909505"/>A default initialized smart pointer holds a null pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>). In &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999606">12.1.3</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999606">464</a>), we&#8217;ll cover additional ways to initialize a smart pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We use a smart pointer in ways that are similar to using a pointer. Dereferencing a smart pointer returns the object to which the pointer points. When we use a smart pointer in a condition, the effect is to test whether the pointer is null:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not null, check whether it's the empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>if (p1 &amp;&amp; p1-&gt;empty())<br class="calibre6"/>&#160;&#160;&#160;&#160;*p1 = "hi";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if so, dereference</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to assign a new value to that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (overleaf) lists operations common to <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. Those that are particular to <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> are listed in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">Table 12.2</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">453</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2911678"/>Table 12.1. Operations Common to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00088.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2912161"/>Table 12.2. Operations Specific to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00089.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">make_shared</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The safest way to allocate and use dynamic memory is to call a library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code>. This function allocates and initializes an object in dynamic memory and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> that points to that object. Like the smart pointers, <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">memory</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code>, we must specify the type of object we want to create. We do so in the same way as we use a template class, by following the function name with a type enclosed in angle brackets:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that points to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">9999999999</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, '9');<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p5</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that is value initialized (&#167; 3.3.1 (p. 98)) to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like the sequential-container <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace</span></tt></code> members (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">345</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> uses its arguments to construct an object of the given type. For example, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared&lt;string&gt;</span></tt></code> must pass argument(s) that match one of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> constructors. Calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared&lt;int&gt;</span></tt></code> can pass any value we can use to initialize an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. And so on. If we do not pass any arguments, then the object is value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Of course, ordinarily we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>) to make it easier to define an object to hold the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p6</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a dynamically allocated, empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;string&gt;</span></span></tt></span><br class="calibre6"/>auto p6 = make_shared&lt;vector&lt;string&gt;&gt;();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Copying and Assigning <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, each <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> keeps track of how many other <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s point to the same object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto p = make_shared&lt;int&gt;(42); // <span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points has one user</span></span></span><br class="calibre6"/>auto q(p); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to the same object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point has two users</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2919193"/>We can think of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> as if it has an associated counter, usually referred to as a <strong class="calibre5"><a id="filepos2919362" href="118-defined_terms.html#filepos3190670">reference count</a></strong>. Whenever we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, the count is incremented. For example, the counter associated with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> is incremented when we use it to initialize another <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, when we use it as the right-hand operand of an assignment, or when we pass it to (&#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>) or return it from a function by value (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). The counter is decremented when we assign a new value to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> and when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> itself is destroyed, such as when a local <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> goes out of scope (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Once a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>&#8217;s counter goes to zero, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> automatically frees the object that it manages:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto r = make_shared&lt;int&gt;(42); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points has one user</span></span></span><br class="calibre6"/>r = q;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">making it point to a different address</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">increase the use count for the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reduce the use count of the object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">had pointed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the object</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">r</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">had pointed to has no users; that object is automatically freed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we allocate an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and store a pointer to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code>. Next, we assign a new value to <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code>. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> is the only <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> pointing to the one we previously allocated. That <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> is automatically freed as part of assigning <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is up to the implementation whether to use a counter or another data structure to keep track of how many pointers share state. The key point is that the class keeps track of how many <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s point to the same object and automatically frees that object when appropriate.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code>s Automatically Destroy Their Objects ...</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> pointing to an object is destroyed, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class automatically destroys the object to which that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points. It does so through another special member function known as a <strong class="calibre5"><a id="filepos2924901" href="118-defined_terms.html#filepos3188004">destructor</a></strong>. Analogous to its constructors, each class has a destructor. Just as a constructor controls initialization, the destructor controls what happens when objects of that class type are destroyed.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2925221"/>Destructors generally free the resources that an object has allocated. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> constructors (and other <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> members) allocate memory to hold the characters that compose the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> destructor frees that memory. Similarly, several <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> operations allocate memory to hold the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. The destructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> destroys those elements and frees the memory used for the elements.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The destructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> decrements the reference count of the object to which that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points. If the count goes to zero, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> destructor destroys the object to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points and frees the memory used by that object.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">...and Automatically Free the Associated Memory</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class automatically frees dynamic objects when they are no longer needed makes it fairly easy to use dynamic memory. For example, we might have a function that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a dynamically allocated object of a type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code> that can be initialized by an argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">factory</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointing to a dynamically allocated object</span></span></span><br class="calibre6"/>shared_ptr&lt;Foo&gt; factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as appropriate</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will take care of deleting this memory</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return make_shared&lt;Foo&gt;(arg);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, we can be sure that the object allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> will be freed when appropriate. For example, the following function stores the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> in a local variable:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void use_factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;shared_ptr&lt;Foo&gt; p = factory(arg);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">goes out of scope; the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points is automatically freed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a/>Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is local to <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code>, it is destroyed when <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code> ends (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>). When <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is destroyed, its reference count is decremented and checked. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is the only object referring to the memory returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is about to go away, the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points will be destroyed and the memory in which that object resides will be freed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The memory will not be freed if there is any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> pointing to it:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;Foo&gt; use_factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;shared_ptr&lt;Foo&gt; p = factory(arg);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return p;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reference count is incremented when we return</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">goes out of scope; the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points is not freed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this version, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> statement in <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code> returns a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> to its caller (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). Copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> adds to the reference count of that object. Now when <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is destroyed, there will be another user for the memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class ensures that so long as there are any <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s attached to that memory, the memory itself will not be freed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because memory is not freed until the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> goes away, it can be important to be sure that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s don&#8217;t stay around after they are no longer needed. The program will execute correctly but may waste memory if you neglect to destroy <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s that the program does not need. One way that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s might stay around after you need them is if you put <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s in a container and subsequently reorder the container so that you don&#8217;t need all the elements. You should be sure to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase shared_ptr</span></tt></code> elements once you no longer need those elements.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If you put <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s in a container, and you subsequently need to use some, but not all, of the elements, remember to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> the elements you no longer need.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Classes with Resources That Have Dynamic Lifetime</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Programs tend to use dynamic memory for one of three purposes:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> They don&#8217;t know how many objects they&#8217;ll need</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> They don&#8217;t know the precise type of the objects they need</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong> They want to share data between several objects</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The container classes are an example of classes that use dynamic memory for the first purpose and we&#8217;ll see examples of the second in <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a>. In this section, we&#8217;ll define a class that uses dynamic memory in order to let several objects share the same underlying data.</p><div class="calibre15">&#160;</div>
<p class="calibre25">So far, the classes we&#8217;ve used allocate resources that exist only as long as the corresponding objects. For example, each <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> &#8220;owns&#8221; its own elements. When we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, the elements in the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and in the copy are separate from one another:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2936823"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; v1; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>{ // <span><span class="calibre45"><span class="calibre16">new scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;string&gt; v2 = {"a", "an", "the"};<br class="calibre6"/>&#160;&#160;&#160;&#160;v1 = v2; // <span><span class="calibre45"><span class="calibre16">copies the elements from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is destroyed, which destroys the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span><br class="calibre6"/>&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has three elements, which are copies of the ones originally in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The elements allocated by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> exist only while the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> itself exists. When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is destroyed, the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> are also destroyed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Some classes allocate resources with a lifetime that is independent of the original object. As an example, assume we want to define a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> that will hold a collection of elements. Unlike the containers, we want <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> objects that are copies of one another to share the same elements. That is, when we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>, the original and the copy should refer to the same underlying elements.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In general, when two objects share the same underlying data, we can&#8217;t unilaterally destroy the data when an object of that type goes away:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Blob&lt;string&gt; b1;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Blob</span></span></tt></span><br class="calibre6"/>{ // <span><span class="calibre45"><span class="calibre16">new scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Blob&lt;string&gt; b2 = {"a", "an", "the"};<br class="calibre6"/>&#160;&#160;&#160;&#160;b1 = b2; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">share the same elements</span></span></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is destroyed, but the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must not be destroyed</span></span></span><br class="calibre6"/>&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the elements originally created in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">b1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> share the same elements. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> goes out of scope, those elements must stay around, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">b1</span></tt></code> is still using them.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">One common reason to use dynamic memory is to allow multiple objects to share the same state.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrBlob</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Ultimately, we&#8217;ll implement our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> class as a template, but we won&#8217;t learn how to do so until &#167; <a href="154-16.1._defining_a_template.html#filepos4193169">16.1.2</a> (p. <a href="154-16.1._defining_a_template.html#filepos4193169">658</a>). For now, we&#8217;ll define a version of our class that can manage <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. As a result, we&#8217;ll name this version of our class <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The easiest way to implement a new collection type is to use one of the library containers to manage the elements. That way, we can let the library type manage the storage for the elements themselves. In this case, we&#8217;ll use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to hold our elements.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, we can&#8217;t store the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> directly in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> object. Members of an object are destroyed when the object itself is destroyed. For example, assume that <code class="calibre23"><tt class="calibre23"><span class="calibre24">b1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> are two <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code>s that share the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. If that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> were stored in one of those <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blobs</span></tt></code>&#8212;say, <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code>&#8212;then that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, and therefore its elements, would no longer exist once <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> goes out of scope. To ensure that the elements continue to exist, we&#8217;ll store the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in dynamic memory.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To implement the sharing we want, we&#8217;ll give each <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a dynamically allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. That <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> member will keep track of how many <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobs</span></tt></code> share the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and will delete the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> when the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> using that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is destroyed.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos2945498"/>We still need to decide what operations our class will provide. For now, we&#8217;ll implement a small subset of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> operations. We&#8217;ll also change the operations that access elements (e.g., <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code>): In our class, these operations will throw an exception if a user attempts to access an element that doesn&#8217;t exist.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our class will have a default constructor and a constructor that has a parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;string&gt;</span></tt></code> (&#167; <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a>, p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>). This constructor will take a braced list of initializers.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrBlob {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;typedef std::vector&lt;std::string&gt;::size_type size_type;<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlob();<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlob(std::initializer_list&lt;std::string&gt; il);<br class="calibre6"/>&#160;&#160;&#160;&#160;size_type size() const { return data-&gt;size(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;bool empty() const { return data-&gt;empty(); }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">add and remove elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void push_back(const std::string &amp;t) {data-&gt;push_back(t);}<br class="calibre6"/>&#160;&#160;&#160;&#160;void pop_back();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">element access</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::string&amp; front();<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string&amp; back();<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">throws</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">msg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">data[i]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">isn't valid</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void check(size_type i, const std::string &amp;msg) const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Inside the class we implemented the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> members. These members forward their work through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> pointer to the underlying <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">size()</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">data-&gt;size()</span></tt></code>, and so on.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrBlob</span></span></tt></span></span></tt></code> Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Each constructor uses its constructor initializer list (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">265</a>) to initialize its <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member to point to a dynamically allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. The default constructor allocates an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrBlob::StrBlob(): data(make_shared&lt;vector&lt;string&gt;&gt;()) { }<br class="calibre6"/>StrBlob::StrBlob(initializer_list&lt;string&gt; il):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data(make_shared&lt;vector&lt;string&gt;&gt;(il)) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> passes its parameter to the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> constructor (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>). That constructor initializes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s elements by copying the values in the list.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Element Access Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> operations access members in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. These operations must check that an element exists before attempting to access that element. Because several members need to do the same checking, we&#8217;ve given <a id="filepos2951402"/>our class a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> utility function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> that verifies that a given index is in range. In addition to an index, <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument that it will pass to the exception handler. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> describes what went wrong:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void StrBlob::check(size_type i, const string &amp;msg) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (i &gt;= data-&gt;size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw out_of_range(msg);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code> and element access members first call <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> succeeds, these members forward their work to the underlying <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> operation:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string&amp; StrBlob::front()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is empty,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;check(0, "front on empty StrBlob");<br class="calibre6"/>&#160;&#160;&#160;&#160;return data-&gt;front();<br class="calibre6"/>}<br class="calibre6"/>string&amp; StrBlob::back()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;check(0, "back on empty StrBlob");<br class="calibre6"/>&#160;&#160;&#160;&#160;return data-&gt;back();<br class="calibre6"/>}<br class="calibre6"/>void StrBlob::pop_back()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;check(0, "pop_back on empty StrBlob");<br class="calibre6"/>&#160;&#160;&#160;&#160;data-&gt;pop_back();<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> members should be overloaded on <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="075-7.3._additional_class_features.html#filepos1876631">7.3.2</a>, p. <a href="075-7.3._additional_class_features.html#filepos1876631">276</a>). Defining those versions is left as an exercise.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Copying, Assigning, and Destroying <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">StrBlob</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class, <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> uses the default versions of the operations that copy, assign, and destroy objects of its type (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). By default, these operations copy, assign, and destroy the data members of the class. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> has only one data member, which is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Therefore, when we copy, assign, or destroy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>, its <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> member will be copied, assigned, or destroyed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> increments its reference count; assigning one <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to another increments the count of the right-hand operand and decrements the count in the left-hand operand; and destroying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> decrements the count. If the count in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> goes to zero, the object to which that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points is automatically destroyed. Thus, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> allocated by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> constructors will be automatically destroyed when the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> pointing to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is destroyed.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2956866"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.1:</strong> How many elements do <code class="calibre23"><tt class="calibre23"><span class="calibre24">b1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b2</span></tt></code> have at the end of this code?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrBlob b1;<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlob b2 = {"a", "an", "the"};<br class="calibre6"/>&#160;&#160;&#160;&#160;b1 = b2;<br class="calibre6"/>&#160;&#160;&#160;&#160;b2.push_back("about");<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.2:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class including the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.3:</strong> Does this class need <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code>? If so, add them. If not, why aren&#8217;t they needed?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.4:</strong> In our <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> function we didn&#8217;t check whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> was greater than zero. Why is it okay to omit that check?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.5:</strong> We did not make the constructor that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list explicit</span></tt></code> (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>). Discuss the pros and cons of this design choice.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2959483" class="calibre37"><span class="calibre5">12.1.2. Managing Memory Directly</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The language itself defines two operators that allocate and free dynamic memory. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> operator allocates memory, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> frees memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For reasons that will become clear as we describe how these operators work, using these operators to manage memory is considerably more error-prone than using a smart pointer. Moreover, classes that do manage their own memory&#8212;unlike those that use smart pointers&#8212;cannot rely on the default definitions for the members that copy, assign, and destroy class objects (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>). As a result, programs that use smart pointers are likely to be easier to write and debug.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Until you have read <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>, your classes should allocate dynamic memory <em class="calibre16">only</em> if they use smart pointers to manage that memory.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> to Dynamically Allocate and Initialize Objects</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Objects allocated on the free store are unnamed, so <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> offers no way to name the objects that it allocates. Instead, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> returns a pointer to the object it allocates:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *pi = new int;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a dynamically allocated,</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">unnamed, uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression constructs an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> on the free store and returns a pointer to that object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">By default, dynamically allocated objects are default initialized (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>), which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2963288"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *ps = new string;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">initialized to empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>int *pi = new int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2964063"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">We can initialize a dynamically allocated object using direct initialization (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>). We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *pi = new int(1024); // <span><span class="calibre45"><span class="calibre16">object to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1024</span></span></tt></span><br class="calibre6"/>string *ps = new string(10, '9');&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"9999999999"</span></span></tt></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with ten elements with values from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">9</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt; *pv = new vector&lt;int&gt;{0,1,2,3,4,5,6,7,8,9};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">We can also value initialize (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) a dynamically allocated object by following the type name with a pair of empty parentheses:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *ps1 = new string;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default initialized to the empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>string *ps = new string(); // <span><span class="calibre45"><span class="calibre16">value initialized to the empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>int *pi1 = new int;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default initialized;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*pi1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is undefined</span></span></span><br class="calibre6"/>int *pi2 = new int();&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">value initialized to 0;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*pi2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For class types (such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>) that define their own constructors (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>), requesting value initialization is of no consequence; regardless of form, the object is initialized by the default constructor. In the case of built-in types the difference is significant; a value-initialized object of built-in type has a well-defined value but a default-initialized object does not. Similarly, members of built-in type in classes that rely on the synthesized default constructor will also be uninitialized if those members are not initialized in the class body (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre28"><a id="filepos2968774"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">When we provide an initializer inside parentheses, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>) to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer&#8217;s type to deduce the type to allocate, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> only with a single initializer inside parentheses:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto p1 = new auto(obj);&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an object of the type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">that object is initialized from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">obj</span></span></tt></span><br class="calibre6"/>auto p2 = new auto{a,b,c}; // <span><span class="calibre45"><span class="calibre16">error: must use parentheses for the initializer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> is a pointer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code>-deduced type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*;</span></tt></code> if <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string*;</span></tt></code> and so on. The newly allocated object is initialized from the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">obj</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Dynamically Allocated <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Objects</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is legal to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to allocate <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> objects:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">allocate and initialize a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>const int *pci = new const int(1024);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">allocate a default-initialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>const string *pcs = new const string;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2972849"/>Like any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, a dynamically allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object must be initialized. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> dynamic object of a class type that defines a default constructor (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>) may be initialized implicitly. Objects of other types must be explicitly initialized. Because the allocated object is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Memory Exhaustion</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. Once a program has used all of its available memory, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expressions will fail. By default, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is unable to allocate the requested storage, it throws an exception of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code> (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>). We can prevent <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> from throwing an exception by using a different form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">if allocation fails,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">new</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a null pointer</span></span></span><br class="calibre6"/>int *p1 = new int; // <span><span class="calibre45"><span class="calibre16">if allocation fails,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">new</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">throws</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">std::bad_alloc</span></span></tt></span><br class="calibre6"/>int *p2 = new (nothrow) int; // <span><span class="calibre45"><span class="calibre16">if allocation fails,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">new</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a null pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For reasons we&#8217;ll explain in &#167; <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">19.1.2</a> (p. <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">824</a>) this form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is referred to as <strong class="calibre5"><a id="filepos2976074" href="118-defined_terms.html#filepos3190070">placement new</a></strong>. A placement new expression lets us pass additional arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. In this case, we pass an object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">nothrow</span></tt></code> that is defined by the library. When we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">nothrow</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>, we tell <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> that it must not throw an exception. If this form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> is unable to allocate the requested storage, it will return a null pointer. Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">nothrow</span></tt></code> are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Freeing Dynamic Memory</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">delete</span></span></tt></span></span></tt></code>
<strong class="calibre5">expression</strong>. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression takes a pointer to the object we want to free:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">delete p;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must point to a dynamically allocated object or be null</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expression performs two actions: It destroys the object to which its given pointer points, and it frees the corresponding memory.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer Values and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">delete</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The pointer we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> must either point to dynamically allocated memory or be a null pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>). Deleting a pointer to memory that was not allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>, or deleting the same pointer value more than once, is undefined:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i, *pi1 = &amp;i, *pi2 = nullptr;<br class="calibre6"/>double *pd = new double(33), *pd2 = pd;<br class="calibre6"/>delete i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a pointer</span></span></span><br class="calibre6"/>delete pi1; // <span><span class="calibre45"><span class="calibre16">undefined:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pi1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to a local</span></span></span><br class="calibre6"/>delete pd;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok</span></span></span><br class="calibre6"/>delete pd2; // <span><span class="calibre45"><span class="calibre16">undefined: the memory pointed to by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pd2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">was already freed</span></span></span><br class="calibre6"/>delete pi2; // <span><span class="calibre45"><span class="calibre16">ok: it is always ok to delete a null pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2980688"/>The compiler will generate an error for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> because it knows that <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is not a pointer. The errors associated with executing <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">pi1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pd2</span></tt></code> are more insidious: In general, compilers cannot tell whether a pointer points to a statically or dynamically allocated object. Similarly, the compiler cannot tell whether memory addressed by a pointer has already been freed. Most compilers will accept these <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> expressions, even though they are in error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although the value of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object cannot be modified, the object itself can be destroyed. As with any other dynamic object, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> dynamic object is freed by executing <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on a pointer that points to that object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const int *pci = new const int(1024);<br class="calibre6"/>delete pci;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: deletes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Dynamically Allocated Objects Exist until They Are Freed</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we saw in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>), memory that is managed through a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> is automatically deleted when the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> is destroyed. The same is not true for memory we manage using built-in pointers. A dynamic object managed through a built-in pointer exists until it is explicitly deleted.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Functions that return pointers (rather than smart pointers) to dynamic memory put a burden on their callers&#8212;the caller must remember to delete the memory:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">factory</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a pointer to a dynamically allocated object</span></span></span><br class="calibre6"/>Foo* factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as appropriate</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return new Foo(arg); // <span><span class="calibre45"><span class="calibre16">caller is responsible for deleting this memory</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like our earlier <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> function (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">453</a>), this version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> allocates an object but does not <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> it. Callers of <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code> are responsible for freeing this memory when they no longer need the allocated object. Unfortunately, all too often the caller forgets to do so:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void use_factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo *p = factory(arg);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">but do not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">it</span></span></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">goes out of scope, but the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points is not freed!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code> function calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code>, which allocates a new object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Foo</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code> returns, the local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is destroyed. That variable is a built-in pointer, not a smart pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike class types, nothing happens when objects of built-in type are destroyed. In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. If that pointer points to dynamic memory, that memory is not automatically freed.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Dynamic memory managed through built-in pointers (rather than smart pointers) exists until it is explicitly freed.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25"><a id="filepos2987662"/>In this example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> was the only pointer to the memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">factory</span></tt></code>. Once <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code> returns, the program has no way to free that memory. Depending on the logic of our overall program, we should fix this bug by remembering to free the memory inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void use_factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo *p = factory(arg);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;delete p;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remember to free the memory now that we no longer need it</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">or, if other code in our system needs to use the object allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">use_factory</span></tt></code>, we should change that function to return a pointer to the memory it allocated:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Foo* use_factory(T arg)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Foo *p = factory(arg);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return p;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">caller must</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">the memory</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Managing Dynamic Memory Is Error-Prone</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">There are three common problems with using <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> to manage dynamic memory:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> Forgetting to <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> memory. Neglecting to delete dynamic memory is known as a &#8220;memory leak,&#8221; because the memory is never returned to the free store. Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually exhaust memory.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> Using an object after it has been deleted. This error can sometimes be detected by making the pointer null after the delete.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">3.</strong> Deleting the same memory twice. This error can happen when two pointers address the same dynamically allocated object. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> is applied to one of the pointers, then the object&#8217;s memory is returned to the free store. If we subsequently <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the second pointer, then the free store may be corrupted.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">These kinds of errors are considerably easier to make than they are to find and fix.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00090.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">You can avoid <em class="calibre16">all</em> of these problems by using smart pointers exclusively. The smart pointer will take care of deleting the memory <em class="calibre16">only</em> when there are no remaining smart pointers pointing to that memory.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Resetting the Value of a Pointer after a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">delete ...</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>, the pointer becomes what is referred to as a <a id="filepos2993287"/><strong class="calibre5"><a id="filepos2993303" href="118-defined_terms.html#filepos3186618">dangling pointer</a></strong>. A dangling pointer is one that refers to memory that once held an object but no longer does so.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Dangling pointers have all the problems of uninitialized pointers (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">54</a>). We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> to the pointer after we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>. Doing so makes it clear that the pointer points to no object.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">...Provides Only Limited Protection</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. Resetting the pointer we use to <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> that memory lets us check that particular pointer but has no effect on any of the other pointers that still point at the (freed) memory. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p(new int(42));&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to dynamic memory</span></span></span><br class="calibre6"/>auto q = p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to the same memory</span></span></span><br class="calibre6"/>delete p;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">invalidates both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span><br class="calibre6"/>p = nullptr; // <span><span class="calibre45"><span class="calibre16">indicates that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is no longer bound to an object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here both <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> point at the same dynamically allocated object. We <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> that memory and set <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code>, indicating that the pointer no longer points to an object. However, resetting <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> has no effect on <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code>, which became invalid when we deleted the memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code>!) pointed. In real systems, finding all the pointers that point to the same memory is surprisingly difficult.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.6:</strong> Write a function that returns a dynamically allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Pass that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to another function that reads the standard input to give values to the elements. Pass the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to another function to print the values that were read. Remember to <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> at the appropriate time.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.7:</strong> Redo the previous exercise, this time using <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.8:</strong> Explain what if anything is wrong with the following function.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool b() {<br class="calibre6"/>&#160;&#160;&#160;&#160;int* p = new int;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">...</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return p;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.9:</strong> Explain what happens in the following code:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *q = new int(42), *r = new int(100);<br class="calibre6"/>r = q;<br class="calibre6"/>auto q2 = make_shared&lt;int&gt;(42), r2 = make_shared&lt;int&gt;(100);<br class="calibre6"/>r2 = q2;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2999606" class="calibre37"><span class="calibre5"><a id="filepos2999639"/>12.1.3. Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code>s with <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. As described in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3001332">Table 12.3</a>, we can also initialize a smart pointer from a pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;double&gt; p1; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that can point at a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>shared_ptr&lt;int&gt; p2(new int(42)); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3001332"/>Table 12.3. Other Ways to Define and Change <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code><strong class="calibre5">s</strong></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00091.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">The smart pointer constructors that take pointers are <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> (&#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>). Hence, we cannot implicitly convert a built-in pointer to a smart pointer; we must use the direct form of initialization (&#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) to initialize a smart pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; p1 = new int(1024);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: must use direct initialization</span></span></span><br class="calibre6"/>shared_ptr&lt;int&gt; p2(new int(1024));&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: uses direct initialization</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> implicitly asks the compiler to create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int*</span></tt></code> returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. Because we can&#8217;t implicitly convert a pointer to a smart pointer, this initialization is an error. For the same reason, a function that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> cannot implicitly convert a plain pointer in its return statement:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; clone(int p) {<br class="calibre6"/>&#160;&#160;&#160;&#160;return new int(p); // <span><span class="calibre45"><span class="calibre16">error: implicit conversion to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr&lt;int&gt;</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We must explicitly bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the pointer we want to return:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; clone(int p) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: explicitly create a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return shared_ptr&lt;int&gt;(new int(p));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">By default, a pointer used to initialize a smart pointer must point to dynamic memory because, by default, smart pointers use <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> to free the associated object. We can bind smart pointers to pointers to other kinds of resources. However, to do so, we must supply our own operation to use in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>. We&#8217;ll see how to supply our own deletion code in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Don&#8217;t Mix Ordinary Pointers and Smart Pointers ...</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> can coordinate destruction only with other <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s that are copies of itself. Indeed, this fact is one of the reasons we recommend using <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. That way, we bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the object at the same time that we allocate it. There is no way to inadvertently bind the same memory to more than one independently created <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Consider the following function that operates on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is created and initialized when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">process</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is called</span></span></span><br class="calibre6"/>void process(shared_ptr&lt;int&gt; ptr)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ptr</span></span></tt></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">goes out of scope and is destroyed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a/>The parameter to <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> is passed by value, so the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> is copied into <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr</span></tt></code>. Copying a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> increments its reference count. Thus, inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> the count is at least 2. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> completes, the reference count of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr</span></tt></code> is decremented but cannot go to zero. Therefore, when the local variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr</span></tt></code> is destroyed, the memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr</span></tt></code> points will not be deleted.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The right way to use this function is to pass it a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; p(new int(42)); // <span><span class="calibre45"><span class="calibre16">reference count is 1</span></span></span><br class="calibre6"/>process(p); // <span><span class="calibre45"><span class="calibre16">copying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">increments its count; in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">process</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">the reference count is 2</span></span></span><br class="calibre6"/>int i = *p; // <span><span class="calibre45"><span class="calibre16">ok: reference count is 1</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Although we cannot pass a built-in pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code>, we can pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> a (temporary) <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> that we explicitly construct from a built-in pointer. However, doing so is likely to be an error:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *x(new int(1024)); // <span><span class="calibre45"><span class="calibre16">dangerous:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">x</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a plain pointer, not a smart pointer</span></span></span><br class="calibre6"/>process(x);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot convert</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr&lt;int&gt;</span></span></tt></span><br class="calibre6"/>process(shared_ptr&lt;int&gt;(x)); // <span><span class="calibre45"><span class="calibre16">legal, but the memory will be deleted!</span></span></span><br class="calibre6"/>int j = *x;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">undefined:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">x</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a dangling pointer!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this call, we passed a temporary <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code>. That temporary is destroyed when the expression in which the call appears finishes. Destroying the temporary decrements the reference count, which goes to zero. The memory to which the temporary points is freed when the temporary is destroyed.</p><div class="calibre15">&#160;</div>
<p class="calibre25">But <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> continues to point to that (freed) memory; <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> is now a dangling pointer. Attempting to use the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> is undefined.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to a plain pointer, we give responsibility for that memory to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Once we give <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> responsibility for a pointer, we should no longer use a built-in pointer to access the memory to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> now points.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos3013215"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is dangerous to use a built-in pointer to access an object owned by a smart pointer, because we may not know when that object is destroyed.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">...and Don&#8217;t Use <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">get</span></span></tt></span></span></tt></code> to Initialize or Assign Another Smart Pointer</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">The smart pointer types define a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> (described in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>)) that returns a built-in pointer to the object that the smart pointer is managing. This function is intended for cases when we need to pass a built-in pointer to code that can&#8217;t use a smart pointer. The code that uses the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> must not <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> that pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although the compiler will not complain, it is an error to bind another smart pointer to the pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; p(new int(42)); // <span><span class="calibre45"><span class="calibre16">reference count is 1</span></span></span><br class="calibre6"/>int *q = p.get();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but don't use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in any way that might delete its pointer</span></span></span><br class="calibre6"/>{ // <span><span class="calibre45"><span class="calibre16">new block</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">undefined: two independent</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s point to the same memory</span></span></span><br class="calibre6"/>shared_ptr&lt;int&gt;(q);<br class="calibre6"/>} // <span><span class="calibre45"><span class="calibre16">block ends,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is destroyed, and the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points is freed</span></span></span><br class="calibre6"/>int foo = *p; // <span><span class="calibre45"><span class="calibre16">undefined; the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points was freed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, both <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> point to the same memory. Because they were created independently from each other, each has a reference count of 1. When the block in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> was defined ends, <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> is destroyed. Destroying <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> frees the memory to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> points. That makes <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> into a dangling pointer, meaning that what happens when we attempt to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is undefined. Moreover, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is destroyed, the pointer to that memory will be <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>d a second time.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> only to pass access to the pointer to code that you know will not <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the pointer. In particular, never use <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> to initialize or assign to another smart pointer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Other <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">shared_ptr</span></span></tt></span></span></tt></code> Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class gives us a few other operations, which are listed in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">Table 12.2</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">453</a>) and <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3001332">Table 12.3</a> (on the previous page). We can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> to assign a new pointer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">p = new int(1024);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign a pointer to a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span><br class="calibre6"/>p.reset(new int(1024));&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a new object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like assignment, <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> updates the reference counts and, if appropriate, deletes the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> member is often used together with <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique</span></tt></code> to control changes to the object shared among several <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s. Before changing the underlying object, we check whether we&#8217;re the only user. If not, we make a new copy before making the change:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (!p.unique())<br class="calibre6"/>&#160;&#160;&#160;&#160;p.reset(new string(*p)); // <span><span class="calibre45"><span class="calibre16">we aren't alone; allocate a new copy</span></span></span><br class="calibre6"/>*p += newVal; // <span><span class="calibre45"><span class="calibre16">now that we know we're the only pointer, okay to change this object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos3021386"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.10:</strong> Explain whether the following call to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> function defined on page <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999639">464</a> is correct. If not, how would you correct the call?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">shared_ptr&lt;int&gt; p(new int(42));<br class="calibre6"/>process(shared_ptr&lt;int&gt;(p));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.11:</strong> What would happen if we called <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code> as follows?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">process(shared_ptr&lt;int&gt;(p.get()));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.12:</strong> Using the declarations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> explain each of the following calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">process</span></tt></code>. If the call is legal, explain what it does. If the call is illegal, explain why:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto p = new int();<br class="calibre6"/>auto sp = make_shared&lt;int&gt;();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">process(sp);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">process(new int());</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">process(p);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">process(shared_ptr&lt;int&gt;(p));</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a/><strong class="calibre5">Exercise 12.13</strong>: What happens if we execute the following code?</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto sp = make_shared&lt;int&gt;();<br class="calibre6"/>auto p = sp.get();<br class="calibre6"/>delete p;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3024819" class="calibre37"><span class="calibre5">12.1.4. Smart Pointers and Exceptions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">In &#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">5.6.2</a> (p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">196</a>) we noted that programs that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed if an exception occurs. One easy way to make sure resources are freed is to use smart pointers.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we use a smart pointer, the smart pointer class ensures that memory is freed when it is no longer needed even if the block is exited prematurely:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;shared_ptr&lt;int&gt; sp(new int(42)); // <span><span class="calibre45"><span class="calibre16">allocate a new object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">code that throws an exception that is not caught inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span><br class="calibre6"/>} // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">freed automatically when the function ends</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, so destroying <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> checks its reference count. Here, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code> is the only pointer to the memory it manages; that memory will be freed as part of destroying <code class="calibre23"><tt class="calibre23"><span class="calibre24">sp</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In contrast, memory that we manage directly is not automatically freed when an exception occurs. If we use built-in pointers to manage memory and an exception occurs after a <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> but before the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>, then that memory won&#8217;t be freed:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3027622"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;int *ip = new int(42);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">dynamically allocate a new object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">code that throws an exception that is not caught inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;delete ip;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free the memory before exiting</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If an exception happens between the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>, and is not caught inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>, then this memory can never be freed. There is no pointer to this memory outside the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code>. Thus, there is no way to free this memory.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Smart Pointers and Dumb Classes</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Many C++ classes, including all the library classes, define destructors (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>) that take care of cleaning up the resources used by that object. However, not all classes are so well behaved. In particular, classes that are designed to be used by both C and C++ generally require the user to specifically free any resources that are used.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Classes that allocate resources&#8212;and that do not define destructors to free those resources&#8212;can be subject to the same kind of errors that arise when we use dynamic memory. It is easy to forget to release the resource. Similarly, if an exception happens between when the resource is allocated and when it is freed, the program will leak that resource.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can often use the same kinds of techniques we use to manage dynamic memory to manage classes that do not have well-behaved destructors. For example, imagine we&#8217;re using a network library that is used by both C and C++. Programs that use this library might contain code such as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct destination;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">represents what we are connecting to</span></span></span><br class="calibre6"/>struct connection;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">information needed to use the connection</span></span></span><br class="calibre6"/>connection connect(destination*);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">open the connection</span></span></span><br class="calibre6"/>void disconnect(connection);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">close the given connection</span></span></span><br class="calibre6"/>void f(destination &amp;d /* <span><span class="calibre45"><span class="calibre16">other parameters</span></span></span> */)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">connection</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">must remember to close it when done</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;connection c = connect(&amp;d);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the connection</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if we forget to call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">disconnect</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">before exiting</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">there will be no way to close</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection</span></tt></code> had a destructor, that destructor would automatically close the connection when <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> completes. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection</span></tt></code> does not have a destructor. This problem is nearly identical to our previous program that used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to avoid memory leaks. It turns out that we can also use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to ensure that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection</span></tt></code> is properly closed.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Our Own Deletion Code</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">By default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s assume that they point to dynamic memory. Hence, by default, when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> is destroyed, it executes <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on the pointer it <a id="filepos3033762"/>holds. To use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to manage a <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection</span></tt></code>, we must first define a function to use in place of <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code>. It must be possible to call this <strong class="calibre5"><a id="filepos3034110" href="118-defined_terms.html#filepos3187653">deleter</a></strong> function with the pointer stored inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. In this case, our deleter must take a single argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection*</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void end_connection(connection *p) { disconnect(*p); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, we can pass an optional argument that points to a deleter function (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f(destination &amp;d /* <span><span class="calibre45"><span class="calibre16">other parameters</span></span></span> */)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;connection c = connect(&amp;d);<br class="calibre6"/>&#160;&#160;&#160;&#160;shared_ptr&lt;connection&gt; p(&amp;c, end_connection);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the connection</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">exits, even if by an exception, the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">connection</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be properly closed</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is destroyed, it won&#8217;t execute <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on its stored pointer. Instead, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">end_connection</span></tt></code> on that pointer. In turn, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end_connection</span></tt></code> will call <code class="calibre23"><tt class="calibre23"><span class="calibre24">disconnect</span></tt></code>, thus ensuring that the connection is closed. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> exits normally, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> will be destroyed as part of the return. Moreover, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> will also be destroyed, and the connection will be closed, if an exception occurs.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Smart Pointer Pitfalls</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Smart pointers can provide safety and convenience for handling dynamically allocated memory only when they are used properly. To use smart pointers correctly, we must adhere to a set of conventions:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Don&#8217;t use the same built-in pointer value to initialize (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>) more than one smart pointer.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Don&#8217;t <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the pointer returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">get()</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Don&#8217;t use <code class="calibre23"><tt class="calibre23"><span class="calibre24">get()</span></tt></code> to initialize or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> another smart pointer.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If you use a pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">get()</span></tt></code>, remember that the pointer will become invalid when the last corresponding smart pointer goes away.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If you use a smart pointer to manage a resource other than memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>, remember to pass a deleter (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>, and &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>).</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.14:</strong> Write your own version of a function that uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to manage a <code class="calibre23"><tt class="calibre23"><span class="calibre24">connection</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.15:</strong> Rewrite the first exercise to use a lambda (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) in place of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end_connection</span></tt></code> function.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3040235" class="calibre37"><span class="calibre5"><a id="filepos3040268"/>12.1.5. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3040473"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> &#8220;owns&#8221; the object to which it points. Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, only one <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> at a time can point to a given object. The object to which a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> points is destroyed when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> is destroyed. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3041443">Table 12.4</a> lists the operations specific to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>s. The operations common to both were covered in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3041443"/>Table 12.4. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code> Operations (See Also <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>))</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00092.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, there is no library function comparable to <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. Instead, when we define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>, we bind it to a pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s, we must use the direct form of initialization:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unique_ptr&lt;double&gt; p1;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unique_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that can point at a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;int&gt; p2(new int(42)); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Because a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> owns the object to which it points, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> does not support ordinary copy or assignment:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unique_ptr&lt;string&gt; p1(new string("Stegosaurus"));<br class="calibre6"/>unique_ptr&lt;string&gt; p2(p1);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no copy for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unique_ptr</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;string&gt; p3;<br class="calibre6"/>p3 = p2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no assign for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unique_ptr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although we can&#8217;t copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>, we can transfer ownership from one (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> to another by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">transfers ownership from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(which points to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string Stegosaurus</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;string&gt; p2(p1.release()); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">release</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">makes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">null</span></span></span><br class="calibre6"/>unique_ptr&lt;string&gt; p3(new string("Trex"));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">transfers ownership from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span><br class="calibre6"/>p2.reset(p3.release()); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reset</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">deletes the memory to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">had pointed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code> member returns the pointer currently stored in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> and makes that <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> null. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> is initialized from the pointer value that had been stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> becomes null.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos3047668"/>The <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> member takes an optional pointer and repositions the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> to point to the given pointer. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> is not null, then the object to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> had pointed is deleted. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code>, therefore, frees the memory used by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> initialized from <code class="calibre23"><tt class="calibre23"><span class="calibre24">"Stegosaurus"</span></tt></code>, transfers <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code>&#8217;s pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code>, and makes <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> null.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code> breaks the connection between a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> and the object it had been managing. Often the pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code> is used to initialize or assign another smart pointer. In that case, responsibility for managing the memory is simply transferred from one smart pointer to another. However, if we do not use another smart pointer to hold the pointer returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code>, our program takes over responsibility for freeing that resource:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">p2.release(); // <span><span class="calibre45"><span class="calibre16">WRONG:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">won't free the memory and we've lost the pointer</span></span></span><br class="calibre6"/>auto p = p2.release(); // <span><span class="calibre45"><span class="calibre16">ok, but we must remember to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete(p</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Passing and Returning <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code>s</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">There is one exception to the rule that we cannot copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr:</span></tt></code> We can copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> that is about to be destroyed. The most common example is when we return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> from a function:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unique_ptr&lt;int&gt; clone(int p) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: explicitly create a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unique_ptr&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return unique_ptr&lt;int&gt;(new int(p));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Alternatively, we can also return a copy of a local object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unique_ptr&lt;int&gt; clone(int p) {<br class="calibre6"/>&#160;&#160;&#160;&#160;unique_ptr&lt;int&gt; ret(new int (p));<br class="calibre6"/>&#160;&#160;&#160;&#160;// . . .<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In both cases, the compiler knows that the object being returned is about to be destroyed. In such cases, the compiler does a special kind of &#8220;copy&#8221; which we&#8217;ll discuss in &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Backward Compatibility: <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">auto_ptr</span></span></tt></span></span></tt></code></span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Earlier versions of the library included a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto_ptr</span></tt></code> that had some, but not all, of the properties of <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. In particular, it was not possible to store an <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto_ptr</span></tt></code> in a container, nor could we return one from a function.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto_ptr</span></tt></code> is still part of the standard library, programs should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> instead.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Passing a Deleter to <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, by default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> to free the object to which a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> points. As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, we can override the default <a id="filepos3054611"/>deleter in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>). However, for reasons we&#8217;ll describe in &#167; <a href="154-16.1._defining_a_template.html#filepos4310778">16.1.6</a> (p. <a href="154-16.1._defining_a_template.html#filepos4310778">676</a>), the way <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> manages its deleter is differs from the way <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> does.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Overridding the deleter in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> affects the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> type as well as how we construct (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code>) objects of that type. Similar to overriding the comparison operation of an associative container (&#167; <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>), we must supply the deleter type inside the angle brackets along with the type to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> can point. We supply a callable object of the specified type when we create or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reset</span></tt></code> an object of this type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an object of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">objT</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and uses an object of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delT</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to free that object</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">it will call an object named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delT</span></span></tt></span><br class="calibre6"/>unique_ptr&lt;objT, delT&gt; p (new objT, fcn);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As a somewhat more concrete example, we&#8217;ll rewrite our connection program to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> in place of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f(destination &amp;d /* <span><span class="calibre45"><span class="calibre16">other needed parameters</span></span></span> */)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;connection c = connect(&amp;d);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">open the connection</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is destroyed, the connection will be closed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;unique_ptr&lt;connection, decltype(end_connection)*&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;p(&amp;c, end_connection);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use the connection</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">when</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">exits, even if by an exception, the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">connection</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be properly closed</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>) to specify the function pointer type. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(end_connection)</span></tt></code> returns a function type, we must remember to add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> to indicate that we&#8217;re using a pointer to that type (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">250</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.16:</strong> Compilers don&#8217;t always give easy-to-understand error messages if we attempt to copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>. Write a program that contains these errors to see how your compiler diagnoses them.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.17:</strong> Which of the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> declarations are illegal or likely to result in subsequent program error? Explain what the problem is with each one.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ix = 1024, *pi = &amp;ix, *pi2 = new int(2048);<br class="calibre6"/>typedef unique_ptr&lt;int&gt; IntP;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(a) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p0(ix);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(b) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p1(pi);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(c) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p2(pi2);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(d) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p3(&amp;ix);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(e) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p4(new int(2048));</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53">(f) <code class="calibre23"><tt class="calibre23"><span class="calibre24">IntP p5(p2.get());</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.18:</strong> Why doesn&#8217;t <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">release</span></tt></code> member?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3062321" class="calibre37"><span class="calibre5"><a id="filepos3062354"/>12.1.6. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">weak_ptr</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<div class="calibre28"><a id="filepos3062617"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> (<a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3063983">Table 12.5</a>) is a smart pointer that does not control the lifetime of the object to which it points. Instead, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> points to an object that is managed by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Binding a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> does not change the reference count of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>. Once the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> pointing to the object goes away, the object itself will be deleted. That object will be deleted even if there are <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>s pointing to it&#8212;hence the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>, which captures the idea that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> shares its object &#8220;weakly.&#8221;</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3063983"/>Table 12.5. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">weak_ptr</span></span></tt></span></span></tt></code>s</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00093.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">When we create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>, we initialize it from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto p = make_shared&lt;int&gt;(42);<br class="calibre6"/>weak_ptr&lt;int&gt; wp(p);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">wp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">weakly shares with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; use count in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is unchanged</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here both <code class="calibre23"><tt class="calibre23"><span class="calibre24">wp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> point to the same object. Because the sharing is weak, creating <code class="calibre23"><tt class="calibre23"><span class="calibre24">wp</span></tt></code> doesn&#8217;t change the reference count of p; it is possible that the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">wp</span></tt></code> points might be deleted.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the object might no longer exist, we cannot use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> to access its object directly. To access that object, we must call <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code> function checks whether the object to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> points still exists. If so, <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the shared object. As with any other <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, we are guaranteed that the underlying object to which that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points continues to exist at least as long as that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> exists. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (shared_ptr&lt;int&gt; np = wp.lock()) { // <span><span class="calibre45"><span class="calibre16">true if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">np</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not null</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">inside the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">if</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">np</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">shares its object with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we enter the body of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> only if the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code> succeeds. Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code>, it is safe to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">np</span></tt></code> to access that object.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Checked Pointer Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As an illustration of when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> is useful, we&#8217;ll define a companion pointer class for our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class. Our pointer class, which we&#8217;ll name <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>, <a id="filepos3068886"/>will store a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> from which it was initialized. By using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>, we don&#8217;t affect the lifetime of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to which a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> points. However, we can prevent the user from attempting to access a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> that no longer exists.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> will have two data members: <code class="calibre23"><tt class="calibre23"><span class="calibre24">wptr</span></tt></code>, which is either null or points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>, which is the index of the element that this object currently denotes. Like its companion <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class, our pointer class has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> member to verify that it is safe to dereference the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrBlobPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">throws an exception on attempts to access a nonexistent element</span></span></span><br class="calibre6"/>class StrBlobPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlobPtr(): curr(0) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlobPtr(StrBlob &amp;a, size_t sz = 0):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wptr(a.data), curr(sz) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string&amp; deref() const;<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlobPtr&amp; incr();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prefix version</span></span></span><br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">check</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if the check succeeds</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;check(std::size_t, const std::string&amp;) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">store a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">weak_ptr</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">which means the underlying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">might be destroyed</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::size_t curr;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">current position within the array</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The default constructor generates a null <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>. Its constructor initializer list (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">265</a>) explicitly initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> to zero and implicitly initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">wptr</span></tt></code> as a null <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code>. The second constructor takes a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> and an optional index value. This constructor initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">wptr</span></tt></code> to point to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> of the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> object and initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> to the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code>. We use a default argument (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>) to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> to denote the first element by default. As we&#8217;ll see, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> parameter will be used by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is worth noting that we cannot bind a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const StrBlob</span></tt></code> object. This restriction follows from the fact that the constructor takes a reference to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> member of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> differs from the one in <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> because it must check whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to which it points is still around:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;<br class="calibre6"/>StrBlobPtr::check(std::size_t i, const std::string &amp;msg) const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto ret = wptr.lock();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">still around?</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (!ret)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw std::runtime_error("unbound StrBlobPtr");<br class="calibre6"/>&#160;&#160;&#160;&#160;if (i &gt;= ret-&gt;size())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw std::out_of_range(msg);<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret; // <span><span class="calibre45"><span class="calibre16">otherwise, return a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3076977"/>Because a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> does not participate in the reference count of its corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to which this <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> points might have been deleted. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is gone, <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code> will return a null pointer. In this case, any reference to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> will fail, so we throw an exception. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> verifies its given index. If that value is okay, <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> returns the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> it obtained from <code class="calibre23"><tt class="calibre23"><span class="calibre24">lock</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We&#8217;ll learn how to define our own operators in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a>. For now, we&#8217;ve defined functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">deref</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">incr</span></tt></code> to dereference and increment the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>, respectively.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">deref</span></tt></code> member calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> to verify that it is safe to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and that <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> is in range:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::string&amp; StrBlobPtr::deref() const<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto p = check(curr, "dereference past end");<br class="calibre6"/>&#160;&#160;&#160;&#160;return (*p)[curr];&#160;&#160;// (<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*p</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which this object points</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code> succeeds, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to which this <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> points. The expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*p)[curr]</span></tt></code> dereferences that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to get the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and uses the subscript operator to fetch and return the element at <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">incr</span></tt></code> member also calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">check</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">prefix: return a reference to the incremented object</span></span></span><br class="calibre6"/>StrBlobPtr&amp; StrBlobPtr::incr()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">already points past the end of the container, can't increment it</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;check(curr, "increment past end of StrBlobPtr");<br class="calibre6"/>&#160;&#160;&#160;&#160;++curr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance the current state</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Of course, in order to access the <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member, our pointer class will have to be a <code class="calibre23"><tt class="calibre23"><span class="calibre24">friend</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> (&#167; <a href="075-7.3._additional_class_features.html#filepos1906774">7.3.4</a>, p. <a href="075-7.3._additional_class_features.html#filepos1906774">279</a>). We&#8217;ll also give our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operations that return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> pointing to itself:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">forward declaration needed for friend declaration in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrBlob</span></span></tt></span><br class="calibre6"/>class StrBlobPtr;<br class="calibre6"/>class StrBlob {<br class="calibre6"/>&#160;&#160;&#160;&#160;friend class StrBlobPtr;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in &#167; 12.1.1 (p. 456)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrBlobPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the first and one past the last elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlobPtr begin() { return StrBlobPtr(*this); }<br class="calibre6"/>&#160;&#160;&#160;&#160;StrBlobPtr end()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ auto ret = StrBlobPtr(*this, data-&gt;size());<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ret; }<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos3084131"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.1.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.19:</strong> Define your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> and update your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class with the appropriate <code class="calibre23"><tt class="calibre23"><span class="calibre24">friend</span></tt></code> declaration and <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.20:</strong> Write a program that reads an input file a line at a time into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> and uses a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> to print each element in that <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.21:</strong> We could have written <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">deref</span></tt></code> member as follows:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::string&amp; deref() const<br class="calibre6"/>{ return (*check(curr, "dereference past end"))[curr]; }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Which version do you think is better and why?</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a id="filepos3086152"/><strong class="calibre5">Exercise 12.22:</strong> What changes would need to be made to <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> to create a class that can be used with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const StrBlob</span></tt></code>? Define a class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">ConstStrBlobPtr</span></tt></code> that can point to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const StrBlob</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="113-chapter_12._dynamic_memory.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="115-12.2._dynamic_arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
