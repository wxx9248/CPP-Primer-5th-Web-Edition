<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>14.4. Assignment Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="132-14.3._arithmetic_and_relational_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="134-14.5._subscript_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3614210" class="calibre29"><span class="bold">14.4. Assignment Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">13.1.2</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">500</a>, and &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">536</a>), a class can define additional assignment operators that allow other types as the right-hand operand.</p><div class="calibre15">&#160;</div>
<p class="calibre14">As one example, in addition to the copy- and move-assignment operators, the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> class defines a third assignment operator that takes a braced list of elements (&#167; <a href="090-9.2._container_library_overview.html#filepos2239281">9.2.5</a>, p. <a href="090-9.2._container_library_overview.html#filepos2239281">337</a>). We can use this operator as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; v;<br class="calibre6"/>v = {"a", "an", "the"};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can add this operator to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>) as well:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrVec {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;StrVec &amp;operator=(std::initializer_list&lt;std::string&gt;);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as in &#167; 13.5 (p. 526)</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3616357"/>To be consistent with assignment for the built-in types (and with the copy- and move-assignment operators we already defined), our new assignment operator will return a reference to its left-hand operand:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrVec &amp;StrVec::operator=(initializer_list&lt;string&gt; il)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alloc_n_copy</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">allocates space and copies elements from the given range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto data = alloc_n_copy(il.begin(), il.end());<br class="calibre6"/>&#160;&#160;&#160;&#160;free();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">destroy the elements in this object and free the space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;elements = data.first; // <span><span class="calibre45"><span class="calibre16">update data members to point to the new space</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;first_free = cap = data.second;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with the copy- and move-assignment operators, other overloaded assignment operators have to free the existing elements and create new ones. Unlike the copy-and move-assignment operators, this operator does not need to check for self-assignment. The parameter is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list&lt;string&gt;</span></tt></code> (&#167; <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a>, p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>), which means that <code class="calibre23"><tt class="calibre23"><span class="calibre24">il</span></tt></code> cannot be the same object as the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">this</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Assignment operators can be overloaded. Assignment operators, regardless of parameter type, must be defined as member functions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Compound-Assignment Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Compound assignment operators are not required to be members. However, we prefer to define all assignments, including compound assignments, in the class. For consistency with the built-in compound assignment, these operators should return a reference to their left-hand operand. For example, here is the definition of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> compound-assignment operator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">member binary operator: left-hand operand is bound to the implicit</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">this</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">pointer</span></span></span><br class="calibre6"/>//&#160;<span><span class="calibre45"><span class="calibre16">assumes that both objects refer to the same book</span></span></span><br class="calibre6"/>Sales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold += rhs.units_sold;<br class="calibre6"/>&#160;&#160;&#160;&#160;revenue += rhs.revenue;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Assignment operators must, and ordinarily compound-assignment operators should, be defined as members. These operators should return a reference to the left-hand operand.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="132-14.3._arithmetic_and_relational_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="134-14.5._subscript_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
