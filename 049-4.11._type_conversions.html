<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.11. Type Conversions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="048-4.10._comma_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="050-4.12._operator_precedence_table.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1157818" class="calibre29"><span class="bold"><a id="filepos1157851" class="calibre2"/>4.11. Type Conversions</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">In C++ some types are related to each other. When two types are related, we can use an object or value of one type where an operand of the related type is expected. Two types are related if there is a <strong class="calibre5"><a id="filepos1158220" href="052-defined_terms.html#filepos1215444">conversion</a></strong> between them.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, consider the following expression, which initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code> to 6:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival = 3.541 + 3; // <span><span class="calibre45"><span class="calibre16">the compiler might warn about loss of precision</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The operands of the addition are values of two different types: <code class="calibre23"><tt class="calibre23"><span class="calibre24">3.541</span></tt></code> has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">3</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Rather than attempt to add values of the two different types, C++ defines a set of conversions to transform the operands to a common type. These conversions are carried out automatically without programmer intervention&#8212;and sometimes without programmer knowledge. For that reason, they are referred to as <strong class="calibre5"><a id="filepos1159664" href="052-defined_terms.html#filepos1216580">implicit conversions</a></strong>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The implicit conversions among the arithmetic types are defined to preserve precision, if possible. Most often, if an expression has both integral and floatingpoint operands, the integer is converted to floating-point. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">3</span></tt></code> is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, floating-point addition is done, and the result is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The initialization happens next. In an initialization, the type of the object we are initializing dominates. The initializer is converted to the object&#8217;s type. In this case, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> result of the addition is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and used to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>. Converting a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> truncates the <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>&#8217;s value, discarding the decimal portion. In this expression, the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">6</span></tt></code> is assigned to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">When Implicit Conversions Occur</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The compiler automatically converts operands in the following circumstances:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; In most expressions, values of integral types smaller than <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> are first promoted to an appropriate larger integral type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; In conditions, non<code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> expressions are converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; In initializations, the initializer is converted to the type of the variable; in assignments, the right-hand operand is converted to the type of the left-hand.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; In arithmetic and relational expressions with operands of mixed types, the types are converted to a common type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; As we&#8217;ll see in <a href="062-chapter_6._functions.html#filepos1412784">Chapter 6</a>, conversions also happen during function calls.</p></blockquote><div class="calibre15">&#160;</div>
<h4 id="filepos1162796" class="calibre37"><span class="calibre5">4.11.1. The Arithmetic Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The <strong class="calibre5"><a id="filepos1163004" href="052-defined_terms.html#filepos1213585">arithmetic conversions</a></strong>, which we introduced in &#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>), convert one arithmetic type to another. The rules define a hierarchy of type conversions in which operands to an operator are converted to the widest type. For example, if one operand is of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>, then the other operand is converted to type <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code> regardless of what the second type is. More generally, in expressions that mix floating-point and integral values, the integral value is converted to an appropriate floating-point type.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1163817"/>Integral Promotions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <strong class="calibre5"><a id="filepos1163925" href="052-defined_terms.html#filepos1217029">integral promotions</a></strong> convert the small integral types to a larger integral type. The types <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">signed char</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">short</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned short</span></tt></code> are promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> if all possible values of that type fit in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Otherwise, the value is promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>. As we&#8217;ve seen many times, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> promotes to 0 and <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> to 1.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The larger <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> types (<code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">char16_t</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">char32_t</span></tt></code>) are promoted to the smallest type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">long long</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned long long</span></tt></code> in which all possible values of that character type fit.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Operands of Unsigned Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If the operands of an operator have differing types, those operands are ordinarily converted to a common type. If any operand is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> type, the type to which the operands are converted depends on the relative sizes of the integral types on the machine.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As usual, integral promotions happen first. If the resulting type(s) match, no further conversion is needed. If both (possibly promoted) operands have the same signedness, then the operand with the smaller type is converted to the larger type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When the signedness differs and the type of the unsigned operand is the same as or larger than that of the signed operand, the signed operand is converted to unsigned. For example, given an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code> and an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> is converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>. It is worth noting that if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> has a negative value, the result will be converted as described in &#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>), with the same results.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The remaining case is when the signed operand has a larger type than the unsigned operand. In this case, the result is machine dependent. If all values in the unsigned type fit in the larger type, then the unsigned operand is converted to the signed type. If the values don&#8217;t fit, then the signed operand is converted to the unsigned type. For example, if the operands are <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> have the same size, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> will be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code>. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code> type has more bits, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code> will be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">long</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Understanding the Arithmetic Conversions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One way to understand the arithmetic conversions is to study lots of examples:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool &#160;&#160;&#160;&#160;&#160;flag;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cval;<br class="calibre6"/>short&#160;&#160;&#160;&#160;&#160;sval;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned short usval;<br class="calibre6"/>int&#160;&#160;&#160;&#160;&#160;&#160;&#160;ival;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned int&#160;&#160;&#160;uival;<br class="calibre6"/>long&#160;&#160;&#160;&#160;&#160;&#160;lval;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;unsigned long&#160;&#160;ulval;<br class="calibre6"/>float&#160;&#160;&#160;&#160;&#160;fval;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;double&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dval;<br class="calibre6"/>3.14159L + 'a'; //&#160;&#160;<span><span class="calibre45"><span class="calibre16">'a' promoted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, then that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">long double</span></span></tt></span><br class="calibre6"/>dval +&#160;ival;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>dval +&#160;fval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span><br class="calibre6"/>ival =&#160;dval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted (by truncation) to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>flag =&#160;dval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">dval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, then</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flag</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, otherwise</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><br class="calibre6"/>cval +&#160;fval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">promoted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, then that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">float</span></span></tt></span><br class="calibre6"/>sval +&#160;cval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">promoted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/><a id="filepos1173177"/>cval + lval;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cval</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">long</span></span></tt></span><br class="calibre6"/>ival + ulval;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ival</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unsigned long</span></span></tt></span><br class="calibre6"/>usval + ival;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">promotion depends on the size of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unsigned short</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>uival + lval;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">conversion depends on the size of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">unsigned int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">long</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first addition, the character constant lowercase <code class="calibre23"><tt class="calibre23"><span class="calibre24">'a'</span></tt></code> has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>, which is a numeric value (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">32</a>). What that value is depends on the machine&#8217;s character set. On our machine, <code class="calibre23"><tt class="calibre23"><span class="calibre24">'a'</span></tt></code> has the numeric value 97. When we add <code class="calibre23"><tt class="calibre23"><span class="calibre24">'a'</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> value is promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, and then that <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value is converted to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>. The converted value is added to the literal. The other interesting cases are the last two expressions involving unsigned values. The type of the result in these expressions is machine dependent.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.11.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.34:</strong> Given the variable definitions in this section, explain what conversions take place in the following expressions:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">if (fval)</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">dval = fval + ival;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>&#160;<code class="calibre23"><tt class="calibre23"><span class="calibre24">dval + ival * cval;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Remember that you may need to consider the associativity of the operators.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.35:</strong> Given the following definitions,</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char cval;&#160;&#160;&#160;&#160;&#160;int ival;&#160;&#160;&#160;&#160;unsigned int ui;<br class="calibre6"/>float fval;&#160;&#160;&#160;&#160;double dval;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">identify the implicit type conversions, if any, taking place:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">cval = 'a' + 3;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">fval = ui - ival * 1.0;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">dval = ui * fval;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">cval = ival + fval + dval;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1178431" class="calibre37"><span class="calibre5">4.11.2. Other Implicit Conversions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">In addition to the arithmetic conversions, there are several additional kinds of implicit conversions. These include:</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5">Array to Pointer Conversions:</strong> In most expressions, when we use an array, the array is automatically converted to a pointer to the first element in that array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[10];&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int* ip = ia; // <span><span class="calibre45"><span class="calibre16">convert</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a pointer to the first element</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This conversion is not performed when an array is used with <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> or as the operand of the address-of (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">typeid</span></tt></code> (which we&#8217;ll cover in &#167; <a href="178-19.2._runtime_type_identification.html#filepos5170863">19.2.2</a> (p. <a href="178-19.2._runtime_type_identification.html#filepos5170863">826</a>)) operators. The conversion is also omitted when we initialize a reference to an array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>). As we&#8217;ll see in &#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a> (p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>), a similar pointer conversion happens when we use a function type in an expression.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5">Pointer Conversions:</strong> There are several other pointer conversions: A constant integral value of 0 and the literal <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> can be converted to any pointer type; a pointer to any non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type can be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code>, and a pointer to any <a id="filepos1181184"/>type can be converted to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const void*</span></tt></code>. We&#8217;ll see in &#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>) that there is an additional pointer conversion that applies to types related by inheritance.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5">Conversions to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bool:</span></span></tt></span></span></tt></code></strong> There is an automatic conversion from arithmetic or pointer types to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. If the pointer or arithmetic value is zero, the conversion yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">false;</span></tt></code> any other value yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char *cp = get_string();<br class="calibre6"/>if (cp) /* <span><span class="calibre45"><span class="calibre16">...</span></span></span> */&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if the pointer</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not zero</span></span></span><br class="calibre6"/>while (*cp) /* <span><span class="calibre45"><span class="calibre16">...</span></span></span>&#160;&#160;*/ // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not the null character</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><strong class="calibre5">Conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const:</span></span></tt></span></span></tt></code></strong> We can convert a pointer to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type to a pointer to the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type, and similarly for references. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is a type, we can convert a pointer or a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> into a pointer or reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T</span></tt></code>, respectively (&#167; <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, p. <a href="024-2.4._const_qualifier.html#filepos476737">61</a>, and &#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;<br class="calibre6"/>const int &amp;j = i;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">convert a non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const int</span></span></tt></span><br class="calibre6"/>const int *p = &amp;i; // <span><span class="calibre45"><span class="calibre16">convert address of a non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the address of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>int &amp;r = j, *q = p; // <span><span class="calibre45"><span class="calibre16">error: conversion from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not allowed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The reverse conversion&#8212;removing a low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>&#8212;does not exist.</p><div class="calibre15">&#160;</div>
<p class="calibre14"><strong class="calibre5">Conversions Defined by Class Types:</strong> Class types can define conversions that the compiler will apply automatically. The compiler will apply only one class-type conversion at a time. In &#167; <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1990205">295</a>) we&#8217;ll see an example of when multiple conversions might be required, and will be rejected.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Our programs have already used class-type conversions: We use a class-type conversion when we use a C-style character string where a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is expected (&#167; <a href="034-3.5._arrays.html#filepos932486">3.5.5</a>, p. <a href="034-3.5._arrays.html#filepos932486">124</a>) and when we read from an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> in a condition:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s, t = "a value";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">character string literal converted to type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>while (cin &gt;&gt; s)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">while</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">condition converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The condition (<code class="calibre23"><tt class="calibre23"><span class="calibre24">cin &gt;&gt; s</span></tt></code>) reads <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> and yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> as its result. Conditions expect a value of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, but this condition tests a value of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code>. The IO library defines a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. That conversion is used (automatically) to convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. The resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value depends on the state of the stream. If the last read succeeded, then the conversion yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. If the last attempt failed, then the conversion to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos1189032" class="calibre37"><span class="calibre5">4.11.3. Explicit Conversions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes we want to explicitly force an object to be converted to a different type. For example, we might want to use floating-point division in the following code:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i, j;<br class="calibre6"/>double slope = i/j;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To do so, we&#8217;d need a way to explicitly convert <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and/or <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>. We use a <strong class="calibre5"><a id="filepos1189842" href="052-defined_terms.html#filepos1214631">cast</a></strong> to request an explicit conversion.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Although necessary at times, casts are inherently dangerous constructs.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos1190399"/>Named Casts</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A named cast has the following form:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><span class="calibre45"><span class="calibre16">cast-name</span></span></span>&lt;<span><span class="calibre45"><span class="calibre16">type</span></span></span>&gt;(<span><span class="calibre45"><span class="calibre16">expression</span></span></span>);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">type</em> is the target type of the conversion, and <em class="calibre16">expression</em> is the value to be cast. If <em class="calibre16">type</em> is a reference, then the result is an lvalue. The <em class="calibre16">cast-name</em> may be one of <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos1191240" href="052-defined_terms.html#filepos1221854">static_cast</a></span></span></tt></span></span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos1191426" href="052-defined_terms.html#filepos1215811">dynamic_cast</a></span></span></tt></span></span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos1191613" href="052-defined_terms.html#filepos1215050">const_cast</a></span></span></tt></span></span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos1191802" href="052-defined_terms.html#filepos1220350">reinterpret_cast</a></span></span></tt></span></span></tt></code>. We&#8217;ll cover <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code>, which supports the run-time type identification, in &#167; <a href="178-19.2._runtime_type_identification.html#filepos5158705">19.2</a> (p. <a href="178-19.2._runtime_type_identification.html#filepos5158705">825</a>). The <em class="calibre16">cast-name</em> determines what kind of conversion is performed.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">static_cast</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Any well-defined type conversion, other than those involving low-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, can be requested using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code>. For example, we can force our expression to use floating-point division by casting one of the operands to <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">cast used to force floating-point division</span></span></span><br class="calibre6"/>double slope = static_cast&lt;double&gt;(j) / i;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> is often useful when a larger arithmetic type is assigned to a smaller type. The cast informs both the reader of the program and the compiler that we are aware of and are not concerned about the potential loss of precision. Compilers often generate a warning for assignments of a larger arithmetic type to a smaller type. When we do an explicit cast, the warning message is turned off.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> is also useful to perform a conversion that the compiler will not generate automatically. For example, we can use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> to retrieve a pointer value that was stored in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">56</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void* p = &amp;d;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: address of any non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object can be stored in a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">void*</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">void*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">back to the original pointer type</span></span></span><br class="calibre6"/>double *dp = static_cast&lt;double*&gt;(p);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we store a pointer in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">void*</span></tt></code> and then use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> to cast the pointer back to its original type, we are guaranteed that the pointer value is preserved. That is, the result of the cast will be equal to the original address value. However, we must be certain that the type to which we cast the pointer is the actual type of that pointer; if the types do not match, the result is undefined.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const_cast</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> changes only a low-level (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> in its operand:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char *pc;<br class="calibre6"/>char *p = const_cast&lt;char*&gt;(pc); // <span><span class="calibre45"><span class="calibre16">ok: but writing through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is undefined</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Conventionally we say that a cast that converts a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type &#8220;casts away the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.&#8221; Once we have cast away the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> of an object, the compiler will no longer prevent us from writing to that object. If the object was originally not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, using a cast to obtain write access is legal. However, using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> in order to write to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object is undefined.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos1198021"/>Only a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> may be used to change the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of an expression. Trying to change whether an expression is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> with any of the other forms of named cast is a compile-time error. Similarly, we cannot use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> to change the type of an expression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char *cp;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static_cast</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can't cast away</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>char *q = static_cast&lt;char*&gt;(cp);<br class="calibre6"/>static_cast&lt;string&gt;(cp); // <span><span class="calibre45"><span class="calibre16">ok: converts string literal to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>const_cast&lt;string&gt;(cp);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const_cast</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">only changes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><span><span class="calibre45"><span class="calibre16">ness</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> is most useful in the context of overloaded functions, which we&#8217;ll describe in &#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a> (p. <a href="066-6.4._overloaded_functions.html#filepos1597234">232</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">reinterpret_cast</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code> generally performs a low-level reinterpretation of the bit pattern of its operands. As an example, given the following cast</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *ip;<br class="calibre6"/>char *pc = reinterpret_cast&lt;char*&gt;(ip);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">we must never forget that the actual object addressed by <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, not a character. Any use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> that assumes it&#8217;s an ordinary character pointer is likely to fail at run time. For example:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string str(pc);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">is likely to result in bizarre run-time behavior.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">str</span></tt></code> is a good example of why <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code> is dangerous. The problem is that types are changed, yet there are no warnings or errors from the compiler. When we initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> with the address of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, there is no error or warning from the compiler because we explicitly said the conversion was okay. Any subsequent use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> will assume that the value it holds is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code>. The compiler has no way of knowing that it actually holds a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Thus, the initialization of <code class="calibre23"><tt class="calibre23"><span class="calibre24">str</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> is absolutely correct&#8212;albeit in this case meaningless or worse! Tracking down the cause of this sort of problem can prove extremely difficult, especially if the cast of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ip</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> occurs in a file separate from the one in which <code class="calibre23"><tt class="calibre23"><span class="calibre24">pc</span></tt></code> is used to initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code> is inherently machine dependent. Safely using <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code> requires completely understanding the types involved as well as the details of how the compiler implements the cast.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Old-Style Casts</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In early versions of C++, an explicit cast took one of the following two forms:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><span class="calibre45"><span class="calibre16">type</span></span></span> (<span><span class="calibre45"><span class="calibre16">expr</span></span></span>); // <span><span class="calibre45"><span class="calibre16">function-style cast notation</span></span></span><br class="calibre6"/>(<span><span class="calibre45"><span class="calibre16">type</span></span></span>) <span><span class="calibre45"><span class="calibre16">expr</span></span></span>; // <span><span class="calibre45"><span class="calibre16">C-language-style cast notation</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos1205128"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Avoid Casts</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Casts interfere with normal type checking (&#167; <a href="022-2.2._variables.html#filepos368323">2.2.2</a>, p. <a href="022-2.2._variables.html#filepos368323">46</a>). As a result, we strongly recommend that programmers avoid casts. This advice is particularly applicable to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code>s. Such casts are always hazardous. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> can be useful in the context of overloaded functions, which we&#8217;ll cover in &#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a> (p. <a href="066-6.4._overloaded_functions.html#filepos1597234">232</a>). Other uses of <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> often indicate a design flaw. The other casts, <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">dynamic_cast</span></tt></code>, should be needed infrequently. Every time you write a cast, you should think hard about whether you can achieve the same result in a different way. If the cast is unavoidable, errors can be mitigated by limiting the scope in which the cast value is used and by documenting all assumptions about the types involved.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Depending on the types involved, an old-style cast has the same behavior as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code>, or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code>. When we use an old-style cast where a <code class="calibre23"><tt class="calibre23"><span class="calibre24">static_cast</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code> would be legal, the old-style cast does the same conversion as the respective named cast. If neither cast is legal, then an old-style cast performs a <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code>. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char *pc = (char*) ip; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">has the same effect as using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">reinterpret_cast</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Old-style casts are less visible than are named casts. Because they are easily overlooked, it is more difficult to track down a rogue cast.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.11.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.36:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> write the expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> *= <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> so that it does integral, rather than floating-point, multiplication.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.37:</strong> Rewrite each of the following old-style casts to use a named cast:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i;&#160;&#160;double d;&#160;&#160;const string *ps;&#160;&#160;char *pc;&#160;&#160;void *pv;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">pv = (void*)ps;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">i = int(*pc);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">pv = &amp;d;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">pc = (char*) pv;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.38:</strong> Explain the following expression:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">double slope = static_cast&lt;double&gt;(j/i);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="048-4.10._comma_operator.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="050-4.12._operator_precedence_table.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
