<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>6.4. Overloaded Functions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="065-6.3._return_types_and_the_return_statement.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="067-6.5._features_for_specialized_uses.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1597234" class="calibre29"><span class="bold">6.4. Overloaded Functions</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><a id="filepos1597343"/><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Functions that have the same name but different parameter lists and that appear in the same scope are <strong class="calibre5"><a id="filepos1597540" href="071-defined_terms.html#filepos1737613">overloaded</a></strong>. For example, in &#167; <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a> (p. <a href="064-6.2._argument_passing.html#filepos1499104">214</a>) we defined several functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void print(const char *cp);<br class="calibre6"/>void print(const int *beg, const int *end);<br class="calibre6"/>void print(const int ia[], size_t size);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1598275"/>These functions perform the same general action but apply to different parameter types. When we call these functions, the compiler can deduce which function we want based on the argument type we pass:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int j[2] = {0,1};<br class="calibre6"/>print("Hello World");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const char*)</span></span></tt></span><br class="calibre6"/>print(j, end(j) - begin(j)); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const int*, size_t)</span></span></tt></span><br class="calibre6"/>print(begin(j), end(j));&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const int*, const int*</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Function overloading eliminates the need to invent&#8212;and remember&#8212;names that exist only to help the compiler figure out which function to call.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function may <em class="calibre16">not</em> be overloaded.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Defining Overloaded Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Consider a database application with several functions to find a record based on name, phone number, account number, and so on. Function overloading lets us define a collection of functions, each named <code class="calibre23"><tt class="calibre23"><span class="calibre24">lookup</span></tt></code>, that differ in terms of how they do the search. We can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">lookup</span></tt></code> passing a value of any of several types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Record lookup(const Account&amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">find by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span><br class="calibre6"/>Record lookup(const Phone&amp;);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">find by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Phone</span></span></tt></span><br class="calibre6"/>Record lookup(const Name&amp;);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">find by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Name</span></span></tt></span><br class="calibre6"/><br class="calibre6"/>Account acct;<br class="calibre6"/>Phone phone;<br class="calibre6"/>Record r1 = lookup(acct);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">call version that takes an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span><br class="calibre6"/>Record r2 = lookup(phone); // <span><span class="calibre45"><span class="calibre16">call version that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Phone</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, all three functions share the same name, yet they are three distinct functions. The compiler uses the argument type(s) to figure out which function to call.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Overloaded functions must differ in the number or the type(s) of their parameters. Each of the functions above takes a single parameter, but the parameters have different types.</p><div class="calibre22">&#160;</div>
<p class="calibre25">It is an error for two functions to differ only in terms of their return types. If the parameter lists of two functions match but the return types differ, then the second declaration is an error:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Record lookup(const Account&amp;);<br class="calibre6"/>bool lookup(const Account&amp;);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: only the return type is different</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Determining Whether Two Parameter Types Differ</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Two parameter lists can be identical, even if they don&#8217;t look the same:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">each pair declares the same function</span></span></span><br class="calibre6"/>Record lookup(const Account &amp;acct);<br class="calibre6"/>Record lookup(const Account&amp;); // <span><span class="calibre45"><span class="calibre16">parameter names are ignored</span></span></span><br class="calibre6"/><br class="calibre6"/>typedef Phone Telno;<br class="calibre6"/>Record lookup(const Phone&amp;);<br class="calibre6"/>Record lookup(const Telno&amp;); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Telno</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Phone</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are the same type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1604555"/>In the first pair, the first declaration names its parameter. Parameter names are only a documentation aid. They do not change the parameter list.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In the second pair, it looks like the types are different, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">Telno</span></tt></code> is not a new type; it is a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Phone</span></tt></code>. A type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) provides an alternative name for an existing type; it does not create a new type. Therefore, two parameters that differ only in that one uses an alias and the other uses the type to which the alias corresponds are not different.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Overloading and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const</span></span></tt></span></span></tt></code> Parameters</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">As we saw in &#167; <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">212</a>), top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) has no effect on the objects that can be passed to the function. A parameter that has a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> is indistinguishable from one without a top-level <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Record lookup(Phone);<br class="calibre6"/>Record lookup(const Phone);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">redeclares</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Record lookup(Phone)</span></span></tt></span><br class="calibre6"/><br class="calibre6"/>Record lookup(Phone*);<br class="calibre6"/>Record lookup(Phone* const);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">redeclares</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Record lookup(Phone*</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In these declarations, the second declaration declares the same function as the first.</p><div class="calibre15">&#160;</div>
<p class="calibre25">On the other hand, we can overload based on whether the parameter is a reference (or pointer) to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of a given type; such <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>s are low-level:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">functions taking</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and non</span></span></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">references or pointers have different parameters</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">declarations for four independent, overloaded functions</span></span></span><br class="calibre6"/>Record lookup(Account&amp;);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function that takes a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span><br class="calibre6"/>Record lookup(const Account&amp;); // <span><span class="calibre45"><span class="calibre16">new function that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">reference</span></span></span><br class="calibre6"/><br class="calibre6"/>Record lookup(Account*);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">new function, takes a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Account</span></span></tt></span><br class="calibre6"/>Record lookup(const Account*); // <span><span class="calibre45"><span class="calibre16">new function, takes a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In these cases, the compiler can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>ness of the argument to distinguish which function to call. Because there is no conversion (&#167; <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>) <em class="calibre16">from</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we can pass a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object (or a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>) only to the version with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> parameter. Because there is a conversion <em class="calibre16">to</em>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we can call either function on a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object or a pointer to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. However, as we&#8217;ll see in &#167; <a href="068-6.6._function_matching.html#filepos1689576">6.6.1</a> (p. <a href="068-6.6._function_matching.html#filepos1689576">246</a>), the compiler will prefer the non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> versions when we pass a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object or pointer to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">const_cast</span></span></tt></span></span></tt></code> and Overloading</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a> (p. <a href="049-4.11._type_conversions.html#filepos1189032">163</a>) we noted that <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code>s are most useful in the context of overloaded functions. As one example, recall our <code class="calibre23"><tt class="calibre23"><span class="calibre24">shorterString</span></tt></code> function from &#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a> (p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">return a reference to the shorter of two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>const string &amp;shorterString(const string &amp;s1, const string &amp;s2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return s1.size() &lt;= s2.size() ? s1 : s2;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos1612288"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: When Not to Overload a Function Name</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Although overloading lets us avoid having to invent (and remember) names for common operations, we should only overload operations that actually do similar things. There are some cases where providing different function names adds information that makes the program easier to understand. Consider a set of functions that move the cursor on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Screen</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen&amp; moveHome();<br class="calibre6"/>Screen&amp; moveAbs(int, int);<br class="calibre6"/>Screen&amp; moveRel(int, int, string direction);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It might at first seem better to overload this set of functions under the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">move</span></tt></code>:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Screen&amp; move();<br class="calibre6"/>Screen&amp; move(int, int);<br class="calibre6"/>Screen&amp; move(int, int, string direction);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">However, by overloading these functions, we&#8217;ve lost information that was inherent in the function names. Although cursor movement is a general operation shared by all these functions, the specific nature of that movement is unique to each of these functions. <code class="calibre23"><tt class="calibre23"><span class="calibre24">moveHome</span></tt></code>, for example, represents a special instance of cursor movement. Whether to overload these functions depends on which of these two calls is easier to understand:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">which is easier to understand?</span></span></span><br class="calibre6"/>myScreen.moveHome(); // <span><span class="calibre45"><span class="calibre16">we think this one!</span></span></span><br class="calibre6"/>myScreen.move();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">This function takes and returns references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>. We can call the function on a pair of non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code> arguments, but we&#8217;ll get a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code> as the result. We might want to have a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shorterString</span></tt></code> that, when given non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> arguments, would yield a plain reference. We can write this version of our function using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_cast</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string &amp;shorterString(string &amp;s1, string &amp;s2)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const_cast&lt;const string&amp;&gt;(s2));<br class="calibre6"/>&#160;&#160;&#160;&#160;return const_cast&lt;string&amp;&gt;(r);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">shorterString</span></tt></code> by casting its arguments to references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. That function returns a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>, which we know is bound to one of our original, non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> arguments. Therefore, we know it is safe to cast that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> back to a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;</span></tt></code> in the return.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Calling an Overloaded Function</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Once we have defined a set of overloaded functions, we need to be able to call them with appropriate arguments. <strong class="calibre5"><a id="filepos1617783" href="071-defined_terms.html#filepos1733248">Function matching</a></strong> (also known as <strong class="calibre5"><a id="filepos1617877" href="071-defined_terms.html#filepos1737409">overload resolution</a></strong>) is the process by which a particular function call is associated with <a id="filepos1618021"/>a specific function from a set of overloaded functions. The compiler determines which function to call by comparing the arguments in the call with the parameters offered by each function in the overload set.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In many&#8212;probably most&#8212;cases, it is straightforward for a programmer to determine whether a particular call is legal and, if so, which function will be called. Often the functions in the overload set differ in terms of the number of arguments, or the types of the arguments are unrelated. In such cases, it is easy to determine which function is called. Determining which function is called when the overloaded functions have the same number of parameters and those parameters are related by conversions (&#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a>, p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>) can be less obvious. We&#8217;ll look at how the compiler resolves calls involving conversions in &#167; <a href="068-6.6._function_matching.html#filepos1674559">6.6</a> (p. <a href="068-6.6._function_matching.html#filepos1674559">242</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">For now, what&#8217;s important to realize is that for any given call to an overloaded function, there are three possible outcomes:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The compiler finds exactly one function that is a <strong class="calibre5"><a id="filepos1619408" href="071-defined_terms.html#filepos1730778">best match</a></strong> for the actual arguments and generates code to call that function.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There is no function with parameters that match the arguments in the call, in which case the compiler issues an error message that there was <strong class="calibre5"><a id="filepos1619786" href="071-defined_terms.html#filepos1735724">no match</a></strong>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There is more than one function that matches and none of the matches is clearly best. This case is also an error; it is an <strong class="calibre5"><a id="filepos1620078" href="071-defined_terms.html#filepos1729302">ambiguous call</a></strong>.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.39:</strong> Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int calc(int, int);<br class="calibre6"/>int calc(const int, const int);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int get();<br class="calibre6"/>double get();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int *reset(int *);<br class="calibre6"/>double *reset(double *);</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos1621309" class="calibre37"><span class="calibre5">6.4.1. Overloading and Scope</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily, it is a bad idea to declare a function locally. However, to explain how scope interacts with overloading, we will violate this practice and use local function declarations.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Programmers new to C++ are often confused about the interaction between scope and overloading. However, overloading has no special properties with respect to scope: As usual, if we declare a name in an inner scope, that name <em class="calibre16">hides</em> uses of that name declared in an outer scope. Names do not overload across scopes:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos1622408"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string read();<br class="calibre6"/>void print(const string &amp;);<br class="calibre6"/>void print(double);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">overloads the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function</span></span></span><br class="calibre6"/>void fooBar(int ival)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;bool read = false; // <span><span class="calibre45"><span class="calibre16">new scope: hides the outer declaration of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">read</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;string s = read(); // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">read</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><span class="calibre45"><span class="calibre16">a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">variable, not a function</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">bad practice: usually it's a bad idea to declare functions at local scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void print(int);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">new scope: hides previous instances of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print("Value: "); // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const string &amp;</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is hidden</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(ival);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is visible</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(3.14);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(int</span></span></tt></span>)<span><span class="calibre45"><span class="calibre16">;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(double</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is hidden</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Most readers will not be surprised that the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">read</span></tt></code> is in error. When the compiler processes the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">read</span></tt></code>, it finds the local definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">read</span></tt></code>. That name is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> variable, and we cannot call a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. Hence, the call is illegal.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Exactly the same process is used to resolve the calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. The declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(int)</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">fooBar</span></tt></code> hides the earlier declarations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. It is as if there is only one <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function available: the one that takes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameter.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>, the compiler first looks for a declaration of that name. It finds the local declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> that takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Once a name is found, the compiler ignores uses of that name in any outer scope. Instead, the compiler assumes that the declaration it found is the one for the name we are using. What remains is to see if the use of the name is valid.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In C++, name lookup happens before type checking.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The first call passes a string literal, but the only declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> that is in scope has a parameter that is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. A string literal cannot be converted to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, so this call is an error. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(const string&amp;)</span></tt></code> function, which would have matched this call, is hidden and is not considered.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> passing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code>, the process is repeated. The compiler finds the local definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(int)</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> argument can be converted to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, so the call is legal.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Had we declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(int)</span></tt></code> in the same scope as the other <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> functions, then it would be another overloaded version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. In that case, these calls would be resolved differently, because the compiler will see all three functions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void print(const string &amp;);<br class="calibre6"/>void print(double); // <span><span class="calibre45"><span class="calibre16">overloads the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">function</span></span></span><br class="calibre6"/>void print(int);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">another overloaded instance</span></span></span><br class="calibre6"/>void fooBar2(int ival)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;print("Value:&#160;"); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(const string &amp;)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(ival);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(int)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;print(3.14);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(double)</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="065-6.3._return_types_and_the_return_statement.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="067-6.5._features_for_specialized_uses.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
