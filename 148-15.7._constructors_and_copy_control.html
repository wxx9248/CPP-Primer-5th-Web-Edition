<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.7. Constructors and Copy Control</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="147-15.6._class_scope_under_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="149-15.8._containers_and_inheritance.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3973987" class="calibre29"><span class="bold"><a id="filepos3974020" class="calibre2"/>15.7. Constructors and Copy Control</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">Like any other class, a class in an inheritance hierarchy controls what happens when objects of its type are created, copied, moved, assigned, or destroyed. As for any other class, if a class (base or derived) does not itself define one of the copy-control operations, the compiler will synthesize that operation. Also, as usual, the synthesized version of any of these members might be a deleted function.</p><div class="calibre15">&#160;</div>
<h4 id="filepos3974566" class="calibre37"><span class="calibre5">15.7.1. Virtual Destructors</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The primary direct impact that inheritance has on copy control for a base class is that a base class generally should define a virtual destructor (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">15.2.1</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">594</a>). The destructor needs to be virtual to allow objects in the inheritance hierarchy to be dynamically allocated.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Recall that the destructor is run when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to a dynamically allocated object (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">13.1.3</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">502</a>). If that pointer points to a type in an inheritance hierarchy, it is possible that the static type of the pointer might differ from the dynamic type of the object being destroyed (&#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>). For example, if we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote*</span></tt></code>, that pointer might point at a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object. If the pointer points at a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>, the compiler has to know that it should run the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> destructor. As with any other function, we arrange to run the proper destructor by defining the destructor as virtual in the base class:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">virtual destructor needed if a base pointer pointing to a derived object is deleted</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual ~Quote() = default; // <span><span class="calibre45"><span class="calibre16">dynamic binding for the destructor</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Like any other virtual, the virtual nature of the destructor is inherited. Thus, classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> have virtual destructors, whether they use the synthesized destructor or define their own version. So long as the base class destructor is virtual, when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to base, the correct destructor will be run:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Quote *itemP = new Quote;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">same static and dynamic type</span></span></span><br class="calibre6"/>delete itemP;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">destructor for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">called</span></span></span><br class="calibre6"/>itemP = new Bulk_quote;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">static and dynamic types differ</span></span></span><br class="calibre6"/>delete itemP;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">destructor for</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">called</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Executing <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on a pointer to base that points to a derived object has undefined behavior if the base&#8217;s destructor is not virtual.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Destructors for base classes are an important exception to the rule of thumb that if a class needs a destructor, it also needs copy and assignment (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>). A base class almost always needs a destructor, so that it can make the destructor virtual. If a base class has an empty destructor in order to make it virtual, then the fact that the class has a destructor does not indicate that the assignment operator or copy constructor is also needed.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3979938"/>Virtual Destructors Turn Off Synthesized Move</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that a base class needs a virtual destructor has an important indirect impact on the definition of base and derived classes: If a class defines a destructor&#8212;even if it uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> to use the synthesized version&#8212;the compiler will not synthesize a move operation for that class (&#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">537</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.7.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.24:</strong> What kinds of classes need a virtual destructor? What operations must a virtual destructor perform?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3980968" class="calibre37"><span class="calibre5">15.7.2. Synthesized Copy Control and Inheritance</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The synthesized copy-control members in a base or a derived class execute like any other synthesized constructor, assignment operator, or destructor: They memberwise initialize, assign, or destroy the members of the class itself. In addition, these synthesized members initialize, assign, or destroy the direct base part of an object by using the corresponding operation from the base class. For example,</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The synthesized <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> default constructor runs the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_Quote</span></tt></code> default constructor, which in turn runs the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> default constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> default constructor default initializes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> member to the empty string and uses the in-class initializer to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">price</span></tt></code> to zero.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> constructor finishes, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_Quote</span></tt></code> constructor continues, which uses the in-class initializers to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">qty</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> constructor finishes, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> constructor continues but has no other work to do.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Similarly, the synthesized <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> copy constructor uses the (synthesized) <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code> copy constructor, which uses the (synthesized) <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> copy constructor. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> copy constructor copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bookNo</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">price</span></tt></code> members; and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_Quote</span></tt></code> copy constructor copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">qty</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">discount</span></tt></code> members.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that it doesn&#8217;t matter whether the base-class member is itself synthesized (as is the case in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> hierarchy) or has a an user-provided definition. All that matters is that the corresponding member is accessible (&#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">611</a>) and that it is not a deleted function.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Each of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> classes use the synthesized destructor. The derived classes do so implicitly, whereas the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class does so explicitly by defining its (virtual) destructor as <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code>. The synthesized destructor is (as usual) empty and its implicit destruction part destroys the members of the class (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">13.1.3</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">501</a>). In addition to destroying its own members, the destruction phase of a destructor in a derived class also destroys its direct base. That destructor in turn invokes the destructor for its own direct base, if any. And, so on up to the root of the hierarchy.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos3985641"/>As we&#8217;ve seen, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> does not have synthesized move operations because it defines a destructor. The (synthesized) copy operations will be used whenever we move a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> object (&#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">540</a>). As we&#8217;re about to see, the fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> does not have move operations means that its derived classes don&#8217;t either.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Base Classes and Deleted Copy Control in the Derived</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos3986390"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">The synthesized default constructor, or any of the copy-control members of either a base or a derived class, may be defined as deleted for the same reasons as in any other class (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>, and &#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">537</a>). In addition, the way in which a base class is defined can cause a derived-class member to be defined as deleted:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the default constructor, copy constructor, copy-assignment operator, or destructor in the base class is deleted or inaccessible (&#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">612</a>), then the corresponding member in the derived class is defined as deleted, because the compiler can&#8217;t use the base-class member to construct, assign, or destroy the base-class part of the object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the base class has an inaccessible or deleted destructor, then the synthesized default and copy constructors in the derived classes are defined as deleted, because there is no way to destroy the base part of the derived object.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; As usual, the compiler will not synthesize a deleted move operation. If we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">= default</span></tt></code> to request a move operation, it will be a deleted function in the derived if the corresponding operation in the base is deleted or inaccessible, because the base class part cannot be moved. The move constructor will also be deleted if the base class destructor is deleted or inaccessible.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">As an example, this base class, <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class B {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;B();<br class="calibre6"/>&#160;&#160;&#160;&#160;B(const B&amp;) = delete;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members, not including a move constructor</span></span></span><br class="calibre6"/>};<br class="calibre6"/>class D : public B {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no constructors</span></span></span><br class="calibre6"/>};<br class="calibre6"/>D d;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s synthesized default constructor uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s default constructor</span></span></span><br class="calibre6"/>D d2(d); // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s synthesized copy constructor is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">deleted</span></span></tt></span><br class="calibre6"/>D d3(std::move(d)); // <span><span class="calibre45"><span class="calibre16">error: implicitly uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s deleted copy constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">has an accessible default constructor and an explicitly deleted copy constructor. Because the copy constructor is defined, the compiler will not synthesize a move constructor for class <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> (&#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">537</a>). As a result, we can neither move nor copy objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>. If a class derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> wanted to allow its objects to be copied or moved, that derived class would have to define its own versions of these constructors. Of course, that class would have to decide how to copy or move the members in it base-class part. In practice, if a base class does not have a default, copy, or move constructor, then its derived classes usually don&#8217;t either.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a/>Move Operations and Inheritance</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, most base classes define a virtual destructor. As a result, by default, base classes generally do not get synthesized move operations. Moreover, by default, classes derived from a base class that doesn&#8217;t have move operations don&#8217;t get synthesized move operations either.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because lack of a move operation in a base class suppresses synthesized move for its derived classes, base classes ordinarily should define the move operations if it is sensible to do so. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class can use the synthesized versions. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> must define these members explicitly. Once it defines its move operations, it must also explicitly define the copy versions as well (&#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">539</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;Quote() = default;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">memberwise default initialize</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Quote(const Quote&amp;) = default; // <span><span class="calibre45"><span class="calibre16">memberwise copy</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Quote(Quote&amp;&amp;) = default;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">memberwise copy</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Quote&amp; operator=(const Quote&amp;) = default; // <span><span class="calibre45"><span class="calibre16">copy assign</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;Quote&amp; operator=(Quote&amp;&amp;) = default;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move assign</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual ~Quote() = default;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Now, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> objects will be memberwise copied, moved, assigned, and destroyed. Moreover, classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> will automatically obtain synthesized move operations as well, unless they have members that otherwise preclude move.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.7.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.25:</strong> Why did we define a default constructor for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code>? What effect, if any, would removing that constructor have on the behavior of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3994728" class="calibre37"><span class="calibre5">15.7.3. Derived-Class Copy-Control Members</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we saw in &#167;<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">598</a>), the initialization phase of a derived-class constructor initializes the base-class part(s) of a derived object as well as initializing its own members. As a result, the copy and move constructors for a derived class must copy/move the members of its base part as well as the members in the derived. Similarly, a derived-class assignment operator must assign the members in the base part of the derived object.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Unlike the constructors and assignment operators, the destructor is responsible only for destroying the resources allocated by the derived class. Recall that the members of an object are implicitly destroyed (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">13.1.3</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">502</a>). Similarly, the base-class part of a derived object is destroyed automatically.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos3995950"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When a derived class defines a copy or move operation, that operation is responsible for copying or moving the entire object, including base-class members.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Derived Copy or Move Constructor</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">When we define a copy or move constructor (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">496</a>, and &#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>) for a derived class, we ordinarily use the corresponding base-class constructor to initialize the base part of the object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Base { /* <span><span class="calibre45"><span class="calibre16">...</span></span></span>&#160;&#160;&#160;&#160;*/ } ;<br class="calibre6"/>class D: public Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">by default, the base class default constructor initializes the base part of an object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">to use the copy or move constructor, we must explicitly call that</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">constructor in the constructor initializer list</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;D(const D&amp; d): Base(d)&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the base members</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* <span><span class="calibre45"><span class="calibre16">initializers for members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span> */ { /* ...&#160;&#160;*/ }<br class="calibre6"/>&#160;&#160;&#160;&#160;D(D&amp;&amp; d): Base(std::move(d)) // <span><span class="calibre45"><span class="calibre16">move the base members</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* <span><span class="calibre45"><span class="calibre16">initializers for members of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span> */ { /* ...&#160;&#160;*/ }<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The initializer <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base(d)</span></tt></code> passes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> object to a base-class constructor. Although in principle, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> could have a constructor that has a parameter of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code>, in practice, that is very unlikely. Instead, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base(d)</span></tt></code> will (ordinarily) match the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> copy constructor. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> object, <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code>, will be bound to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base&amp;</span></tt></code> parameter in that constructor. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> copy constructor will copy the base part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> into the object that is being created. Had the initializer for the base class been omitted,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">probably incorrect definition of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">copy constructor</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">base-class part is default initialized, not copied</span></span></span><br class="calibre6"/>D(const D&amp; d) /* <span><span class="calibre45"><span class="calibre16">member initializers, but no base-class initializer</span></span></span>&#160;&#160;&#160;&#160;*/<br class="calibre6"/>&#160;&#160;&#160;&#160;{ /* <span><span class="calibre45"><span class="calibre16">...</span></span></span>&#160;&#160;&#160;*/ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> default constructor would be used to initialize the base part of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> object. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code>&#8217;s constructor copies the derived members from <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code>, this newly constructed object would be oddly configured: Its <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> members would hold default values, while its <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> members would be copies of the data from another object.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">By default, the base-class default constructor initializes the base-class part of a derived object. If we want copy (or move) the base-class part, we must explicitly use the copy (or move) constructor for the base class in the derived&#8217;s constructor initializer list.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Derived-Class Assignment Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like the copy and move constructors, a derived-class assignment operator (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">13.1.2</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">500</a>, and &#167;<a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">536</a>), must assign its base part explicitly:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4002835"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::operator=(const Base&amp;)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not invoked automatically</span></span></span><br class="calibre6"/>D &amp;D::operator=(const D &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;Base::operator=(rhs); // <span><span class="calibre45"><span class="calibre16">assigns the base part</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign the members in the derived class, as usual,</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">handling self-assignment and freeing existing resources as appropriate</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This operator starts by explicitly calling the base-class assignment operator to assign the members of the base part of the derived object. The base-class operator will (presumably) correctly handle self-assignment and, if appropriate, will free the old value in the base part of the left-hand operand and assign the new values from <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code>. Once that operator finishes, we continue doing whatever is needed to assign the members in the derived class.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that a derived constructor or assignment operator can use its corresponding base class operation regardless of whether the base defined its own version of that operator or uses the synthesized version. For example, the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base::operator=</span></tt></code> executes the copy-assignment operator in class <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code>. It is immaterial whether that operator is defined explicitly by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Base</span></tt></code> class or is synthesized by the compiler.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Derived-Class Destructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Recall that the data members of an object are implicitly destroyed after the destructor body completes (&#167;<a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">13.1.3</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3230370">502</a>). Similarly, the base-class parts of an object are also implicitly destroyed. As a result, unlike the constructors and assignment operators, a derived destructor is responsible only for destroying the resources allocated by the derived class:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class D: public Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::~Base</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">invoked automatically</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;~D() { /* <span><span class="calibre45"><span class="calibre16">do what it takes to clean up derived members</span></span></span>&#160;&#160;&#160;*/ }<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Objects are destroyed in the opposite order from which they are constructed: The derived destructor is run first, and then the base-class destructors are invoked, back up through the inheritance hierarchy.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Calls to Virtuals in Constructors and Destructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, the base-class part of a derived object is constructed first. While the base-class constructor is executing, the derived part of the object is uninitialized. Similarly, derived objects are destroyed in reverse order, so that when a base class destructor runs, the derived part has already been destroyed. As a result, while these base-class members are executing, the object is incomplete.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To accommodate this incompleteness, the compiler treats the object as if its type changes during construction or destruction. That is, while an object is being constructed it is treated as if it has the same class as the constructor; calls to virtual <a id="filepos4007500"/>functions will be bound as if the object has the same type as the constructor itself. Similarly, for destructors. This binding applies to virtuals called directly or that are called indirectly from a function that the constructor (or destructor) calls.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To understand this behavior, consider what would happen if the derived-class version of a virtual was called from a base-class constructor. This virtual probably accesses members of the derived object. After all, if the virtual didn&#8217;t need to use members of the derived object, the derived class probably could use the version in its base class. However, those members are uninitialized while a base constructor is running. If such access were allowed, the program would probably crash.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a constructor or destructor calls a virtual, the version that is run is the one corresponding to the type of the constructor or destructor itself.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.7.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.26:</strong> Define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> copy-control members to do the same job as the synthesized versions. Give them and the other constructors print statements that identify which function is running. Write programs using these classes and predict what objects will be created and destroyed. Compare your predictions with the output and continue experimenting until your predictions are reliably correct.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4009689" class="calibre37"><span class="calibre5">15.7.4. Inherited Constructors</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos4009802"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, a derived class can reuse the constructors defined by its direct base class. Although, as we&#8217;ll see, such constructors are not inherited in the normal sense of that term, it is nonetheless common to refer to such constructors as &#8220;inherited.&#8221; For the same reasons that a class may initialize only its direct base class, a class may inherit constructors only from its direct base. A class cannot inherit the default, copy, and move constructors. If the derived class does not directly define these constructors, the compiler synthesizes them as usual.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A derived class inherits its base-class constructors by providing a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration that names its (direct) base class. As an example, we can redefine our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> class (&#167;<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>) to inherit its constructors from <code class="calibre23"><tt class="calibre23"><span class="calibre24">Disc_quote</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Bulk_quote : public Disc_quote {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;using Disc_quote::Disc_quote; // <span><span class="calibre45"><span class="calibre16">inherit</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Disc_quote'</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s constructors</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;double net_price(std::size_t) const;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Ordinarily, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration only makes a name visible in the current scope. When applied to a constructor, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration causes the compiler to generate code. The compiler generates a derived constructor corresponding to each constructor in the base. That is, for each constructor in the base class, the compiler generates a constructor in the derived class that has the same parameter list.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4012384"/>These compiler-generated constructors have the form</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">derived</span></span></tt></span>(<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">parms</span></span></tt></span>) : <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">base</span></span></tt></span>(<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">args</span></span></tt></span>) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">derived</em> is the name of the derived class, <em class="calibre16">base</em> is the name of the base class, <em class="calibre16">parms</em> is the parameter list of the constructor, and <em class="calibre16">args</em> pass the parameters from the derived constructor to the base constructor. In our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> class, the inherited constructor would be equivalent to</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Bulk_quote(const std::string&amp; book, double price,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::size_t qty, double disc):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;Disc_quote(book, price, qty, disc) { }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the derived class has any data members of its own, those members are default initialized (&#167;<a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">266</a>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Characteristics of an Inherited Constructor</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declarations for ordinary members, a constructor <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration does not change the access level of the inherited constructor(s). For example, regardless of where the <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration appears, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> constructor in the base is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">private</span></tt></code> constructor in the derived; similarly for <code class="calibre23"><tt class="calibre23"><span class="calibre24">protected</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">public</span></tt></code> constructors.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Moreover, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">using</span></tt></code> declaration can&#8217;t specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code>. If a constructor in the base is <code class="calibre23"><tt class="calibre23"><span class="calibre24">explicit</span></tt></code> (&#167;<a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>) or <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> (&#167;<a href="077-7.5._constructors_revisited.html#filepos2019288">7.5.6</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2019288">299</a>), the inherited constructor has the same property.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If a base-class constructor has default arguments (&#167;<a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>), those arguments are not inherited. Instead, the derived class gets multiple inherited constructors in which each parameter with a default argument is successively omitted. For example, if the base has a constructor with two parameters, the second of which has a default, the derived class will obtain two constructors: one with both parameters (and no default argument) and a second constructor with a single parameter corresponding to the left-most, non-defaulted parameter in the base class.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If a base class has several constructors, then with two exceptions, the derived class inherits each of the constructors from its base class. The first exception is that a derived class can inherit some constructors and define its own versions of other constructors. If the derived class defines a constructor with the same parameters as a constructor in the base, then that constructor is not inherited. The one defined in the derived class is used in place of the inherited constructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The second exception is that the default, copy, and move constructors are not inherited. These constructors are synthesized using the normal rules. An inherited constructor is not treated as a user-defined constructor. Therefore, a class that contains only inherited constructors will have a synthesized default constructor.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.7.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.27:</strong> Redefine your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> class to inherit its constructors.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="147-15.6._class_scope_under_inheritance.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="149-15.8._containers_and_inheritance.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
