<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>17.4. Random Numbers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="165-17.3._regular_expressions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="167-17.5._the_io_library_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4713529" class="calibre29"><span class="bold"><a id="filepos4713562" class="calibre2"/>17.4. Random Numbers</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><a id="filepos4713641"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Programs often need a source of random numbers. Prior to the new standard, both C and C++ relied on a simple C library function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code>. That function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system-dependent maximum value that is at least 32767.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> function has several problems: Many, if not most, programs need random numbers in a different range from the one produced by <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code>. Some applications require random floating-point numbers. Some programs need numbers that reflect a nonuniform distribution. Programmers often introduce nonrandomness when they try to transform the range, type, or distribution of the numbers generated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The random-number library, defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">random</span></tt></code> header, solves these problems through a set of cooperating classes: <strong class="calibre5">random-number engines</strong> and <strong class="calibre5">random-number distribution classes</strong>. These clases are described in <a href="166-17.4._random_numbers.html#filepos4715502">Table 17.14</a>. An engine generates a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> random numbers. A distribution uses an engine to generate random numbers of a specified type, in a given range, distributed according to a particular probability distribution.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4715502"/>Table 17.14. Random Number Library Components</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00124.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">C++ programs should not use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> function. Instead, they should use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">default_random_engine</span></tt></code> along with an appropriate distribution object.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4716290" class="calibre37"><span class="calibre5">17.4.1. Random-Number Engines and Distribution</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The random-number engines are function-object classes (&#167; <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>) that define a call operator that takes no arguments and returns a random <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> number. We can generate raw random numbers by calling an object of a random-number engine type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">default_random_engine e;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">generates random unsigned integers</span></span></span><br class="calibre6"/>for (size_t i = 0; i &lt; 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">e() "calls" the object to produce the next random number</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; e() &lt;&lt; " ";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">On our system, this program generates:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">16807 282475249 1622650073 984943658 1144108930 470211272 ...</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we defined an object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> that has type <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4718264" href="169-defined_terms.html#filepos4844044">default_random_engine</a></span></span></tt></span></span></tt></code>. Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code>, we call the object <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> to obtain the next random number.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4718634"/>The library defines several random-number engines that differ in terms of their performance and quality of randomness. Each compiler designates one of these engines as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">default_random_engine</span></tt></code> type. This type is intended to be the engine with the most generally useful properties. <a href="166-17.4._random_numbers.html#filepos4719262">Table 17.15</a> lists the engine operations and the engine types defined by the standard are listed in &#167; <a href="190-a.3._random_numbers.html#filepos5515213">A.3.2</a> (p. <a href="190-a.3._random_numbers.html#filepos5515213">884</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4719262"/>Table 17.15. Random Number Engine Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00125.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">For most purposes, the output of an engine is not directly usable, which is why we described them earlier as raw random numbers. The problem is that the numbers usually span a range that differs from the one we need. <em class="calibre16">Correctly</em> transforming the range of a random number is surprisingly hard.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Distribution Types and Engines</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To get a number in a specified range, we use an object of a distribution type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">uniformly distributed from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">9</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inclusive</span></span></span><br class="calibre6"/>uniform_int_distribution&lt;unsigned&gt; u(0,9);<br class="calibre6"/>default_random_engine e;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">generates unsigned random integers</span></span></span><br class="calibre6"/>for (size_t i = 0; i &lt; 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">u</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a source of numbers</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">each call returns a uniformly distributed value in the specified range</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; u(e) &lt;&lt; " ";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code produces output such as</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">0 1 7 4 5 2 0 6 6 9</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> as a <code class="calibre23"><tt class="calibre23"><span class="calibre24">uniform_int_distribution&lt;unsigned&gt;</span></tt></code>. That type generates uniformly distributed <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> values. When we define an object of this type, we can supply the minimum and maximum values we want. In this program, <code class="calibre23"><tt class="calibre23"><span class="calibre24">u(0,9)</span></tt></code> says that we want numbers to be in the range <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">9</span></tt></code>
<em class="calibre16">inclusive.</em> The random number distributions use inclusive ranges so that we can obtain every possible value of the given integral type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like the engine types, the distribution types are also function-object classes. The distribution types define a call operator that takes a random-number engine as its argument. The distribution object uses its engine argument to produce random numbers that the distribution object maps to the specified distribution.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Note that we pass the engine object itself, <code class="calibre23"><tt class="calibre23"><span class="calibre24">u(e)</span></tt></code>. Had we written the call as <code class="calibre23"><tt class="calibre23"><span class="calibre24">u(e())</span></tt></code>, we would have tried to pass the next value generated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code>, which would be a compile-time error. We pass the engine, not the next result of the engine, because some distributions may need to call the engine more than once.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we refer to a <strong class="calibre5">random-number generator</strong>, we mean the combination of a distribution object with an engine.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Comparing Random Engines and the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">rand</span></span></tt></span></span></tt></code> Function</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">For readers familiar with the C library <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> function, it is worth noting that the output of calling a <code class="calibre23"><tt class="calibre23"><span class="calibre24">default_random_engine</span></tt></code> object is similar to the output of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code>. Engines deliver <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> integers in a system-defined range. The range <a id="filepos4724905"/>for <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> is 0 to <code class="calibre23"><tt class="calibre23"><span class="calibre24">RAND_MAX</span></tt></code>. The range for an engine type is returned by calling the <code class="calibre23"><tt class="calibre23"><span class="calibre24">min</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">max</span></tt></code> members on an object of that type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; "min: " &lt;&lt; e.min() &lt;&lt; " max: " &lt;&lt; e.max() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">On our system this program produces the following output:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">min: 1 max: 2147483646</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Engines Generate a Sequence of Numbers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Random number generators have one property that often confuses new users: Even though the numbers that are generated appear to be random, a given generator returns the same sequence of numbers each time it is run. The fact that the sequence is unchanging is very helpful during testing. On the other hand, programs that use random-number generators have to take this fact into account.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As one example, assume we need a function that will generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of 100 random integers uniformly distributed in the range from 0 to 9. We might think we&#8217;d write this function as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">almost surely the wrong way to generate a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of random integers</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">output from this function will be the same 100 numbers on every call!</span></span></span><br class="calibre6"/>vector&lt;unsigned&gt; bad_randVec()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;default_random_engine e;<br class="calibre6"/>&#160;&#160;&#160;&#160;uniform_int_distribution&lt;unsigned&gt; u(0,9);<br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;unsigned&gt; ret;<br class="calibre6"/>&#160;&#160;&#160;&#160;for (size_t i = 0; i &lt; 100; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret.push_back(u(e));<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, this function will return the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> every time it is called:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;unsigned&gt; v1(bad_randVec());<br class="calibre6"/>vector&lt;unsigned&gt; v2(bad_randVec());<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">will print</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">equal</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; ((v1 == v2) ? "equal" : "not equal") &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4728867"/>This code will print <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal</span></tt></code> because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s <code class="calibre23"><tt class="calibre23"><span class="calibre24">v1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">v2</span></tt></code> have the same values.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The right way to write our function is to make the engine and associated distribution objects <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> (&#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of 100 uniformly distributed random numbers</span></span></span><br class="calibre6"/>vector&lt;unsigned&gt; good_randVec()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">because engines and distributions retain state, they usually should be</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">defined as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">static</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">so that new numbers are generated on each call</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;static default_random_engine e;<br class="calibre6"/>&#160;&#160;&#160;&#160;static uniform_int_distribution&lt;unsigned&gt; u(0,9);<br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;unsigned&gt; ret;<br class="calibre6"/>&#160;&#160;&#160;&#160;for (size_t i = 0; i &lt; 100; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret.push_back(u(e));<br class="calibre6"/>&#160;&#160;&#160;&#160;return ret;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">u</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>, they will hold their state across calls to the function. The first call will use the first 100 random numbers from the sequence <code class="calibre23"><tt class="calibre23"><span class="calibre24">u(e)</span></tt></code> generates, the second call will get the next 100, and so on.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A given random-number generator always produces the same sequence of numbers. A function with a local random-number generator should make that generator (both the engine and distribution objects) <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code>. Otherwise, the function will generate the identical sequence on each call.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Seeding a Generator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that a generator returns the same sequence of numbers is helpful during debugging. However, once our program is tested, we often want to cause each run of the program to generate different random results. We do so by providing a <strong class="calibre5"><a id="filepos4732550" href="169-defined_terms.html#filepos4849403">seed</a></strong>. A seed is a value that an engine can use to cause it to start generating numbers at a new point in its sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can seed an engine in one of two ways: We can provide the seed when we create an engine object, or we can call the engine&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">seed</span></tt></code> member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">default_random_engine e1;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the default seed</span></span></span><br class="calibre6"/>default_random_engine e2(2147483646); // <span><span class="calibre45"><span class="calibre16">use the given seed value</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will generate the same sequence because they use the same seed</span></span></span><br class="calibre6"/>default_random_engine e3;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the default seed value</span></span></span><br class="calibre6"/>e3.seed(32767);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">seed</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to set a new seed value</span></span></span><br class="calibre6"/>default_random_engine e4(32767); // <span><span class="calibre45"><span class="calibre16">set the seed value to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">32767</span></span></tt></span><br class="calibre6"/>for (size_t i = 0; i != 100; ++i) {<br class="calibre6"/>&#160;&#160;&#160;&#160;if (e1() == e2())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "unseeded match at iteration: " &lt;&lt; i &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;if (e3() != e4())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; "seeded differs at iteration: " &lt;&lt; i &lt;&lt; endl;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we define four engines. The first two, <code class="calibre23"><tt class="calibre23"><span class="calibre24">e1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">e2</span></tt></code>, have different seeds and <a id="filepos4735331"/><em class="calibre16">should</em> generate different sequences. The second two, <code class="calibre23"><tt class="calibre23"><span class="calibre24">e3</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">e4</span></tt></code>, have the same seed value. These two objects <em class="calibre16">will</em> generate the same sequence.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Picking a good seed, like most things about generating good random numbers, is surprisingly hard. Perhaps the most common approach is to call the system <code class="calibre23"><tt class="calibre23"><span class="calibre24">time</span></tt></code> function. This function, defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ctime</span></tt></code> header, returns the number of seconds since a given epoch. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">time</span></tt></code> function takes a single parameter that is a pointer to a structure into which to write the time. If that pointer is null, the function just returns the time:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">default_random_engine e1(time(0));&#160;&#160;// <span><span class="calibre45"><span class="calibre16">a somewhat random seed</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">time</span></tt></code> returns time as the number of seconds, this seed is useful only for applications that generate the seed at second-level, or longer, intervals.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">time</span></tt></code> as a seed usually doesn&#8217;t work if the program is run repeatedly as part of an automated process; it might wind up with the same seed several times.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 17.4.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.28:</strong> Write a function that generates and returns a uniformly distributed random <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned int</span></tt></code> each time it is called.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.29:</strong> Allow the user to supply a seed as an optional argument to the function you wrote in the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 17.30:</strong> Revise your function again this time to take a minimum and maximum value for the numbers that the function should return.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4738594" class="calibre37"><span class="calibre5">17.4.2. Other Kinds of Distributions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The engines produce <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> numbers, and each number in the engine&#8217;s range has the same likelihood of being generated. Applications often need numbers of different types or distributions. The library handles both these needs by defining different distributions that, when used with an engine, produce the desired results. <a href="166-17.4._random_numbers.html#filepos4739302">Table 17.16</a> (overleaf) lists the operations supported by the distribution types.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos4739302"/>Table 17.16. Distribution Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00126.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Generating Random Real Numbers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Programs often need a source of random floating-point values. In particular, programs frequently need random numbers between zero and one.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The most common, <em class="calibre16">but incorrect</em>, way to obtain a random floating-point from <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> is to divide the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand()</span></tt></code> by <code class="calibre23"><tt class="calibre23"><span class="calibre24">RAND_MAX</span></tt></code>, which is a system-defined upper limit that is the largest random number that <code class="calibre23"><tt class="calibre23"><span class="calibre24">rand</span></tt></code> can return. This technique is incorrect because random integers usually have less precision than floating-point numbers, in which case there are some floating-point values that will never be produced as output.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4740542"/>With the new library facilities, we can easily obtain a floating-point random number. We define an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">uniform_real_distribution</span></tt></code> and let the library handle mapping random integers to random floating-point numbers. As we did for <code class="calibre23"><tt class="calibre23"><span class="calibre24">uniform_int_distribution</span></tt></code>, we specify the minimum and maximum values when we define the object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">default_random_engine e; // <span><span class="calibre45"><span class="calibre16">generates unsigned random integers</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">uniformly distributed from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inclusive</span></span></span><br class="calibre6"/>uniform_real_distribution&lt;double&gt; u(0,1);<br class="calibre6"/>for (size_t i = 0; i &lt; 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; u(e) &lt;&lt; " ";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code is nearly identical to the previous program that generated <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> values. However, because we used a different distribution type, this version generates different results:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">0.131538 0.45865 0.218959 0.678865 0.934693 0.519416 ...</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Distribution&#8217;s Default Result Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">With one exception, which we&#8217;ll cover in &#167; <a href="166-17.4._random_numbers.html#filepos4738594">17.4.2</a> (p. <a href="166-17.4._random_numbers.html#filepos4738594">752</a>), the distribution types are templates that have a single template type parameter that represents the type of the numbers that the distribution generates. These types always generate either a floating-point type or an integral type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each distribution template has a default template argument (&#167; <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">670</a>). The distribution types that generate floating-point values generate <code class="calibre23"><tt class="calibre23"><span class="calibre24">double</span></tt></code> by default. Distributions that generate integral results use <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> as their default. Because the distribution types have only one template parameter, when we want to use the default we must remember to follow the template&#8217;s name with empty angle brackets to signify that we want the default (&#167; <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">671</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">signify we want to use the default result type</span></span></span><br class="calibre6"/>uniform_real_distribution&lt;&gt; u(0,1); // <span><span class="calibre45"><span class="calibre16">generates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">double</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by default</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4744864"/>Generating Numbers That Are Not Uniformly Distributed</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In addition to correctly generating numbers in a specified range, another advantage of the new library is that we can obtain numbers that are nonuniformly distributed. Indeed, the library defines 20 distribution types! These types are listed in &#167; <a href="190-a.3._random_numbers.html#filepos5496561">A.3</a> (p. <a href="190-a.3._random_numbers.html#filepos5496561">882</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll generate a series of normally distributed values and plot the resulting distribution. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">normal_distribution</span></tt></code> generates floating-point numbers, our program will use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">lround</span></tt></code> function from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cmath</span></tt></code> header to round each result to its nearest integer. We&#8217;ll generate 200 numbers centered around a mean of 4 with a standard deviation of 1.5. Because we&#8217;re using a normal distribution, we can expect all but about 1 percent of the generated numbers to be in the range from 0 to 8, inclusive. Our program will count how many values appear that map to the integers in this range:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">default_random_engine e;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">generates random integers</span></span></span><br class="calibre6"/>normal_distribution&lt;&gt; n(4,1.5); // <span><span class="calibre45"><span class="calibre16">mean 4, standard deviation 1.5</span></span></span><br class="calibre6"/>vector&lt;unsigned&gt; vals(9);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">nine elements each 0</span></span></span><br class="calibre6"/>for (size_t i = 0; i != 200; ++i) {<br class="calibre6"/>&#160;&#160;&#160;&#160;unsigned v = lround(n(e));&#160;&#160;// <span><span class="calibre45"><span class="calibre16">round to the nearest integer</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (v &lt; vals.size())&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if this result is in range</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++vals[v];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">count how often each number appears</span></span></span><br class="calibre6"/>}<br class="calibre6"/>for (size_t j = 0; j != vals.size(); ++j)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; j &lt;&lt; ": " &lt;&lt; string(vals[j], '*') &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by defining our random generator objects and a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">vals</span></tt></code>. We&#8217;ll use <code class="calibre23"><tt class="calibre23"><span class="calibre24">vals</span></tt></code> to count how often each number in the range 0 . . . 9 occurs. Unlike most of our programs that use <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, we allocate <code class="calibre23"><tt class="calibre23"><span class="calibre24">vals</span></tt></code> at its desired size. By doing so, we start out with each element initialized to 0.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop, we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">lround(n(e))</span></tt></code> to round the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">n(e)</span></tt></code> to the nearest integer. Having obtained the integer that corresponds to our floating-point random number, we use that number to index our <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of counters. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">n(e)</span></tt></code> can produce a number outside the range 0 to 9, we check that the number we got is in range before using it to index <code class="calibre23"><tt class="calibre23"><span class="calibre24">vals</span></tt></code>. If the number is in range, we increment the associated counter.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When the loop completes, we print the contents of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vals</span></tt></code>, which will generate output such as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">0: ***</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">1: ********</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">2: ********************</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">3: **************************************</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">4: **********************************************************</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">5: ******************************************</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">6: ***********************</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">7: *******</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">8: *</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we print a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> with as many asterisks as the count of the times the current value was returned by our random-number generator. Note that this figure <a id="filepos4750946"/>is not perfectly symmetrical. If it were, that symmetry should give us reason to suspect the quality of our random-number generator.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bernoulli_distribution</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We noted that there was one distribution that does not take a template parameter. That distribution is the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bernoulli_distribution</span></tt></code>, which is an ordinary class, not a template. This distribution always returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> value. It returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> with a given probability. By default that probability is .5.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example of this kind of distribution, we might have a program that plays a game with a user. To play the game, one of the players&#8212;either the user or the program&#8212;has to go first. We could use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">uniform_int_distribution</span></tt></code> object with a range of 0 to 1 to select the first player. Alternatively, we can use a Bernoulli distribution to make this choice. Assuming that we have a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">play</span></tt></code> that plays the game, we might have a loop such as the following to interact with the user:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string resp;<br class="calibre6"/>default_random_engine e;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has state, so it must be outside the loop!</span></span></span><br class="calibre6"/>bernoulli_distribution b; // <span><span class="calibre45"><span class="calibre16">50/50 odds by default</span></span></span><br class="calibre6"/>do {<br class="calibre6"/>&#160;&#160;&#160;&#160;bool first = b(e);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, the program will go first</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; (first ? "We go first"<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: "You get to go first") &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">play the game passing the indicator of who goes first</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; ((play(first)) ? "sorry, you lost"<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: "congrats, you won") &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; "play again? Enter 'yes' or 'no'" &lt;&lt; endl;<br class="calibre6"/>} while (cin &gt;&gt; resp &amp;&amp; resp[0] == 'y');</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">do while</span></tt></code> (&#167; <a href="057-5.4._iterative_statements.html#filepos1343100">5.4.4</a>, p. <a href="057-5.4._iterative_statements.html#filepos1343100">189</a>) to repeatedly prompt the user to play.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because engines return the same sequence of numbers (&#167; <a href="166-17.4._random_numbers.html#filepos4716290">17.4.1</a>, p. <a href="166-17.4._random_numbers.html#filepos4716290">747</a>), it is essential that we declare engines outside of loops. Otherwise, we&#8217;d create a new engine on each iteration and generate the same values on each iteration. Similarly, distributions may retain state and should also be defined outside loops.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">One reason to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bernoulli_distribution</span></tt></code> in this program is that doing so lets us give the program a better chance of going first:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bernoulli_distribution b(.55); // <span><span class="calibre45"><span class="calibre16">give the house a slight edge</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we use this definition for <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, then the program has 55/45 odds of going first.</p><div class="calibre15">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="165-17.3._regular_expressions.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="167-17.5._the_io_library_revisited.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
