<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.5. Increment and Decrement Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="042-4.4._assignment_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="044-4.6._the_member_access_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1087530" class="calibre29"><span class="bold">4.5. Increment and Decrement Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The increment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code>) and decrement (<code class="calibre23"><tt class="calibre23"><span class="calibre24">--</span></tt></code>) operators provide a convenient notational shorthand for adding or subtracting 1 from an object. This notation rises above <a id="filepos1087957"/>mere convenience when we use these operators with iterators, because many iterators do not support arithmetic.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There are two forms of these operators: prefix and postfix. So far, we have used only the prefix form. This form increments (or decrements) its operand and yields the <em class="calibre16">changed</em> object as its result. The postfix operators increment (or decrement) the operand but yield a copy of the original, <em class="calibre16">unchanged</em> value as its result:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, j;<br class="calibre6"/>j = ++i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">= 1,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">= 1: prefix yields the incremented value</span></span></span><br class="calibre6"/>j = i++; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">= 1,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">= 2: postfix yields the unincremented value</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These operators require lvalue operands. The prefix operators return the object itself as an lvalue. The postfix operators return a copy of the object&#8217;s original value as an rvalue.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Use Postfix Operators only When Necessary</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Readers from a C background might be surprised that we use the prefix increment in the programs we&#8217;ve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don&#8217;t need the unincremented value, there&#8217;s no need for the extra work done by the postfix operator.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">For <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and pointers, the compiler can optimize away this extra work. For more complicated iterator types, this extra work potentially might be more costly. By habitually using the prefix versions, we do not have to worry about whether the performance difference matters. Moreover&#8212;and perhaps more importantly&#8212;we can express the intent of our programs more directly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Combining Dereference and Increment in a Single Expression</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">The postfix versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">--</span></tt></code> are used when we want to use the current value of a variable and increment it in a single compound expression.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As one example, we can use postfix increment to write a loop to print the values in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> up to but not including the first negative value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto pbeg = v.begin();<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">print elements up to the first negative value</span></span></span><br class="calibre6"/>while (pbeg != v.end() &amp;&amp; *beg &gt;= 0)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; *pbeg++ &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print the current value and advance</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pbeg</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pbeg++</span></tt></code> is usually confusing to programmers new to both C++ and C. However, because this usage pattern is so common, C++ programmers must understand such expressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The precedence of postfix increment is higher than that of the dereference operator, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pbeg++</span></tt></code> is equivalent to <code class="calibre23"><tt class="calibre23"><span class="calibre24">*(pbeg++)</span></tt></code>. The subexpression <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg++</span></tt></code> increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> and yields a copy of the previous value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> as its result. Accordingly, the operand of <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> is the unincremented value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code>. Thus, the statement prints the element to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> originally pointed and increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos1093977"/>This usage relies on the fact that postfix increment returns a copy of its original, unincremented operand. If it returned the incremented value, we&#8217;d dereference the incremented value, with disastrous results. We&#8217;d skip the first element. Worse, if the sequence had no negative values, we would attempt to dereference one too many elements.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Brevity Can Be a Virtue</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Expressions such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pbeg++</span></tt></code> can be bewildering&#8212;at first. However, it is a useful and widely used idiom. Once the notation is familiar, writing</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; *iter++ &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">is easier and less error-prone than the more verbose equivalent</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; *iter &lt;&lt; endl;<br class="calibre6"/>++iter;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is worthwhile to study examples of such code until their meanings are immediately clear. Most C++ programs use succinct expressions rather than more verbose equivalents. Therefore, C++ programmers must be comfortable with such usages. Moreover, once these expressions are familiar, you will find them less error-prone.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Remember That Operands Can Be Evaluated in Any Order</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Most operators give no guarantee as to the order in which operands will be evaluated (&#167; <a href="039-4.1._fundamentals.html#filepos1019764">4.1.3</a>, p. <a href="039-4.1._fundamentals.html#filepos1019764">137</a>). This lack of guaranteed order often doesn&#8217;t matter. The cases where it does matter are when one subexpression changes the value of an operand that is used in another subexpression. Because the increment and decrement operators change their operands, it is easy to misuse these operators in compound expressions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To illustrate the problem, we&#8217;ll rewrite the loop from &#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a> (p. <a href="033-3.4._introducing_iterators.html#filepos804727">108</a>) that capitalizes the first word in the input. That example used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)<br class="calibre6"/>&#160;&#160;&#160;&#160;*it = toupper(*it); // <span><span class="calibre45"><span class="calibre16">capitalize the current character</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">which allowed us to separate the statement that dereferenced <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> from the one that incremented it. Replacing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> with a seemingly equivalent <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the behavior of the following loop is undefined!</span></span></span><br class="calibre6"/>while (beg != s.end() &amp;&amp; !isspace(*beg))<br class="calibre6"/>&#160;&#160;&#160;&#160;*beg = toupper(*beg++);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: this assignment is undefined</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">results in undefined behavior. The problem is that in the revised version, both the left- and right-hand operands to <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> use <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>
<em class="calibre16">and</em> the right-hand operand changes <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>. The assignment is therefore undefined. The compiler might evaluate this expression as either</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">*beg = toupper(*beg);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">execution if left-hand side is evaluated first</span></span></span><br class="calibre6"/>*(beg + 1) = toupper(*beg);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">execution if right-hand side is evaluated first</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">or it might evaluate it in yet some other way.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos1099695"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.17:</strong> Explain the difference between prefix and postfix increment.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.18:</strong> What would happen if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> loop on page <a href="043-4.5._increment_and_decrement_operators.html#filepos1087957">148</a> that prints the elements from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> used the prefix increment operator?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.19:</strong> Given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr</span></tt></code> points to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>, and that <code class="calibre23"><tt class="calibre23"><span class="calibre24">ival</span></tt></code> is an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, explain the behavior of each of these expressions. Which, if any, are likely to be incorrect? Why? How might each be corrected?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ptr != 0 &amp;&amp; *ptr++</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">ival++ &amp;&amp; ival</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">vec[ival++] &lt;= vec[ival]</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="042-4.4._assignment_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="044-4.6._the_member_access_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
