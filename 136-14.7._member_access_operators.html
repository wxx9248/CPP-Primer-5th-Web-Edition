<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>14.7. Member Access Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="135-14.6._increment_and_decrement_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="137-14.8._functioncall_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3645985" class="calibre29"><span class="bold">14.7. Member Access Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The dereference (<code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>) and arrow (<code class="calibre23"><tt class="calibre23"><span class="calibre24">-&gt;</span></tt></code>) operators are often used in classes that represent iterators and in smart pointer classes (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">12.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">450</a>). We can logically add these operators to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> class as well:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrBlobPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string&amp; operator*() const<br class="calibre6"/>&#160;&#160;&#160;&#160;{ auto p = check(curr, "dereference past end");<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;return (*p)[curr];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">(*p</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which this object points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string* operator-&gt;() const<br class="calibre6"/>&#160;&#160;&#160;&#160;{ // <span><span class="calibre45"><span class="calibre16">delegate the real work to the dereference operator</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;return &amp; this-&gt;operator*();<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">other members as before</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The dereference operator checks that <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> is still in range and, if so, returns a reference to the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>. The arrow operator avoids doing any work of its own by calling the dereference operator and returning the address of the element returned by that operator.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Operator arrow must be a member. The dereference operator is not required to be a member but usually should be a member as well.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">It is worth noting that we&#8217;ve defined these operators as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> members. Unlike the increment and decrment operators, fetching an element doesn&#8217;t change the state of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>. Also note that these operators return a reference or pointer to non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code>. They do so because we know that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> can only be bound to a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const StrBlob</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">12.1.6</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">474</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can use these operators the same way that we&#8217;ve used the corresponding operations on pointers or <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> iterators:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">StrBlob a1 = {"hi", "bye", "now"};<br class="calibre6"/>StrBlobPtr p(a1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inside</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span><br class="calibre6"/>*p = "okay";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assigns to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; p-&gt;size() &lt;&lt; endl;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">4</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, the size of the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; (*p).size() &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p-&gt;size(</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a/>Constraints on the Return from Operator Arrow</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with most of the other operators (although it would be a bad idea to do so), we can define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator*</span></tt></code> to do whatever processing we like. That is, we can define <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator*</span></tt></code> to return a fixed value, say, <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>, or print the contents of the object to which it is applied, or whatever. The same is not true for overloaded arrow. The arrow operator never loses its fundamental meaning of member access. When we overload arrow, we change the object from which arrow fetches the specified member. We cannot change the fact that arrow fetches a member.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">point-&gt;mem</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">point</span></tt></code> must be a pointer to a class object or it must be an object of a class with an overloaded <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator-&gt;</span></tt></code>. Depending on the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">point</span></tt></code>, writing <code class="calibre23"><tt class="calibre23"><span class="calibre24">point-&gt;mem</span></tt></code> is equivalent to</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">(*point).mem;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">point</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a built-in pointer type</span></span></span><br class="calibre6"/>point.operator()-&gt;mem; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">point</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an object of class type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Otherwise the code is in error. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">point-&gt;mem</span></tt></code> executes as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">1.</strong> If <code class="calibre23"><tt class="calibre23"><span class="calibre24">point</span></tt></code> is a pointer, then the built-in arrow operator is applied, which means this expression is a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*point).mem</span></tt></code>. The pointer is dereferenced and the indicated member is fetched from the resulting object. If the type pointed to by <code class="calibre23"><tt class="calibre23"><span class="calibre24">point</span></tt></code> does not have a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code>, then the code is in error.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre47"><strong class="calibre5">2.</strong> If <code class="calibre23"><tt class="calibre23"><span class="calibre24">point</span></tt></code> is an object of a class that defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator-&gt;</span></tt></code>, then the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">point.operator-&gt;()</span></tt></code> is used to fetch <code class="calibre23"><tt class="calibre23"><span class="calibre24">mem</span></tt></code>. If that result is a pointer, then step 1 is executed on that pointer. If the result is an object that itself has an overloaded <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator-&gt;()</span></tt></code>, then this step is repeated on that object. This process continues until either a pointer to an object with the indicated member is returned or some other value is returned, in which case the code is in error.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The overloaded arrow operator <em class="calibre16">must</em> return either a pointer to a class type or an object of a class type that defines its own operator arrow.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.7</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.30:</strong> Add dereference and arrow operators to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> class and to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ConstStrBlobPtr</span></tt></code> class that you defined in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3086152">exercise 12.22</a> from &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">12.1.6</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">476</a>). Note that the operators in <code class="calibre23"><tt class="calibre23"><span class="calibre24">constStrBlobPtr</span></tt></code> must return <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> references because the <code class="calibre23"><tt class="calibre23"><span class="calibre24">data</span></tt></code> member in <code class="calibre23"><tt class="calibre23"><span class="calibre24">constStrBlobPtr</span></tt></code> points to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.31:</strong> Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> class does not define the copy constructor, assignment operator, or a destructor. Why is that okay?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.32:</strong> Define a class that holds a pointer to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code>. Define the overloaded arrow operator for that class.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="135-14.6._increment_and_decrement_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="137-14.8._functioncall_operator.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
