<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>2.2. Variables</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="021-2.1._primitive_builtin_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="023-2.3._compound_types.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos350076" class="calibre29"><span class="bold">2.2. Variables</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A <em class="calibre16"><strong class="calibre5"><a id="filepos350207" href="028-defined_terms.html#filepos630288">variable</a></strong></em> provides us with named storage that our programs can manipulate. Each variable in C++ has a type. The type determines the size and layout of the variable&#8217;s memory, the range of values that can be stored within that memory, and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as &#8220;variables&#8221; or &#8220;objects&#8221; interchangeably.</p><div class="calibre15">&#160;</div>
<h4 id="filepos350704" class="calibre37"><span class="calibre5">2.2.1. Variable Definitions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">A simple variable definition consists of a <strong class="calibre5"><a id="filepos350944" href="028-defined_terms.html#filepos628783">type specifier</a></strong>, followed by a list of one or more variable names separated by commas, and ends with a semicolon. Each name <a id="filepos351120"/>in the list has the type defined by the type specifier. A definition may (optionally) provide an initial value for one or more of the names it defines:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int sum = 0, value, // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum, value</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">units_sold</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold = 0; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">units_sold</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have initial value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>Sales_item item;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_item</span></span></tt></span> (<span><span class="calibre45"><span class="calibre16">see</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&#167; 1.5.1</span></span></tt></span> (<span><span class="calibre45"><span class="calibre16">p. 20</span></span></span>))<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a library type, representing a variable-length sequence of characters</span></span></span><br class="calibre6"/>std::string book("0-201-78345-X"); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">book</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">initialized from string literal</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">book</span></tt></code> uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::string</span></tt></code> library type. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostream</span></tt></code> (&#167; <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">7</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is defined in namespace <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>. We&#8217;ll have more to say about the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> type in <a href="029-chapter_3._strings_vectors_and_arrays.html#filepos633734">Chapter 3</a>. For now, what&#8217;s useful to know is that a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is a type that represents a variable-length sequence of characters. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> library gives us several ways to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> objects. One of these ways is as a copy of a string literal (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>). Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">book</span></tt></code> is initialized to hold the characters <code class="calibre23"><tt class="calibre23"><span class="calibre24">0-201-78345-X</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Terminology: What is an Object?</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">C++ programmers tend to be cavalier in their use of the term <em class="calibre16"><a id="filepos355079" href="028-defined_terms.html#filepos622865">object</a></em>. Most generally, an object is a region of memory that can contain data and has a type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Some use the term <em class="calibre16">object</em> only to refer to variables or values of class types. Others distinguish between named and unnamed objects, using the term <em class="calibre16">variable</em> to refer to named objects. Still others distinguish between objects and values, using the term <em class="calibre16">object</em> for data that can be changed by the program and the term <em class="calibre16">value</em> for data that are read-only.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">In this book, we&#8217;ll follow the more general usage that an object is a region of memory that has a type. We will freely use the term <em class="calibre16">object</em> regardless of whether the object has built-in or class type, is named or unnamed, or can be read or written.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Initializers</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">An object that is <strong class="calibre5"><a id="filepos356298" href="028-defined_terms.html#filepos620056">initialized</a></strong> gets the specified value at the moment it is created. The values used to initialize a variable can be arbitrarily complicated expressions. When a definition defines two or more variables, the name of each object becomes visible immediately. Thus, it is possible to initialize a variable to the value of one defined earlier in the same definition.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok</span></span></span>: <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">price</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is defined and initialized before it is used to initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">discount</span></span></tt></span><br class="calibre6"/>double price = 109.99, discount = price * 0.16;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">applyDiscount</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and use the return value to initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">salePrice</span></span></tt></span><br class="calibre6"/>double salePrice = applyDiscount(price, discount);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Initialization in C++ is a surprisingly complicated topic and one we will return to again and again. Many programmers are confused by the use of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">=</span></tt></code> symbol to initialize a variable. It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. This concept is particularly confusing because in many languages the distinction is irrelevant <a id="filepos358328"/>and can be ignored. Moreover, even in C++ the distinction often doesn&#8217;t matter. Nonetheless, it is a crucial concept and one we will reiterate throughout the text.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object&#8217;s current value and replaces that value with a new one.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">List Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">One way in which initialization is a complicated topic is that the language defines several different forms of initialization. For example, we can use any of the following four different ways to define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> variable named <code class="calibre23"><tt class="calibre23"><span class="calibre24">units_sold</span></tt></code> and initialize it to <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int units_sold = 0;<br class="calibre6"/>int units_sold = {0};<br class="calibre6"/>int units_sold{0};<br class="calibre6"/>int units_sold(0);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The generalized use of curly braces for initialization was introduced as part of the new standard. This form of initialization previously had been allowed only in more restricted ways. For reasons we&#8217;ll learn about in &#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a> (p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>), this form of initialization is referred to as <strong class="calibre5"><a id="filepos360286" href="028-defined_terms.html#filepos620737">list initialization</a></strong>. Braced lists of initializers can now be used whenever we initialize an object and in some cases when we assign a new value to an object.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos360541"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">When used with variables of built-in type, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">long double ld = 3.1415926536;<br class="calibre6"/>int a{ld}, b = {ld}; // <span><span class="calibre45"><span class="calibre16">error: narrowing conversion required</span></span></span><br class="calibre6"/>int c(ld), d = ld;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: but value will be truncated</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The compiler rejects the initializations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> because using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code> to initialize an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> is likely to lose data. At a minimum, the fractional part of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ld</span></tt></code> will be truncated. In addition, the integer part in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ld</span></tt></code> might be too large to fit in an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As presented here, the distinction might seem trivial&#8212;after all, we&#8217;d be unlikely to directly initialize an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">long double</span></tt></code>. However, as we&#8217;ll see in <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a>, such initializations might happen unintentionally. We&#8217;ll say more about these forms of initialization in &#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a> (p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) and &#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a> (p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>).</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Default Initialization</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we define a variable without an initializer, the variable is <strong class="calibre5"><a id="filepos363102" href="028-defined_terms.html#filepos617436">default initialized</a></strong>. Such variables are given the &#8220;default&#8221; value. What that default value is depends on the type of the variable and may also depend on where the variable is defined.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, which we cover in &#167; <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a> (p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>), variables of built-in <a id="filepos363730"/>type defined inside a function are <strong class="calibre5"><a id="filepos363781" href="028-defined_terms.html#filepos629734">uninitialized</a></strong>. The value of an uninitialized variable of built-in type is undefined (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">36</a>). It is an error to copy or otherwise try to access the value of a variable whose value is undefined.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Each class controls how we initialize objects of that class type. In particular, it is up to the class whether we can define objects of that type without an initializer. If we can, the class determines what value the resulting object will have.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Most classes let us define objects without explicit initializers. Such classes supply an appropriate default value for us. For example, as we&#8217;ve just seen, the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class says that if we do not supply an initializer, then the resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is the empty string:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::string empty;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">implicitly initialized to the empty string</span></span></span><br class="calibre6"/>Sales_item item;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">default-initialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_item</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Some classes require that every object be explicitly initialized. The compiler will complain if we try to create an object of such a class with no initializer.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.9:</strong> Explain the following definitions. For those that are illegal, explain what&#8217;s wrong and how to correct it.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">std::cin &gt;&gt; int input_value;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int i = { 3.14 };</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">double salary = wage = 9999.99;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int i = 3.14;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.10:</strong> What are the initial values, if any, of each of the following variables?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::string global_str;<br class="calibre6"/>int global_int;<br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;int local_int;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string local_str;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos368323" class="calibre37"><span class="calibre5">2.2.2. Variable Declarations and Definitions</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">To allow programs to be written in logical parts, C++ supports what is commonly known as <em class="calibre16"><strong class="calibre5"><a id="filepos368630" href="028-defined_terms.html#filepos626576">separate compilation</a></strong></em>. Separate compilation lets us split our programs into several files, each of which can be compiled independently.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we separate a program into multiple files, we need a way to share code across those files. For example, code defined in one file may need to use a variable defined in another file. As a concrete example, consider <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::cout</span></tt></code> and <a id="filepos369182"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">std::cin</span></tt></code>. These are objects defined somewhere in the standard library, yet our programs can use these objects.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Uninitialized Variables Cause Run-Time Problems</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An uninitialized variable has an indeterminate value. Trying to use the value of an uninitialized variable is an error that is often hard to debug. Moreover, the compiler is not required to detect such errors, although most will warn about at least some uses of uninitialized variables.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">What happens when we use an uninitialized variable is undefined. Sometimes, we&#8217;re lucky and our program crashes as soon as we access the object. Once we track down the location of the crash, it is usually easy to see that the variable was not properly initialized. Other times, the program completes but produces erroneous results. Even worse, the results may appear correct on one run of our program but fail on a subsequent run. Moreover, adding code to the program in an unrelated location can cause what we thought was a correct program to start producing incorrect results.</p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">To support separate compilation, C++ distinguishes between declarations and definitions. A <strong class="calibre5"><a id="filepos371408" href="028-defined_terms.html#filepos616618">declaration</a></strong> makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. A <strong class="calibre5"><a id="filepos371606" href="028-defined_terms.html#filepos617899">definition</a></strong> creates the associated entity.</p><div class="calibre22">&#160;</div>
<p class="calibre25">A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To obtain a declaration that is not also a definition, we add the <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> keyword and may not provide an explicit initializer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">extern int i;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declares but does not define</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span><br class="calibre6"/>int j;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">declares and defines</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Any declaration that includes an explicit initializer is a definition. We can provide an initializer on a variable defined as <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code>, but doing so overrides the <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code>. An <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> that has an initializer is a definition:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">extern double pi = 3.1416; // <span><span class="calibre45"><span class="calibre16">definition</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">It is an error to provide an initializer on an <code class="calibre23"><tt class="calibre23"><span class="calibre24">extern</span></tt></code> inside a function.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Variables must be defined exactly once but can be declared many times.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable&#8217;s definition. To use the same variable in multiple files, we must define that variable in one&#8212;and only one&#8212;file. Other files that use that variable must declare&#8212;but not define&#8212;that variable.</p><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos374992"/>We&#8217;ll have more to say about how C++ supports separate compilation in &#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos600691">2.6.3</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos600691">76</a>) and &#167; <a href="063-6.1._function_basics.html#filepos1445824">6.1.3</a> (p. <a href="063-6.1._function_basics.html#filepos1445824">207</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.11:</strong> Explain whether each of the following is a declaration or a definition:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">extern int ix = 1024;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int iy;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">extern int iz;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Static Typing</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">C++ is a <em class="calibre16">statically typed</em> language, which means that types are checked at compile time. The process by which types are checked is referred to as <em class="calibre16"><a id="filepos376660" href="028-defined_terms.html#filepos628449">type checking</a></em>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As we&#8217;ve seen, the type of an object constrains the operations that the object can perform. In C++, the compiler checks whether the operations we write are supported by the types we use. If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As our programs get more complicated, we&#8217;ll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must declare the type of a variable before we can use that variable.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos377641" class="calibre37"><span class="calibre5">2.2.3. Identifiers</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14"><em class="calibre16"><strong class="calibre5"><a id="filepos377773" href="028-defined_terms.html#filepos619194">Identifiers</a></strong></em> in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are distinct:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">defines four different</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">variables</span></span></span><br class="calibre6"/>int somename, someName, SomeName, SOMENAME;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The language reserves a set of names, listed in <a href="022-2.2._variables.html#filepos378992">Tables 2.3</a> and <a href="022-2.2._variables.html#filepos379182">Table 2.4</a>, for its own use. These names may not be used as identifiers.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos378992"/>Table 2.3. C++ Keywords</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00019.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos379182"/>Table 2.4. C++ Alternative Operator Names</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00020.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">The standard also reserves a set of names for use in the standard library. The identifiers we define in our own programs may not contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an uppercase letter. In addition, identifiers defined outside a function may not begin with an underscore.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Conventions for Variable Names</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27"><a id="filepos380109"/>&#8226; An identifier should give some indication of its meaning.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Variable names normally are lowercase&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">index</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">Index</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">INDEX</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_item</span></tt></code>, classes we define usually begin with an uppercase letter.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Identifiers with multiple words should visually distinguish each word, for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">student_loan</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">studentLoan</span></tt></code>, not <code class="calibre23"><tt class="calibre23"><span class="calibre24">studentloan</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Naming conventions are most useful when followed consistently.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.12:</strong> Which, if any, of the following names are invalid?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int double = 3.14;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int _;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int catch-22;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int 1_or_2 = 1;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">double Double = 3.14;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos382972" class="calibre37"><span class="calibre5"><a id="filepos383005"/>2.2.4. Scope of a Name</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">At any particular point in a program, each name that is in use refers to a specific entity&#8212;a variable, function, type, and so on. However, a given name can be reused to refer to different entities at different points in the program.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A <strong class="calibre5"><a id="filepos383477" href="028-defined_terms.html#filepos625473">scope</a></strong> is a part of the program in which a name has a particular meaning. Most scopes in C++ are delimited by curly braces.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The same name can refer to different entities in different scopes. Names are visible from the point where they are declared until the end of the scope in which the declaration appears.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, consider the program from &#167; <a href="014-1.4._flow_of_control.html#filepos180866">1.4.2</a> (p. <a href="014-1.4._flow_of_control.html#filepos180866">13</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">#include &lt;iostream&gt;<br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;int sum = 0;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">sum values from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">through</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">10</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inclusive</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;for (int val = 1; val &lt;= 10; ++val)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += val;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum = sum + val</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; "Sum of 1 to 10 inclusive is "<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; sum &lt;&lt; std::endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program defines three names&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>&#8212;and uses the namespace name <code class="calibre23"><tt class="calibre23"><span class="calibre24">std</span></tt></code>, along with two names from that namespace&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">endl</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> is defined outside any curly braces. The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>&#8212;like most names defined outside a function&#8212;has <strong class="calibre5"><a id="filepos386326" href="028-defined_terms.html#filepos618702">global scope</a></strong>. Once declared, names at the global scope are accessible throughout the program. The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> is defined within the scope of the block that is the body of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function. It is accessible from its point of declaration throughout the rest of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function but not outside of it. The variable <code class="calibre23"><tt class="calibre23"><span class="calibre24">sum</span></tt></code> has <strong class="calibre5">block scope</strong>. The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is defined in the scope of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> statement. It can be used in that statement but not elsewhere in <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Define Variables Where You First Use Them</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is usually a good idea to define an object near the point at which the object is first used. Doing so improves readability by making it easy to find the definition of the variable. More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Nested Scopes</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Scopes can contain other scopes. The contained (or nested) scope is referred to as an <strong class="calibre5"><a id="filepos388224" href="028-defined_terms.html#filepos620324">inner scope</a></strong>, the containing scope is the <strong class="calibre5"><a id="filepos388326" href="028-defined_terms.html#filepos623110">outer scope</a></strong>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Once a name has been declared in a scope, that name can be used by scopes nested inside that scope. Names declared in the outer scope can also be redefined in an inner scope:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos388699"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">#include &lt;iostream&gt;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">Program for illustration purposes only: It is bad style for a function</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">to use a global variable and also define a local variable with the same name</span></span></span><br class="calibre6"/>int reused = 42;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has global scope</span></span></span><br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;int unique = 0; // unique <span><span class="calibre45"><span class="calibre16">has block scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">output #1: uses global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 0</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; reused &lt;&lt; " " &lt;&lt; unique &lt;&lt; std::endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;int reused = 0; // <span><span class="calibre45"><span class="calibre16">new, local object named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">hides global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">output #2: uses local</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0 0</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; reused &lt;&lt; " " &lt;&lt; unique &lt;&lt; std::endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">output #3: explicitly requests the global</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">reused</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 0</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;std::cout &lt;&lt; ::reused &lt;&lt; " " &lt;&lt; unique &lt;&lt; std::endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Output <code class="calibre23"><tt class="calibre23"><span class="calibre24">#</span></tt></code>1 appears before the local definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code>. Therefore, this output statement uses the name <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code> that is defined in the global scope. This statement prints <code class="calibre23"><tt class="calibre23"><span class="calibre24">42 0</span></tt></code>. Output <code class="calibre23"><tt class="calibre23"><span class="calibre24">#</span></tt></code>2 occurs after the local definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code>. The local <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code> is now <strong class="calibre5"><a id="filepos392091" href="028-defined_terms.html#filepos619841">in scope</a></strong>. Thus, this second output statement uses the local object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code> rather than the global one and prints <code class="calibre23"><tt class="calibre23"><span class="calibre24">0 0</span></tt></code>. Output <code class="calibre23"><tt class="calibre23"><span class="calibre24">#</span></tt></code>3 uses the scope operator (&#167; <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">8</a>) to override the default scoping rules. The global scope has no name. Hence, when the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope. Thus, this expression uses the global <code class="calibre23"><tt class="calibre23"><span class="calibre24">reused</span></tt></code> and prints <code class="calibre23"><tt class="calibre23"><span class="calibre24">42 0</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 2.2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.13:</strong> What is the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> in the following program?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 42;<br class="calibre6"/>int main()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;int i = 100;<br class="calibre6"/>&#160;&#160;&#160;&#160;int j = i;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 2.14:</strong> Is the following program legal? If so, what values are printed?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 100, sum = 0;<br class="calibre6"/>for (int i = 0; i != 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;sum += i;<br class="calibre6"/>std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; sum &lt;&lt; std::endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="021-2.1._primitive_builtin_types.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="023-2.3._compound_types.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
