<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>3.4. Introducing Iterators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="032-3.3._library_vector_type.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="034-3.5._arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos802543" class="calibre29"><span class="bold"><a id="filepos802576" class="calibre2"/>3.4. Introducing Iterators</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Although we can use subscripts to access the characters of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or the elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, there is a more general mechanism&#8212;known as <strong class="calibre5"><a id="filepos803020" href="037-defined_terms.html#filepos983924">iterators</a></strong>&#8212;that we can use for the same purpose. As we&#8217;ll see in <a href="081-part_ii_the_cpp_library.html#filepos2066884">Part II</a>, in addition to <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator. Technically speaking, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is not a container type, but <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> supports many of the container operations. As we&#8217;ve seen <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> has a subscript operator. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s, <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s also have iterators.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like pointers (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>), iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We can use an iterator to fetch an element and iterators have operations to move from one element to another. As with pointers, an iterator may be valid or invalid. A valid iterator either denotes an element or denotes a position one past the last element in a container. All other iterator values are invalid.</p><div class="calibre22">&#160;</div>
<h4 id="filepos804727" class="calibre37"><span class="calibre5">3.4.1. Using Iterators</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Unlike pointers, we do not use the address-of operator to obtain an iterator. Instead, types that have iterators have members that return iterators. In particular, these types have members named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos805193" href="037-defined_terms.html#filepos977897">begin</a></span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos805376" href="037-defined_terms.html#filepos982096">end</a></span></span></tt></span></span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> member returns an iterator that denotes the first element (or first character), if there is one:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">the compiler determines the type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">see &#167; 2.5.2 (p. 68)</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denotes the first element and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denotes one past the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v</span></span></tt></span><br class="calibre6"/>auto b = v.begin(), e = v.end(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">b</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have the same type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> is an iterator positioned &#8220;one past the end&#8221; of the associated container (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>). This iterator denotes a nonexistent element &#8220;off the end&#8221; of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> is often referred to as the <strong class="calibre5"><a id="filepos807668" href="037-defined_terms.html#filepos985121">off-the-end iterator</a></strong> or abbreviated as &#8220;the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> iterator.&#8221; If the container is empty, <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> returns the same iterator as the one returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If the container is empty, the iterators returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> are equal&#8212;they are both off-the-end iterators.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">In general, we do not know (or care about) the precise type that an iterator has. In this example, we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to define <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>). As a result, these variables have whatever type is returned by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members, respectively. We&#8217;ll have more to say about those types on page <a href="033-3.4._introducing_iterators.html#filepos815330">108</a>.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Iterator Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Iterators support only a few operations, which are listed in <a href="033-3.4._introducing_iterators.html#filepos810064">Table 3.6</a>. We can compare two valid iterators using <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code>. Iterators are equal if they denote the same element or if they are both off-the-end iterators for the same container. Otherwise, they are unequal.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos810064"/>Table 3.6. Standard Container Iterator Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00027.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos810275"/>As with pointers, we can dereference an iterator to obtain the element denoted by an iterator. Also, like pointers, we may dereference only a valid iterator that denotes an element (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>). Dereferencing an invalid iterator or an off-the-end iterator has undefined behavior.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll rewrite the program from &#167; <a href="031-3.2._library_string_type.html#filepos697807">3.2.3</a> (p. <a href="031-3.2._library_string_type.html#filepos697807">94</a>) that capitalized the first character of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> using an iterator instead of a subscript:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s("some string");<br class="calibre6"/>if (s.begin() != s.end()) { // <span><span class="calibre45"><span class="calibre16">make sure</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not empty</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto it = s.begin();&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denotes the first character in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;*it = toupper(*it);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">make that character uppercase</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As in our original program, we first check that <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> isn&#8217;t empty. In this case, we do so by comparing the iterators returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. Those iterators are equal if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is empty. If they are unequl, there is at least one character in <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> body, we obtain an iterator to the first character by assigning the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>. We dereference that iterator to pass that character to <code class="calibre23"><tt class="calibre23"><span class="calibre24">toupper</span></tt></code>. We also dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> on the left-hand side of the assignment in order to assign the character returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">toupper</span></tt></code> to the first character in <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>. As in our original program, the output of this loop will be:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">Some string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Moving Iterators from One Element to Another</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Iterators use the increment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code>) operator (&#167; <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a>, p. <a href="014-1.4._flow_of_control.html#filepos166704">12</a>) to move from one element to the next. Incrementing an iterator is a logically similar operation to incrementing an integer. In the case of integers, the effect is to &#8220;add <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>&#8221; to the integer&#8217;s value. In the case of iterators, the effect is to &#8220;advance the iterator by one position.&#8221;</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because the iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> does not denote an element, it may not be incremented or dereferenced.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Using the increment operator, we can rewrite our program that changed the case of the first word in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to use iterators instead:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos815330"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">process characters in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">until we run out of characters or we hit a whitespace</span></span></span><br class="calibre6"/>for (auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)<br class="calibre6"/>&#160;&#160;&#160;&#160;*it = toupper(*it); // <span><span class="calibre45"><span class="calibre16">capitalize the current character</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This loop, like the one in &#167; <a href="031-3.2._library_string_type.html#filepos697807">3.2.3</a> (p. <a href="031-3.2._library_string_type.html#filepos697807">94</a>), iterates through the characters in <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>, stopping when we encounter a whitespace character. However, this loop accesses these characters using an iterator, not a subscript.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The loop starts by initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">s.begin</span></tt></code>, meaning that <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> denotes the first character (if any) in <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>. The condition checks whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> has reached the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>. If not, the condition next dereferences <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> to pass the current character to <code class="calibre23"><tt class="calibre23"><span class="calibre24">isspace</span></tt></code> to see whether we&#8217;re done. At the end of each iteration, we execute <code class="calibre23"><tt class="calibre23"><span class="calibre24">++it</span></tt></code> to advance the iterator to access the next character in <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The body of this loop, is the same as the last statement in the previous <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code>. We dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> to pass the current character to <code class="calibre23"><tt class="calibre23"><span class="calibre24">toupper</span></tt></code> and assign the resulting uppercase letter back into the character denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Generic Programming</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Programmers coming to C++ from C or Java might be surprised that we used <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> rather than <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> in our <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loops such as the one above and in the one on page <a href="031-3.2._library_string_type.html#filepos718762">94</a>. C++ programmers use <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">As we&#8217;ve seen, only a few library types, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> operators. Most of those iterators do not have the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. By routinely using iterators and <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code>, we don&#8217;t have to worry about the precise type of container we&#8217;re processing.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Iterator Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as we do not know the precise type of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> member (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>), so too, we generally do not know&#8212;and do not need to know&#8212;the precise type of an iterator. Instead, as with <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code>, the library types that have iterators define types named <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> that represent actual iterator types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;::iterator it; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read and write</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements</span></span></span><br class="calibre6"/>string::iterator it2;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read and write characters in a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt;::const_iterator it3; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read but not write elements</span></span></span><br class="calibre6"/>string::const_iterator it4;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can read but not write characters</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> behaves like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer (&#167; <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>). Like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> pointer, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> may read but not write the element it denotes; an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> can both read and write. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we may use only its <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> type. With a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we can use either <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos823731"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Terminology: Iterators and Iterator Types</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The term iterator is used to refer to three different entities. We might mean the <em class="calibre16">concept</em> of an iterator, or we might refer to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code>
<em class="calibre16">type</em> defined by a container, or we might refer to an <em class="calibre16">object</em> as an iterator.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">What&#8217;s important to understand is that there is a collection of types that are related conceptually. A type is an iterator if it supports a common set of actions. Those actions let us access an element in a container and let us move from one element to another.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Each container class defines a type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator;</span></tt></code> that <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> type supports the actions of an (conceptual) iterator.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">begin</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">end</span></span></tt></span></span></tt></code> Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The type returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> depends on whether the object on which they operator is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. If the object is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator;</span></tt></code> if the object is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, they return <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; v;<br class="calibre6"/>const vector&lt;int&gt; cv;<br class="calibre6"/>auto it1 = v.begin();&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;::iterator</span></span></tt></span><br class="calibre6"/>auto it2 = cv.begin(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;::const_iterator</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Often this default behavior is not what we want. For reasons we&#8217;ll explain in &#167; <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>), it is usually best to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> type (such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code>) when we need to read but do not need to write to an object. To let us ask specifically for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> type, the new standard introduced two new functions named <code class="calibre23"><tt class="calibre23"><span class="calibre24">cbegin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cend</span></tt></code>:</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos827968"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto it3 = v.cbegin(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;::const_iterator</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As do the <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> members, these members return iterators to the first and one past the last element in the container. However, regardless of whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>) is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, they return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Combining Dereference and Member Access</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we dereference an iterator, we get the object that the iterator denotes. If that object has a class type, we may want to access a member of that object. For example, we might have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s and we might need to know whether a given element is empty. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> is an iterator into this <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, we can check whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> denotes is empty as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">(*it).empty()</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For reasons we&#8217;ll cover in &#167; <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a> (p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>), the parentheses in <code class="calibre23"><tt class="calibre23"><span class="calibre24">(*it).empty()</span></tt></code> are necessary. The parentheses say to apply the dereference operator to <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> and to apply the dot operator (&#167; <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>) to the result of dereferencing <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>. Without parentheses, the dot operator would apply to <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>, not to the resulting object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">(*it).empty() // <span><span class="calibre45"><span class="calibre16">dereferences</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and calls the member</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on the resulting object</span></span></span><br class="calibre6"/>*it.empty()&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: attempts to fetch the member named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;<span><span class="calibre45"><span class="calibre16">but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an iterator and has no member named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">empty</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos832595"/>The second expression is interpreted as a request to fetch the <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code> member from the object named <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code>. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> is an iterator and has no member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code>. Hence, the second expression is in error.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To simplify expressions such as this one, the language defines the arrow operator (the <a id="filepos833208" href="037-defined_terms.html#filepos991740"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">-&gt;</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>). The arrow operator combines dereference and member access into a single operation. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">it-&gt;mem</span></tt></code> is a synonym for <code class="calibre23"><tt class="calibre23"><span class="calibre24">(* it).mem</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">For example, assume we have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt;</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> that holds the data from a text file. Each element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is either a sentence or an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representing a paragraph break. If we want to print the contents of the first paragraph from <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>, we&#8217;d write a loop that iterates through <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> until we encounter an element that is empty:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print each line in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">text</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">up to the first blank line</span></span></span><br class="calibre6"/>for (auto it = text.cbegin();<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;it != text.cend() &amp;&amp; !it-&gt;empty(); ++it)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; *it &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by initializing <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> to denote the first element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>. The loop continues until either we process every element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> or we find an element that is empty. So long as there are elements and we haven&#8217;t seen an empty element, we print the current element. It is worth noting that because the loop reads but does not write to the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">cbegin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cend</span></tt></code> to control the iteration.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Some <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">vector</span></span></tt></span></span></tt></code> Operations Invalidate Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="032-3.3._library_vector_type.html#filepos767585">3.3.2</a> (p. <a href="032-3.3._library_vector_type.html#filepos767585">101</a>) we noted that there are implications of the fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s can grow dynamically. We also noted that one such implication is that we cannot add elements to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> inside a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop. Another implication is that any operation, such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>, that changes the size of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> potentially invalidates all iterators into that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. We&#8217;ll explore how iterators become invalid in more detail in &#167; <a href="091-9.3._sequential_container_operations.html#filepos2331099">9.3.6</a> (p. <a href="091-9.3._sequential_container_operations.html#filepos2331099">353</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">For now, it is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.4.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.21:</strong> Redo the first exercise from &#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a> (p. <a href="032-3.3._library_vector_type.html#filepos778112">105</a>) using iterators.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.22:</strong> Revise the loop that printed the first paragraph in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> to instead change the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> that correspond to the first paragraph to all uppercase. After you&#8217;ve updated <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>, print its contents.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.23:</strong> Write a program to create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> with ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> elements. Using an iterator, assign each element a value that is twice its current value. Test your program by printing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos839265" class="calibre37"><span class="calibre5"><a id="filepos839298"/>3.4.2. Iterator Arithmetic</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Incrementing an iterator moves the iterator one element at a time. All the library containers have iterators that support increment. Similarly, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code> to compare two valid iterators (&#167; <a href="033-3.4._introducing_iterators.html#filepos802543">3.4</a>, p. <a href="033-3.4._introducing_iterators.html#filepos802543">106</a>) into any of the library container types.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Iterators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> support additional operations that can move an iterator multiple elements at a time. They also support all the relational operators. These operations, which are often referred to as <strong class="calibre5"><a id="filepos840313" href="037-defined_terms.html#filepos984164">iterator arithmetic</a></strong>, are described in <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a>.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos840512"/>Table 3.7. Operations Supported by <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">vector</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">string</span></span></tt></span></span></tt></code> Iterators</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00028.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Arithmetic Operations on Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can add (or subtract) an integral value and an iterator. Doing so returns an iterator positioned forward (or backward) that many elements. When we add or subtract an integral value and an iterator, the result must denote an element in the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>) or denote one past the end of the associated <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>). As an example, we can compute an iterator to the element nearest the middle of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">compute an iterator to the element closest to the midpoint of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span><br class="calibre6"/>auto mid = vi.begin() + vi.size() / 2;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">vi</span></tt></code> has 20 elements, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">vi.size()/2</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code>. In this case, we&#8217;d set <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">vi.begin() + 10</span></tt></code>. Remembering that subscripts start at 0, this element is the same as <code class="calibre23"><tt class="calibre23"><span class="calibre24">vi[10]</span></tt></code>, the element ten past the first.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In addition to comparing two iterators for equality, we can compare <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> iterators using the relational operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;=</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;=</span></tt></code>). The iterators must be valid and must denote elements in (or one past the end of) the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> is an iterator into the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> as <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>, we can check whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> denotes an element before or after <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (it &lt; mid)<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">process elements in the first half of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos844872"/>We can also subtract two iterators so long as they refer to elements in, or one off the end of, the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The result is the distance between the iterators. By distance we mean the amount by which we&#8217;d have to change one iterator to get the other. The result type is a signed integral type named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos845411" href="037-defined_terms.html#filepos980691">difference_type</a></span></span></tt></span></span></tt></code>. Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> define <code class="calibre23"><tt class="calibre23"><span class="calibre24">difference_type</span></tt></code>. This type is signed, because subtraction might have a negative result.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Iterator Arithmetic</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">A classic algorithm that uses iterator arithmetic is binary search. A binary search looks for a particular value in a sorted sequence. It operates by looking at the element closest to the middle of the sequence. If that element is the one we want, we&#8217;re done. Otherwise, if that element is smaller than the one we want, we continue our search by looking only at elements after the rejected one. If the middle element is larger than the one we want, we continue by looking only in the first half. We compute a new middle element in the reduced range and continue looking until we either find the element or run out of elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can do a binary search using iterators as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">text</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must be sorted</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">beg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">end</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will denote the range we're searching</span></span></span><br class="calibre6"/>auto beg = text.begin(), end = text.end();<br class="calibre6"/>auto mid = text.begin() + (end - beg)/2; // <span><span class="calibre45"><span class="calibre16">original midpoint</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">while there are still elements to look at and we haven't yet found</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sought</span></span></tt></span><br class="calibre6"/>while (mid != end &amp;&amp; *mid != sought) {<br class="calibre6"/>&#160;&#160;&#160;&#160;if (sought &lt; *mid)&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">is the element we want in the first half?</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end = mid;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if so, adjust the range to ignore the second half</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the element we want is in the second half</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;beg = mid + 1;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">start looking with the element just after</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">mid</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;mid = beg + (end - beg)/2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">new midpoint</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by defining three iterators: <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> will be the first element in the range, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> one past the last element, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> the element closest to the middle. We initialize these iterators to denote the entire range in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt;</span></tt></code> named <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Our loop first checks that the range is not empty. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> is equal to the current value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, then we&#8217;ve run out of elements to search. In this case, the condition fails and we exit the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code>. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> refers to an element and we check whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> denotes the one we want. If so, we&#8217;re done and we exit the loop.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If we still have elements to process, the code inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> adjusts the range by moving <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code>. If the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> is greater than <code class="calibre23"><tt class="calibre23"><span class="calibre24">sought</span></tt></code>, we know that if <code class="calibre23"><tt class="calibre23"><span class="calibre24">sought</span></tt></code> is in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>, it will appear before the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. Therefore, we can ignore elements after <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>, which we do by assigning <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">*mid</span></tt></code> is smaller than <code class="calibre23"><tt class="calibre23"><span class="calibre24">sought</span></tt></code>, the element must be in the range of elements after the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. In this case, we adjust the range by making <code class="calibre23"><tt class="calibre23"><span class="calibre24">beg</span></tt></code> denote the element just after <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code>. We already know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> is not the one we want, so we can eliminate it from the range.</p><div class="calibre22">&#160;</div>
<p class="calibre25">At the end of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> will be equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> or it will denote the element for which we are looking. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid</span></tt></code> equals <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, then the element was not in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos852759"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.4.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.24:</strong> Redo the last exercise from &#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a> (p. <a href="032-3.3._library_vector_type.html#filepos778112">105</a>) using iterators.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.25:</strong> Rewrite the grade clustering program from &#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a> (p. <a href="032-3.3._library_vector_type.html#filepos778112">104</a>) using iterators instead of subscripts.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.26:</strong> In the binary search program on page <a href="033-3.4._introducing_iterators.html#filepos844872">112</a>, why did we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid = beg + (end - beg) / 2;</span></tt></code> instead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">mid = (beg + end) /2;</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="032-3.3._library_vector_type.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="034-3.5._arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
