<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>6.7. Pointers to Functions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="068-6.6._function_matching.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="070-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1702852" class="calibre29"><span class="bold">6.7. Pointers to Functions</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">A function pointer is just that&#8212;a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function&#8217;s type is determined by its return type and the types of its parameters. The function&#8217;s name is not part of its type. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">compares lengths of two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>bool lengthCompare(const string &amp;, const string &amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool(const string&amp;, const string&amp;)</span></tt></code>. To declare a pointer that can point at this function, we declare a pointer in place of the function name:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to a function returning</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that takes two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">references</span></span></span><br class="calibre6"/>bool (*pf)(const string &amp;, const string &amp;);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uninitialized</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Starting from the name we are declaring, we see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> is preceded by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code>, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> is a pointer. To the right is a parameter list, which means that <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> points to a function. Looking left, we find that the type the function returns is <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> points to a function that has two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string&amp;</span></tt></code> parameters and returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos1706055"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">*pf</span></tt></code> are necessary. If we omit the parentheses, then we declare <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> as a function that returns a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>:</p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">declares a function named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that returns a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool*</span></span></tt></span><br class="calibre6"/>bool *pf(const string &amp;, const string &amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using Function Pointers</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of <code class="calibre23"><tt class="calibre23"><span class="calibre24">lengthCompare</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">pf</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">pf = lengthCompare;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">now points to the function named</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lengthCompare</span></span></tt></span><br class="calibre6"/>pf = &amp;lengthCompare; // <span><span class="calibre45"><span class="calibre16">equivalent assignment: address-of operator is optional</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly&#8212;there is no need to dereference the pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">bool b1 = pf("hello", "goodbye");&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lengthCompare</span></span></tt></span><br class="calibre6"/>bool b2 = (*pf)("hello", "goodbye"); // <span><span class="calibre45"><span class="calibre16">equivalent call</span></span></span><br class="calibre6"/>bool b3 = lengthCompare("hello", "goodbye"); // <span><span class="calibre45"><span class="calibre16">equivalent call</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">There is no conversion between pointers to one function type and pointers to another function type. However, as usual, we can assign <code class="calibre23"><tt class="calibre23"><span class="calibre24">nullptr</span></tt></code> (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>) or a zero-valued integer constant expression to a function pointer to indicate that the pointer does not point to any function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string::size_type sumLength(const string&amp;, const string&amp;);<br class="calibre6"/>bool cstringCompare(const char*, const char*);<br class="calibre6"/>pf = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to no function</span></span></span><br class="calibre6"/>pf = sumLength;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: return type differs</span></span></span><br class="calibre6"/>pf = cstringCompare; // <span><span class="calibre45"><span class="calibre16">error: parameter types differ</span></span></span><br class="calibre6"/>pf = lengthCompare;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: function and pointer types match exactly</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Pointers to Overloaded Functions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As usual, when we use an overloaded function, the context must make it clear which version is being used. When we declare a pointer to an overloaded function</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void ff(int*);<br class="calibre6"/>void ff(unsigned int);<br class="calibre6"/>void (*pf1)(unsigned int) = ff;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff(unsigned</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the compiler uses the type of the pointer to determine which overloaded function to use. The type of the pointer must match one of the overloaded functions exactly:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void (*pf2)(int) = ff;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with a matching parameter list</span></span></span><br class="calibre6"/>double (*pf3)(int*) = ff; // <span><span class="calibre45"><span class="calibre16">error: return type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">don't match</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos1713246"/>Function Pointer Parameters</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Just as with arrays (&#167; <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a>, p. <a href="064-6.2._argument_passing.html#filepos1499104">214</a>), we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">third parameter is a function type and is automatically treated as a pointer to function</span></span></span><br class="calibre6"/>void useBigger(const string &amp;s1, const string &amp;s2,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bool pf(const string &amp;, const string &amp;));<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">equivalent declaration: explicitly define the parameter as a pointer to function</span></span></span><br class="calibre6"/>void useBigger(const string &amp;s1, const string &amp;s2,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;bool (*pf)(const string &amp;, const string &amp;));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we pass a function as an argument, we can do so directly. It will be automatically converted to a pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">automatically converts the function</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">lengthCompare</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a pointer to function</span></span></span><br class="calibre6"/>useBigger(s1, s2, lengthCompare);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">As we&#8217;ve just seen in the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">useBigger</span></tt></code>, writing function pointer types quickly gets tedious. Type aliases (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>), along with <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>), let us simplify code that uses function pointers:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Func</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Func2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have function type</span></span></span><br class="calibre6"/>typedef bool Func(const string&amp;, const string&amp;);<br class="calibre6"/>typedef decltype(lengthCompare) Func2; // <span><span class="calibre45"><span class="calibre16">equivalent type</span></span></span><br class="calibre6"/><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">FuncP</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">FuncP2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have pointer to function type</span></span></span><br class="calibre6"/>typedef bool(*FuncP)(const string&amp;, const string&amp;);<br class="calibre6"/>typedef decltype(lengthCompare) *FuncP2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve used <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> to define our types. Both <code class="calibre23"><tt class="calibre23"><span class="calibre24">Func</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">Func2</span></tt></code> are function types, whereas <code class="calibre23"><tt class="calibre23"><span class="calibre24">FuncP</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">FuncP2</span></tt></code> are pointer types. It is important to note that <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> returns the function type; the automatic conversion to pointer is not done. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> returns a function type, if we want a pointer we must add the <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> ourselves. We can redeclare <code class="calibre23"><tt class="calibre23"><span class="calibre24">useBigger</span></tt></code> using any of these types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">equivalent declarations of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">useBigger</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">using type aliases</span></span></span><br class="calibre6"/>void useBigger(const string&amp;, const string&amp;, Func);<br class="calibre6"/>void useBigger(const string&amp;, const string&amp;, FuncP2);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Both declarations declare the same function. In the first case, the compiler will automatically convert the function type represented by <code class="calibre23"><tt class="calibre23"><span class="calibre24">Func</span></tt></code> to a pointer.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Returning a Pointer to Function</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with arrays (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">228</a>), we can&#8217;t return a function type but can return a pointer to a function type. Similarly, we must write the return type as a pointer type; the compiler will not automatically treat a function return type as the corresponding pointer type. Also as with array returns, by far the easiest way to declare a function that returns a pointer to function is by using a type alias:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">using F = int(int*, int);&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">F</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a function type, not a pointer</span></span></span><br class="calibre6"/>using PF = int(*)(int*, int); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">PF</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1720652"/>Here we used type alias declarations (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">68</a>) to define <code class="calibre23"><tt class="calibre23"><span class="calibre24">F</span></tt></code> as a function type and <code class="calibre23"><tt class="calibre23"><span class="calibre24">PF</span></tt></code> as a pointer to function type. The thing to keep in mind is that, unlike what happens to parameters that have function type, the return type is not automatically converted to a pointer type. We must explicitly specify that the return type is a pointer type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">PF f1(int); // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">PF</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to function;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a pointer to function</span></span></span><br class="calibre6"/>F f1(int);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">F</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a function type;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can't return a function</span></span></span><br class="calibre6"/>F *f1(int); // <span><span class="calibre45"><span class="calibre16">ok: explicitly specify that the return type is a pointer to function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Of course, we can also declare <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> directly, which we&#8217;d do as</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int (*f1(int))(int*, int);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Reading this declaration from the inside out, we see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> has a parameter list, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> is a function. <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> is preceded by a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> so <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> returns a pointer. The type of that pointer itself has a parameter list, so the pointer points to a function. That function returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For completeness, it&#8217;s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto f1(int) -&gt; int (*)(int*, int);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">auto</span></span></tt></span></span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">decltype</span></span></tt></span></span></tt></code> for Function Pointer Types</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">If we know which function(s) we want to return, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to simplify writing a function pointer return type. For example, assume we have two functions, both of which return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string::size_type</span></tt></code> and have two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string&amp;</span></tt></code> parameters. We can write a third function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> parameter and returns a pointer to one of these two functions as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string::size_type sumLength(const string&amp;, const string&amp;);<br class="calibre6"/>string::size_type largerLength(const string&amp;, const string&amp;);<br class="calibre6"/><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">depending on the value of its</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter,</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">getFcn</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns a pointer to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sumLength</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largerLength</span></span></tt></span><br class="calibre6"/>decltype(sumLength) *getFcn(const string &amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The only tricky part in declaring <code class="calibre23"><tt class="calibre23"><span class="calibre24">getFcn</span></tt></code> is to remember that when we apply <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> to a function, it returns a function type, not a pointer to function type. We must add a <code class="calibre23"><tt class="calibre23"><span class="calibre24">*</span></tt></code> to indicate that we are returning a pointer, not a function.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 6.7</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.54:</strong> Write a declaration for a function that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameters and returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, and declare a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> whose elements have this function pointer type.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.55:</strong> Write four functions that add, subtract, multiply, and divide two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> values. Store pointers to these values in your <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> from the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 6.56:</strong> Call each element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and print their result.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="068-6.6._function_matching.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="070-chapter_summary.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
