<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>15.3. Virtual Functions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="143-15.2._defining_base_and_derived_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="145-15.4._abstract_base_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3853256" class="calibre29"><span class="bold">15.3. Virtual Functions</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, in C++ dynamic binding happens when a virtual member function is called through a reference or a pointer to a base-class type (&#167;<a href="142-15.1._oop_an_overview.html#filepos3782427">15.1</a>, p. <a href="142-15.1._oop_an_overview.html#filepos3782427">593</a>). Because we don&#8217;t know which version of a function is called until run time, virtual functions must <em class="calibre16">always</em> be defined. Ordinarily, if we do not use a function, we don&#8217;t need to supply a definition for that function (&#167;<a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>). However, we must define every virtual function, regardless of whether it is used, because the compiler has no way to determine whether a virtual function is used.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos3854199"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.8:</strong> Define static type and dynamic type.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.9:</strong> When is it possible for an expression&#8217;s static type to differ from its dynamic type? Give three examples in which the static and dynamic type differ.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.10:</strong> Recalling the discussion from &#167;<a href="083-8.1._the_io_classes.html#filepos2076693">8.1</a> (p. <a href="083-8.1._the_io_classes.html#filepos2076693">311</a>), explain how the program on page <a href="084-8.2._file_input_and_output.html#filepos2114945">317</a> that passed an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data read</span></tt></code> function works.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Conversions among Types Related by Inheritance</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">There are three things that are important to understand about conversions among classes related by inheritance:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The conversion from derived to base applies only to pointer or reference types.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; There is no implicit conversion from the base-class type to the derived type.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Like any member, the derived-to-base conversion may be inaccessible due to access controls. We&#8217;ll cover accessibility in &#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a> (p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">613</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Although the automatic conversion applies only to pointers and references, most classes in an inheritance hierarchy (implicitly or explicitly) define the copy-control members (<a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>). As a result, we can often copy, move, or assign an object of derived type to a base-type object. However, copying, moving, or assigning a derived-type object to a base-type object copies, moves, or assigns <em class="calibre16">only</em> the members in the base-class part of the object.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Calls to Virtual Functions <em class="calibre16">May Be</em> Resolved at Run Time</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When a virtual function is called through a reference or pointer, the compiler generates code to <em class="calibre16">decide at run time</em> which function to call. The function that is called is the one that corresponds to the dynamic type of the object bound to that pointer or reference.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, consider our <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> function from &#167;<a href="142-15.1._oop_an_overview.html#filepos3782427">15.1</a> (p. <a href="142-15.1._oop_an_overview.html#filepos3782427">593</a>). That function calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> on its parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code>, which has type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote&amp;</span></tt></code>. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> is a reference, and because <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> is virtual, the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> that is called depends at run time on the actual (dynamic) type of the argument bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">Quote base("0-201-82470-1", 50);<br class="calibre6"/>print_total(cout, base, 10);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote::net_price</span></span></tt></span><br class="calibre6"/>Bulk_quote derived("0-201-82470-1", 50, 5, .19);<br class="calibre6"/>print_total(cout, derived, 10); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Bulk_quote::net_price</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In the first call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> is bound to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code>. As a result, when <a id="filepos3859516"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>, the version defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> is run. In the second call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">item</span></tt></code> is bound to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> object. In this call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">print_total</span></tt></code> calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Bulk_quote</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is crucial to understand that dynamic binding happens only when a virtual function is called through a pointer or a reference.</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">base = derived;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copies the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">part of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">derived</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">base</span></span></tt></span><br class="calibre6"/>base.net_price(20);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Quote::net_price</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we call a virtual function on an expression that has a plain&#8212;nonreference and nonpointer&#8212;type, that call is bound at compile time. For example, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> on <code class="calibre23"><tt class="calibre23"><span class="calibre24">base</span></tt></code>, there is no question as to which version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> to run. We can change the value (i.e., the contents) of the object that <code class="calibre23"><tt class="calibre23"><span class="calibre24">base</span></tt></code> represents, but there is no way to change the type of that object. Hence, this call is resolved, at compile time, to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Polymorphism in C++</span></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The key idea behind OOP is polymorphism. Polymorphism is derived from a Greek word meaning &#8220;many forms.&#8221; We speak of types related by inheritance as polymorphic types, because we can use the &#8220;many forms&#8221; of these types while ignoring the differences among them. The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we call a function defined in a base class through a reference or pointer to the base class, we do not know the type of the object on which that member is executed. The object can be a base-class object or an object of a derived class. If the function is virtual, then the decision as to which function to run is delayed until run time. The version of the virtual function that is run is the one defined by the type of the object to which the reference is bound or to which the pointer points.</p><div class="calibre22">&#160;</div>
<p class="calibre25">On the other hand, calls to nonvirtual functions are bound at compile time. Similarly, calls to any function (virtual or not) on an object are also bound at compile time. The type of an object is fixed and unvarying&#8212;there is nothing we can do to make the dynamic type of an object differ from its static type. Therefore, calls made on an object are bound at compile time to the version defined by the type of the object.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Virtuals are resolved at run time <em class="calibre16">only</em> if the call is made through a reference or pointer. Only in these cases is it possible for an object&#8217;s dynamic type to differ from its static type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Virtual Functions in a Derived Class</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">When a derived class overrides a virtual function, it may, but is not required to, repeat the <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> keyword. Once a function is declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code>, it remains <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> in all the derived classes.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A derived-class function that overrides an inherited virtual function must have exactly the same parameter type(s) as the base-class function that it overrides.</p><div class="calibre22">&#160;</div>
<p class="calibre25">With one exception, the return type of a virtual in the derived class also must match the return type of the function from the base class. The exception applies to <a id="filepos3865666"/>virtuals that return a reference (or pointer) to types that are themselves related by inheritance. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> is derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>, then a base class virtual can return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">B*</span></tt></code> and the version in the derived can return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">D*</span></tt></code>. However, such return types require that the derived-to-base conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">D</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> is accessible. &#167;<a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a> (p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">613</a>) covers how to determine whether a base class is accessible. We&#8217;ll see an example of this kind of virtual function in &#167;<a href="149-15.8._containers_and_inheritance.html#filepos4027082">15.8.1</a> (p. <a href="149-15.8._containers_and_inheritance.html#filepos4027082">633</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A function that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> in a base class is implicitly <code class="calibre23"><tt class="calibre23"><span class="calibre24">virtual</span></tt></code> in its derived classes. When a derived class overrides a virtual, the parameters in the base and derived classes must match exactly.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">final</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">override</span></span></tt></span></span></tt></code> Specifiers</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ll see in &#167;<a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">15.6</a> (p. <a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">620</a>), it is legal for a derived class to define a function with the same name as a virtual in its base class but with a different parameter list. The compiler considers such a function to be independent from the base-class function. In such cases, the derived version does not override the version in the base class. In practice, such declarations often are a mistake&#8212;the class author intended to override a virtual from the base class but made a mistake in specifying the parameter list.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos3868355"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Finding such bugs can be surprisingly hard. Under the new standard we can specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> on a virtual function in a derived class. Doing so makes our intention clear and (more importantly) enlists the compiler in finding such problems for us. The compiler will reject a program if a function marked <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> does not override an existing virtual function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct B {<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual void f1(int) const;<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual void f2();<br class="calibre6"/>&#160;&#160;&#160;&#160;void f3();<br class="calibre6"/>};<br class="calibre6"/>struct D1 : B {<br class="calibre6"/>&#160;&#160;&#160;&#160;void f1(int) const override; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">matches</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in the base</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f2(int) override; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has no</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">function</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f3() override;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not virtual</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f4() override;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">doesn't have a function named f4</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> specifier on <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> is fine; both the base and derived versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> members that take an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. The version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f1</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> properly overrides the virtual that it inherits from <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> does not match the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>&#8212;the version defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> takes no arguments and the one defined in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Because the declarations don&#8217;t match, <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code> doesn&#8217;t override <code class="calibre23"><tt class="calibre23"><span class="calibre24">f2</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>; it is a new function that happens to have the same name. Because we said we intended this declaration to be an <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> and it isn&#8217;t, the compiler will generate an error.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because only a virtual function can be overridden, the compiler will also reject <code class="calibre23"><tt class="calibre23"><span class="calibre24">f3</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">D1</span></tt></code>. That function is not virtual in <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code>, so there is no function to override. <a id="filepos3873399"/>Similarly <code class="calibre23"><tt class="calibre23"><span class="calibre24">f4</span></tt></code> is in error because <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> doesn&#8217;t even have a function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">f4</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">We can also designate a function as <code class="calibre23"><tt class="calibre23"><span class="calibre24">final</span></tt></code>. Any attempt to override a function that has been defined as <code class="calibre23"><tt class="calibre23"><span class="calibre24">final</span></tt></code> will be flagged as an error:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct D2 : B {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">inherits</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f3(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and overrides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1(int)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f1(int) const final; // <span><span class="calibre45"><span class="calibre16">subsequent classes can't override</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">(int)</span></span></span><br class="calibre6"/>};<br class="calibre6"/>struct D3 : D2 {<br class="calibre6"/>&#160;&#160;&#160;&#160;void f2();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: overrides</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">inherited from the indirect base,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">B</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f1(int) const; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">D2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">declared</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">final</span></span></tt></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">final</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> specifiers appear after the parameter list (including any <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference qualifiers) and after a trailing return (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>).</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Virtual Functions and Default Arguments</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Like any other function, a virtual function can have default arguments (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>). If a call uses a default argument, the value that is used is the one defined by the static type through which the function is called.</p><div class="calibre15">&#160;</div>
<p class="calibre25">That is, when a call is made through a reference or pointer to base, the default argument(s) will be those defined in the base class. The base-class arguments will be used even when the derived version of the function is run. In this case, the derived function will be passed the default arguments defined for the base-class version of the function. If the derived function relies on being passed different arguments, the program will not execute as expected.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Virtual functions that have default arguments should use the same argument values in the base and derived classes.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Circumventing the Virtual Mechanism</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In some cases, we want to prevent dynamic binding of a call to a virtual function; we want to force the call to use a particular version of that virtual. We can use the scope operator to do so. For example, this code:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">//&#160;&#160;<span><span class="calibre45"><span class="calibre16">calls the version from the base class regardless of the dynamic type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">baseP</span></span></tt></span><br class="calibre6"/>double undiscounted = baseP-&gt;Quote::net_price(42);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">calls the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">net_price</span></tt></code> regardless of the type of the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">baseP</span></tt></code> actually points. This call will be resolved at compile time.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily, only code inside member functions (or friends) should need to use the scope operator to circumvent the virtual mechanism.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Why might we wish to circumvent the virtual mechanism? The most common reason is when a derived-class virtual function calls the version from the base class. In such cases, the base-class version might do work common to all types in the hierarchy. The versions defined in the derived classes would do whatever additional work is particular to their own type.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><a id="filepos3880356"/><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a derived virtual function that intended to call its base-class version omits the scope operator, the call will be resolved at run time as a call to the derived version itself, resulting in an infinite recursion.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 15.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.11:</strong> Add a virtual <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug</span></tt></code> function to your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Quote</span></tt></code> class hierarchy that displays the data members of the respective classes.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.12:</strong> Is it ever useful to declare a member function as both <code class="calibre23"><tt class="calibre23"><span class="calibre24">override</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">final</span></tt></code>? Why or why not?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.13:</strong> Given the following classes, explain each <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;string name() { return basename; }<br class="calibre6"/>&#160;&#160;&#160;virtual void print(ostream &amp;os) { os &lt;&lt; basename; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;string basename;<br class="calibre6"/>};<br class="calibre6"/>class derived : public base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;void print(ostream &amp;os) { print(os); os &lt;&lt; " " &lt;&lt; i; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;int i;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If there is a problem in this code, how would you fix it?</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 15.14:</strong> Given the classes from the previous exercise and the following objects, determine which function is called at run time:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">base bobj;&#160;&#160;&#160;&#160;&#160;base *bp1 = &amp;bobj;&#160;&#160;&#160;base &amp;br1 = bobj;<br class="calibre6"/>derived dobj;&#160;&#160;base *bp2 = &amp;dobj;&#160;&#160;&#160;base &amp;br2 = dobj;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">bobj.print();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">dobj.print();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">bp1-&gt;name();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">bp2-&gt;name();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(e)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">br1.print();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(f)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">br2.print();</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="143-15.2._defining_base_and_derived_classes.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="145-15.4._abstract_base_classes.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
