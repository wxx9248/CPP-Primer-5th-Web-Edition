<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>4.3. Logical and Relational Operators</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="040-4.2._arithmetic_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="042-4.4._assignment_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos1044115" class="calibre29"><span class="bold">4.3. Logical and Relational Operators</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The relational operators take operands of arithmetic or pointer type; the logical operators take operands of any type that can be converted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. These operators all return values of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. Arithmetic and pointer operand(s) with a value of zero are <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>; all other values are <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The operands to these operators are rvalues and the result is an rvalue.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos1044939"/><a/>Table 4.2. Logical and Relational Operators</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00031.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Logical <small class="calibre48">AND</small> and <small class="calibre48">OR</small> Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The overall result of the logical <small class="calibre48">AND</small> operator is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if and only if both its operands evaluate to <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. The logical <small class="calibre48">OR</small> (<code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code>) operator evaluates as <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if either of its operands evaluates as <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The logical <small class="calibre48">AND</small> and <small class="calibre48">OR</small> operators always evaluate their left operand before the right. Moreover, the right operand is evaluated <em class="calibre16">if and only if</em> the left operand does not determine the result. This strategy is known as <strong class="calibre5"><a id="filepos1046144" href="052-defined_terms.html#filepos1221109">short-circuit evaluation</a></strong>:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The right side of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code> is evaluated if and only if the left side is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The right side of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code> is evaluated if and only if the left side is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">Several of the programs in <a href="029-chapter_3._strings_vectors_and_arrays.html#filepos633734">Chapter 3</a> used the logical <small class="calibre48">AND</small> operator. Those programs used the left-hand operand to test whether it was safe to evaluate the right-hand operand. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> condition on page <a href="031-3.2._library_string_type.html#filepos718762">94</a>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">index != s.size() &amp;&amp; !isspace(s[index])</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">first checks that <code class="calibre23"><tt class="calibre23"><span class="calibre24">index</span></tt></code> has not reached the end of its associated <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We&#8217;re guaranteed that the right operand won&#8217;t be evaluated unless <code class="calibre23"><tt class="calibre23"><span class="calibre24">index</span></tt></code> is in range.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example that uses the logical <small class="calibre48">OR</small>, imagine we have some text in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. We want to print the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, adding a newline after each empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or after a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that ends with a period. We&#8217;ll use a range-based <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> loop (&#167; <a href="031-3.2._library_string_type.html#filepos697807">3.2.3</a>, p. <a href="031-3.2._library_string_type.html#filepos697807">91</a>) to process each element:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">//&#160;&#160;<span><span class="calibre45"><span class="calibre16">note</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a reference to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span>; <span><span class="calibre45"><span class="calibre16">the elements aren't copied and can't be changed</span></span></span><br class="calibre6"/>for (const auto &amp;s : text) { // <span><span class="calibre45"><span class="calibre16">for each element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">text</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the current element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">blank lines and those that end with a period get a newline</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (s.empty() || s[s.size() - 1] == '.')<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &lt;&lt; " ";&#160;&#160;// <span><span class="calibre45"><span class="calibre16">otherwise just separate with a space</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1050473"/>After we print the current element, we check to see if we need to print a newline. The condition in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> first checks whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. If so, we need to print a newline regardless of the value of the right-hand operand. Only if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is not empty do we evaluate the second expression, which checks whether the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> ends with a period. In this expression, we rely on short-circuit evaluation of <code class="calibre23"><tt class="calibre23"><span class="calibre24">||</span></tt></code> to ensure that we subscript <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> only if <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is not empty.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that we declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> as a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">69</a>). The elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">text</span></tt></code> are <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, and might be large. By making <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> a reference, we avoid copying the elements. Because we don&#8217;t need to write to the elements, we made <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Logical <small class="calibre48">NOT</small> Operator</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The logical <small class="calibre48">NOT</small> operator (<code class="calibre23"><tt class="calibre23"><span class="calibre24">!</span></tt></code>) returns the inverse of the truth value of its operand. We first used this operator in &#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a> (p. <a href="031-3.2._library_string_type.html#filepos659212">87</a>). As another example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, we might use the logical <small class="calibre48">NOT</small> operator to see whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> has elements by negating the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if there is one</span></span></span><br class="calibre6"/>if (!vec.empty())<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; vec[0];</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The subexpression</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">!vec.empty()</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">evaluates as <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The Relational Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The relational operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;=</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;=</span></tt></code>) have their ordinary meanings and return <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> values. These operators are left associative.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the relational operators return <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>s, the result of chaining these operators together is likely to be surprising:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">oops! this condition compares</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">bool</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">result of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">&lt; j</span></span></span><br class="calibre6"/>if (i &lt; j &lt; k) // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is greater than 1!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This condition groups <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> to the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> result of that expression is the left-hand operand of the second less-than operator. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">k</span></tt></code> is compared to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>/<code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> result of the first comparison! To accomplish the test we intended, we can rewrite the expression as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: condition is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is smaller than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">j</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is smaller than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">k</span></span></tt></span><br class="calibre6"/>if (i &lt; j &amp;&amp; j &lt; k) { /* ...&#160;&#160;*/ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Equality Tests and the <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">bool</span></span></tt></span></span></tt></code> Literals</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">If we want to test the truth value of an arithmetic or pointer object, the most direct way is to use the value as a condition:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (val)&#160;&#160;{ /*&#160;&#160;...&#160;&#160;*/ } // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is any nonzero value</span></span></span><br class="calibre6"/>if (!val) { /*&#160;&#160;...&#160;&#160;*/ } // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is zero</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos1059698"/>In both conditions, the compiler converts <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>. The first condition succeeds so long as <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is nonzero; the second succeeds if <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is zero.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We might think we could rewrite a test of this kind as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (val == true) { /* ...&#160;&#160;&#160;*/ } // <span><span class="calibre45"><span class="calibre16">true only if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is equal to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1!</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There are two problems with this approach. First, it is longer and less direct than the previous code (although admittedly when first learning C++ this kind of abbreviation can be perplexing). Much more importantly, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, this comparison does not work as expected.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> is converted to the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator is applied. That is, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> is not a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>, it is as if we had written</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (val == 1) { /* ... */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> is converted to another arithmetic type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> converts to <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> converts to <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code> (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>). If we really cared whether <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code> was the specific value <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, we should write the condition to test that case directly.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is usually a bad idea to use the boolean literals <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> as operands in a comparison. These literals should be used only to compare to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 4.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.8:</strong> Explain when operands are evaluated in the logical <small class="calibre48">AND</small>, logical <small class="calibre48">OR</small>, and equality operators.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.9:</strong> Explain the behavior of the condition in the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code>:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char *cp = "Hello World";<br class="calibre6"/>if (cp &amp;&amp; *cp)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.10:</strong> Write the condition for a <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> loop that would read <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s from the standard input and stop when the value read is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">42</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.11:</strong> Write an expression that tests four values, <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code>, and ensures that <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> is greater than <code class="calibre23"><tt class="calibre23"><span class="calibre24">b</span></tt></code>, which is greater than <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code>, which is greater than <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 4.12:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">k</span></tt></code> are all <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, explain what <code class="calibre23"><tt class="calibre23"><span class="calibre24">i != j &lt; k</span></tt></code> means.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="040-4.2._arithmetic_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="042-4.4._assignment_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
