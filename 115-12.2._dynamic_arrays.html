<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>12.2. Dynamic Arrays</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="114-12.1._dynamic_memory_and_smart_pointers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="116-12.3._using_the_library_a_textquery_program.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3086710" class="calibre29"><span class="bold">12.2. Dynamic Arrays</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> operators allocate objects one at a time. Some applications, need the ability to allocate storage for many objects at once. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s store their elements in contiguous memory and must allocate several elements at once whenever the container has to be reallocated (&#167; <a href="092-9.4._how_a_vector_grows.html#filepos2347166">9.4</a>, p. <a href="092-9.4._how_a_vector_grows.html#filepos2347166">355</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">To support such usage, the language and library provide two ways to allocate an array of objects at once. The language defines a second kind of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression that allocates and initializes an array of objects. The library includes a template class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> that lets us separate allocation from initialization. For reasons we&#8217;ll explain in &#167; <a href="115-12.2._dynamic_arrays.html#filepos3119523">12.2.2</a> (p. <a href="115-12.2._dynamic_arrays.html#filepos3119523">481</a>), using an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> generally provides better performance and more flexible memory management.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Many, perhaps even most, applications have no direct need for dynamic arrays. When an application needs a varying number of objects, it is almost always easier, faster, and safer to do as we did with <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob:</span></tt></code> use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> (or other library container). For reasons we&#8217;ll explain in &#167; <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>), the advantages of using a library container are even more pronounced under the new standard. Libraries that support the new standard tend to be dramatically faster than previous releases.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Most applications should use a library container rather than dynamically allocated arrays. Using a container is easier, less likely to contain memory-management bugs, <em class="calibre16">and</em> is likely to give better performance.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, classes that use the containers can use the default versions of the operations for copy, assignment, and destruction (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). Classes that allocate dynamic arrays must define their own versions of these operations to manage the associated memory when objects are copied, assigned, and destroyed.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Do not allocate dynamic arrays in code inside classes until you have read <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3090536" class="calibre37"><span class="calibre5"><a id="filepos3090569"/>12.2.1. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">new</span></span></tt></span></span></tt></code> and Arrays</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">We ask <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to allocate an array of objects by specifying the number of objects to allocate in a pair of square brackets after a type name. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> allocates the requested number of objects and (assuming the allocation succeeds) returns a pointer to the first one:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get_size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to determine how many</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s to allocate</span></span></span><br class="calibre6"/>int *pia = new int[get_size()]; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pia</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first of these</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The size inside the brackets must have integral type but need not be a constant.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can also allocate an array by using a type alias (&#167; <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) to represent an array type. In this case, we omit the brackets:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef int arrT[42]; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arrT</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">names the type array of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *p = new arrT;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocates an array of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first one</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> allocates an array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and returns a pointer to the first one. Even though there are no brackets in our code, the compiler executes this expression using <code class="calibre23"><tt class="calibre23"><span class="calibre24">new[]</span></tt></code>. That is, the compiler executes this expression as if we had written</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p = new int[42];</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Allocating an Array Yields a Pointer to the Element Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although it is common to refer to memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new T[]</span></tt></code> as a &#8220;dynamic array,&#8221; this usage is somewhat misleading. When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to allocate an array, we do not get an object with an array type. Instead, we get a pointer to the element type of the array. Even if we use a type alias to define an array type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> does not allocate an object of array type. In this case, the fact that we&#8217;re allocating an array is not even visible; there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">[</span></tt></code><em class="calibre16">num</em>]. Even so, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> returns a pointer to the element type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because the allocated memory does not have an array type, we cannot call <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) on a dynamic array. These functions use the array dimension (which is part of an array&#8217;s type) to return pointers to the first and one past the last elements, respectively. For the same reasons, we also cannot use a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> to process the elements in a (so-called) dynamic array.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3096143"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is important to remember that what we call a dynamic array does not have an array type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Initializing an Array of Dynamically Allocated Objects</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">By default, objects allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>&#8212;whether allocated as a single object or in an array&#8212;are default initialized. We can value initialize (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) the elements in an array by following the size with an empty pair of parentheses.</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *pia = new int[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">block of ten uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *pia2 = new int[10]();&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">block of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">value initialized to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>string *psa = new string[10];&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">block of ten empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>string *psa2 = new string[10](); // <span><span class="calibre45"><span class="calibre16">block of ten empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3098772"/><a id="filepos3098780"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can also provide a braced list of element initializers:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">block of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">each initialized from the corresponding initializer</span></span></span><br class="calibre6"/>int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">block of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s;</span></span></span>
<span><span class="calibre45"><span class="calibre16">the first four are initialized from the given initializers</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">remaining elements are value initialized</span></span></span><br class="calibre6"/>string *psa3 = new string[10]{"a", "an", "the", string(3,'x')};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As when we list initialize an object of built-in array type (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), the initializers are used to initialize the first elements in the array. If there are fewer initializers than elements, the remaining elements are value initialized. If there are more initializers than the given size, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression fails and no storage is allocated. In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> throws an exception of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_array_new_length</span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code>, this type is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Although we can use empty parentheses to value initialize the elements of an array, we cannot supply an element initializer inside the parentheses. The fact that we cannot supply an initial value inside the parentheses means that we cannot use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to allocate an array (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">459</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3101582"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<h5 class="calibre39"><span class="calibre5">It Is Legal to Dynamically Allocate an Empty Array</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can use an arbitrary expression to determine the number of objects to allocate:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">size_t n = get_size(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get_size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">returns the number of elements needed</span></span></span><br class="calibre6"/>int* p = new int[n];&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocate an array to hold the elements</span></span></span><br class="calibre6"/>for (int* q = p; q != p + n; ++q)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;/* <span><span class="calibre45"><span class="calibre16">process the array</span></span></span> */ ;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">An interesting question arises: What happens if <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_size</span></tt></code> returns 0? The answer is that our code works fine. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">new[n]</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> equal to 0 is legal even though we cannot create an array variable of size 0:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char arr[0];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot define a zero-length array</span></span></span><br class="calibre6"/>char *cp = new char[0]; // <span><span class="calibre45"><span class="calibre16">ok: but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can't be dereferenced</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> to allocate an array of size zero, <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> returns a valid, nonzero pointer. That pointer is guaranteed to be distinct from any other pointer returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. This pointer acts as the off-the-end pointer (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">119</a>) for a zero-element array. We can use this pointer in ways that we use an off-the-end iterator. The pointer can be compared as in the loop above. We can add zero to (or subtract zero from) such a pointer and can subtract the pointer from itself, yielding zero. The pointer cannot be dereferenced&#8212;after all, it points to no element.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In our hypothetical loop, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">get_size</span></tt></code> returns 0, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> is also 0. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> will allocate zero objects. The condition in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> will fail (<code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">q + n</span></tt></code> because <code class="calibre23"><tt class="calibre23"><span class="calibre24">n</span></tt></code> is 0). Thus, the loop body is not executed.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Freeing Dynamic Arrays</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">To free a dynamic array, we use a special form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> that includes an empty pair of square brackets:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3105858"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">delete p;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must point to a dynamically allocated object or be null</span></span></span><br class="calibre6"/>delete [] pa; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pa</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">must point to a dynamically allocated array or be null</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The second statement destroys the elements in the array to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">pa</span></tt></code> points and frees the corresponding memory. Elements in an array are destroyed in reverse order. That is, the last element is destroyed first, then the second to last, and so on.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to an array, the empty bracket pair is essential: It indicates to the compiler that the pointer addresses the first element of an array of objects. If we omit the brackets when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to an array (or provide them when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to an object), the behavior is undefined.</p><div class="calibre22">&#160;</div>
<p class="calibre14">Recall that when we use a type alias that defines an array type, we can allocate an array without using <code class="calibre23"><tt class="calibre23"><span class="calibre24">[]</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. Even so, we must use brackets when we delete a pointer to that array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">typedef int arrT[42];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arrT</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">names the type array of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *p = new arrT;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">allocates an array of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>; <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first one</span></span></span><br class="calibre6"/>delete [] p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">brackets are necessary because we allocated an array</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Despite appearances, <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> points to the first element of an array of objects, not to a single object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrT</span></tt></code>. Thus, we must use <code class="calibre23"><tt class="calibre23"><span class="calibre24">[]</span></tt></code> when we delete <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The compiler is unlikely to warn us if we forget the brackets when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to an array or if we use them when we <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> a pointer to an object. Instead, our program is apt to misbehave without warning during execution.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Smart Pointers and Dynamic Arrays</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The library provides a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> that can manage arrays allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code>. To use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> to manage a dynamic array, we must include a pair of empty brackets after the object type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">up</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an array of ten uninitialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>unique_ptr&lt;int[]&gt; up(new int[10]);<br class="calibre6"/>up.release();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">automatically uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete[]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to destroy its pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The brackets in the type specifier <code class="calibre23"><tt class="calibre23"><span class="calibre24">(&lt;int[]&gt;)</span></tt></code> say that <code class="calibre23"><tt class="calibre23"><span class="calibre24">up</span></tt></code> points not to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> but to an array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">up</span></tt></code> points to an array, when <code class="calibre23"><tt class="calibre23"><span class="calibre24">up</span></tt></code> destroys the pointer it manages, it will automatically use <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete[]</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><code class="calibre23"><tt class="calibre23"><span class="calibre24">unqiue_ptr</span></tt></code>s that point to arrays provide slightly different operations than those we used in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">470</a>). These operations are described in <a href="115-12.2._dynamic_arrays.html#filepos3113900">Table 12.6</a> (overleaf). When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> points to an array, we cannot use the dot and arrow member access operators. After all, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unqiue_ptr</span></tt></code> points to an array, not an object so these operators would be meaningless. On the other hand, when a <code class="calibre23"><tt class="calibre23"><span class="calibre24">unqiue_ptr</span></tt></code> points to an array, we can use the subscript operator to access the elements in the array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (size_t i = 0; i != 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;up[i] = i; // <span><span class="calibre45"><span class="calibre16">assign a new value to each of the elements</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3113892"/><a id="filepos3113900"/>Table 12.6. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unique_ptr</span></span></tt></span></span></tt></code>s to Arrays</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00094.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s provide no direct support for managing a dynamic array. If we want to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> to manage a dynamic array, we must provide our own deleter:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">to use a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">we must supply a deleter</span></span></span><br class="calibre6"/>shared_ptr&lt;int&gt; sp(new int[10], [](int *p) { delete[] p; });<br class="calibre6"/>sp.reset(); // <span><span class="calibre45"><span class="calibre16">uses the lambda we supplied that uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete[]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to free the array</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we pass a lambda (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) that uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete[]</span></tt></code> as the deleter.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Had we neglected to supply a deleter, this code would be undefined. By default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> to destroy the object to which it points. If that object is a dynamic array, using <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> has the same kinds of problems that arise if we forget to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">[]</span></tt></code> when we delete a pointer to a dynamic array (&#167; <a href="115-12.2._dynamic_arrays.html#filepos3090536">12.2.1</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3090536">479</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre14">The fact that <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> does not directly support managing arrays affects how we access the elements in the array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">shared_ptr</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s don't have subscript operator and don't support pointer arithmetic</span></span></span><br class="calibre6"/>for (size_t i = 0; i != 10; ++i)<br class="calibre6"/>&#160;&#160;&#160;&#160;*(sp.get() + i) = i;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to get a built-in pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">There is no subscript operator for <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s, and the smart pointer types do not support pointer arithmetic. As a result, to access the elements in the array, we must use <code class="calibre23"><tt class="calibre23"><span class="calibre24">get</span></tt></code> to obtain a built-in pointer, which we can then use in normal ways.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.23:</strong> Write a program to concatenate two string literals, putting the result in a dynamically allocated array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code>. Write a program to concatenate two library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s that have the same value as the literals used in the first program.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.24:</strong> Write a program that reads a string from the standard input into a dynamically allocated character array. Describe how your program handles varying size inputs. Test your program by giving it a string of data that is longer than the array size you&#8217;ve allocated.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.25:</strong> Given the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression, how would you <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete pa</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *pa = new int[10];</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3119523" class="calibre37"><span class="calibre5"><a id="filepos3119556"/>12.2.2. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">allocator</span></span></tt></span></span></tt></code> Class</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">An aspect of <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> that limits its flexibility is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> combines allocating memory with constructing object(s) in that memory. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> combines destruction with deallocation. Combining initialization with allocation is usually what we want when we allocate a single object. In that case, we almost certainly know the value the object should have.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we allocate a block of memory, we often plan to construct objects in that memory as needed. In this case, we&#8217;d like to decouple memory allocation from object construction. Decoupling construction from allocation means that we can allocate memory in large chunks and pay the overhead of constructing the objects only when we actually need to create them.</p><div class="calibre22">&#160;</div>
<p class="calibre14">In general, coupling allocation and construction can be wasteful. For example:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *const p = new string[n]; // <span><span class="calibre45"><span class="calibre16">construct</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>string s;<br class="calibre6"/>string *q = p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>while (cin &gt;&gt; s &amp;&amp; q != p + n)<br class="calibre6"/>&#160;&#160;&#160;&#160;*q++ = s;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assign a new value to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*q</span></span></tt></span><br class="calibre6"/>const size_t size = q - p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remember how many</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s we read</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">use the array</span></span></span><br class="calibre6"/>delete[] p;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an array; must remember to use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">delete[]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression allocates and initializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">n string</span></tt></code>s. However, we might not need <code class="calibre23"><tt class="calibre23"><span class="calibre24">n string</span></tt></code>s; a smaller number might suffice. As a result, we may have created objects that are never used. Moreover, for those objects we do use, we immediately assign new values over the previously initialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. The elements that are used are written twice: first when the elements are default initialized, and subsequently when we assign to them.</p><div class="calibre15">&#160;</div>
<p class="calibre25">More importantly, classes that do not have default constructors cannot be dynamically allocated as an array.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">allocator</span></span></tt></span></span></tt></code> Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The library <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos3124364" href="118-defined_terms.html#filepos3186396">allocator</a></span></span></tt></span></span></tt></code> class, which is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">memory</span></tt></code> header, lets us separate allocation from construction. It provides type-aware allocation of raw, unconstructed, memory. <a href="115-12.2._dynamic_arrays.html#filepos3125184">Table 12.7</a> (overleaf) outlines the operations that <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> supports. In this section, we&#8217;ll describe the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> operations. In &#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a> (p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">524</a>), we&#8217;ll see an example of how this class is typically used.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3125184"/>Table 12.7. Standard <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">allocator</span></span></tt></span></span></tt></code> Class and Customized Algorithms</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00095.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> is a template (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). To define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> we must specify the type of objects that a particular <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> can allocate. When an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">allocator&lt;string&gt; alloc;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">object that can allocate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>auto const p = alloc.allocate(n); // <span><span class="calibre45"><span class="calibre16">allocate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">unconstructed</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code> allocates memory for <code class="calibre23"><tt class="calibre23"><span class="calibre24">n string</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos3127513"/><code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">allocator</span></span></tt></span></span></tt></code>s Allocate Unconstructed Memory</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The memory an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> allocates is <em class="calibre16">unconstructed.</em> We use this memory by constructing objects in that memory. In the new library the <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> member takes a pointer and zero or more additional arguments; it constructs an element at the given location. The additional arguments are used to initialize the object being constructed. Like the arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">451</a>), these additional arguments must be valid initializers for an object of the type being constructed. In particular, if the, object is a class type, these arguments must match a constructor for that class:</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos3128651"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto q = p; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will point to one past the last constructed element</span></span></span><br class="calibre6"/>alloc.construct(q++);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the empty string</span></span></span><br class="calibre6"/>alloc.construct(q++, 10, 'c');&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cccccccccc</span></span></tt></span><br class="calibre6"/>alloc.construct(q++, "hi");&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hi!</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In earlier versions of the library, <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> took only two arguments: the pointer at which to construct an object and a value of the element type. As a result, we could only copy an element into unconstructed space, we could not use any other constructor for the element type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is an error to use raw memory in which an object has not been constructed:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; *p &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">ok: uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">output operator</span></span></span><br class="calibre6"/>cout &lt;&lt; *q &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">disaster:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">q</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to unconstructed memory!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We must <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> objects in order to use memory returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code>. Using unconstructed memory in other ways is undefined.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">When we&#8217;re finished using the objects, we must destroy the elements we constructed, which we do by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> on each constructed element. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> function takes a pointer and runs the destructor (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>) on the pointed-to object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3132501"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">while (q != p)<br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.destroy(--q);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">we actually allocated</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">At the beginning of our loop, <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> points one past the last constructed element. We decrement <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> before calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code>. Thus, on the first call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy, q</span></tt></code> points to the last constructed element. We <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> the first element in the last iteration, after which <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code> will equal <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> and the loop ends.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We may <code class="calibre23"><tt class="calibre23"><span class="calibre24">destroy</span></tt></code> only elements that are actually constructed.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Once the elements have been destroyed, we can either reuse the memory to hold other <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s or return the memory to the system. We free the memory by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code>:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">alloc.deallocate(p, n);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The pointer we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code> cannot be null; it must point to memory allocated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code>. Moreover, the size argument passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">deallocate</span></tt></code> must be the same size as used in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocate</span></tt></code> that obtained the memory to which the pointer points.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Algorithms to Copy and Fill Uninitialized Memory</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As a companion to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code> class, the library also defines two algorithms that can construct objects in uninitialized memory. These functions, described in <a href="115-12.2._dynamic_arrays.html#filepos3136090">Table 12.8</a>, are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">memory</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3136090"/>Table 12.8. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">allocator</span></span></tt></span></span></tt></code> Algorithms</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00096.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, assume we have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s that we want to copy into dynamic memory. We&#8217;ll allocate memory for twice as many <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s as are in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. We&#8217;ll construct the first half of the newly allocated memory by copying elements from the original <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. We&#8217;ll construct elements in the second half by filling them with a given value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3137157"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">allocate twice as many elements as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds</span></span></span><br class="calibre6"/>auto p = alloc.allocate(vi.size() * 2);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">construct elements starting at</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as copies of elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span><br class="calibre6"/>auto q = uninitialized_copy(vi.begin(), vi.end(), p);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">initialize the remaining elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><br class="calibre6"/>uninitialized_fill_n(q, vi.size(), 42);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Like the <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code> algorithm (&#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">10.2.2</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">382</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> takes three iterators. The first two denote an input sequence and the third denotes the destination into which those elements will be copied. The destination iterator passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> must denote unconstructed memory. Unlike <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> constructs elements in its destination.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">copy</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> returns its (incremented) destination iterator. Thus, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_copy</span></tt></code> returns a pointer positioned one element past the last constructed element. In this example, we store that pointer in <code class="calibre23"><tt class="calibre23"><span class="calibre24">q</span></tt></code>, which we pass to <code class="calibre23"><tt class="calibre23"><span class="calibre24">uninitialized_fill_n</span></tt></code>. This function, like <code class="calibre23"><tt class="calibre23"><span class="calibre24">fill_n</span></tt></code> (&#167; <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">10.2.2</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">380</a>), takes a pointer to a destination, a count, and a value. It will construct the given number of objects from the given value at locations starting at the given destination.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 12.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 12.26:</strong> Rewrite the program on page <a href="115-12.2._dynamic_arrays.html#filepos3119556">481</a> using an <code class="calibre23"><tt class="calibre23"><span class="calibre24">allocator</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="114-12.1._dynamic_memory_and_smart_pointers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="116-12.3._using_the_library_a_textquery_program.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
