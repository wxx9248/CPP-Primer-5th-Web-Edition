<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>18.1. Exception Handling</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="170-chapter_18._tools_for_large_programs.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="172-18.2._namespaces.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4855328" class="calibre29"><span class="bold">18.1. Exception Handling</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos4855463" href="175-defined_terms.html#filepos5107360">Exception handling</a></strong> allows independently developed parts of a program to communicate about and handle problems that arise at run time. Exceptions let us separate problem detection from problem resolution. One part of the program can detect a problem and can pass the job of resolving that problem to another part of the program. The detecting part need not know anything about the handling part, and vice versa.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In &#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a> (p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>) we introduced the basic concepts and mechanics of using exceptions. In this section we&#8217;ll expand our coverage of these basics. Effective use of exception handling requires understanding what happens when an exception is thrown, what happens when it is caught, and the meaning of the objects that communicate what went wrong.</p><div class="calibre22">&#160;</div>
<h4 id="filepos4856427" class="calibre37"><span class="calibre5">18.1.1. Throwing an Exception</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In C++, an exception is <strong class="calibre5"><a id="filepos4856590" href="175-defined_terms.html#filepos5114981">raised</a></strong> by <strong class="calibre5">throwing</strong> an expression. The type of the thrown expression, together with the current call chain, determines which <strong class="calibre5"><a id="filepos4856792" href="175-defined_terms.html#filepos5110121">handler</a></strong> will deal with the exception. The selected handler is the one nearest in the call chain that matches the type of the thrown object. The type and contents of that object allow the throwing part of the program to inform the handling part about what went wrong.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> is executed, the statement(s) following the <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> are not executed. Instead, control is transferred from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> to the matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>. That <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> might be local to the same function or might be in a function that directly or indirectly called the function in which the exception occurred. The fact that control passes from one location to another has two important implications:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Functions along the call chain may be prematurely exited.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; When a handler is entered, objects created along the call chain will have been destroyed.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Because the statements following a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> are not executed, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> is like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">return:</span></tt></code> It is usually part of a conditional statement or is the last (or only) statement in a function.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4858722"/>Stack Unwinding</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When an exception is thrown, execution of the current function is suspended and the search for a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clause begins. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> appears inside a <a id="filepos4859097" href="175-defined_terms.html#filepos5117274"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">try</span></span></tt></span></span></tt></code>
<strong class="calibre5">block</strong></a>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses associated with that <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> are examined. If a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, the exception is handled by that <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>. Otherwise, if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> was itself nested inside another <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code>, the search continues through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses of the enclosing <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code>s. If no matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, the current function is exited, and the search continues in the calling function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If the call to the function that threw is in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses associated with that <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> are examined. If a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, the exception is handled. Otherwise, if that <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> was nested, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses of the enclosing <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code>s are searched. If no catch is found, the calling function is also exited. The search continues in the function that called the just exited one, and so on.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This process, known as <strong class="calibre5"><a id="filepos4861240" href="175-defined_terms.html#filepos5115865">stack unwinding</a></strong>, continues up the chain of nested function calls until a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clause for the exception is found, or the <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function itself is exited without having found a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Assuming a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, that <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is entered, and the program continues by executing the code inside that <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>. When the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> completes, execution continues at the point immediately after the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clause associated with that <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If no matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, the program is exited. Exceptions are intended for events that prevent the program from continuing normally. Therefore, once an exception is raised, it cannot remain unhandled. If no matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is found, the program calls the library <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos4862918" href="175-defined_terms.html#filepos5116342">terminate</a></span></span></tt></span></span></tt></code> function. As its name implies, <code class="calibre23"><tt class="calibre23"><span class="calibre24">terminate</span></tt></code> stops execution of the program.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">An exception that is not caught terminates the program.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Objects Are Automatically Destroyed during Stack Unwinding</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">During stack unwinding, blocks in the call chain may be exited prematurely. In general, these blocks will have created local objects. Ordinarily, local objects are destroyed when the block in which they are created is exited. Stack unwinding is no exception. When a block is exited during stack unwinding, the compiler guarantees that objects created in that block are properly destroyed. If a local object is of class type, the destructor for that object is called automatically. As usual, the compiler does no work to destroy objects of built-in type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If an exception occurs in a constructor, then the object under construction might be only partially constructed. Some of its members might have been initialized, but others might not have been initialized before the exception occurred. Even if the object is only partially constructed, we are guaranteed that the constructed members will be properly destroyed.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Similarly, an exception might occur during initialization of the elements of an array or a library container type. Again, we are guaranteed that the elements (if any) that were constructed before the exception occurred will be destroyed.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos4865062"/>Destructors and Exceptions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The fact that destructors are run&#8212;but code inside a function that frees a resource may be bypassed&#8212;affects how we structure our programs. As we saw in &#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">467</a>), if a block allocates a resource, and an exception occurs before the code that frees that resource, the code to free the resource will not be executed. On the other hand, resources allocated by an object of class type generally will be freed by their destructor. By using classes to control resource allocation, we ensure that resources are properly freed, whether a function ends normally or via an exception.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fact that destructors are run during stack unwinding affects how we write destructors. During stack unwinding, an exception has been raised but is not yet handled. If a new exception is thrown during stack unwinding and not caught in the function that threw it, <code class="calibre23"><tt class="calibre23"><span class="calibre24">terminate</span></tt></code> is called. Because destructors may be invoked during stack unwinding, they should never throw exceptions that the destructor itself does not handle. That is, if a destructor does an operation that might throw, it should wrap that operation in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block and handle it locally to the destructor.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In practice, because destructors free resources, it is unlikely that they will throw exceptions. All of the standard library types guarantee that their destructors will not raise an exception.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">During stack unwinding, destructors are run on local objects of class type. Because destructors are run automatically, they should not throw. If, during stack unwinding, a destructor throws an exception that it does not also catch, the program will be terminated.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Exception Object</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The compiler uses the thrown expression to copy initialize (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>) a special object known as the <strong class="calibre5"><a id="filepos4867759" href="175-defined_terms.html#filepos5108038">exception object</a></strong>. As a result, the expression in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> must have a complete type (&#167; <a href="075-7.3._additional_class_features.html#filepos1897012">7.3.3</a>, p. <a href="075-7.3._additional_class_features.html#filepos1897012">278</a>). Moreover, if the expression has class type, that class must have an accessible destructor and an accessible copy or move constructor. If the expression has an array or function type, the expression is converted to its corresponding pointer type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The exception object resides in space, managed by the compiler, that is guaranteed to be accessible to whatever <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is invoked. The exception object is destroyed after the exception is completely handled.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, when an exception is thrown, blocks along the call chain are exited until a matching handler is found. When a block is exited, the memory used by the local objects in that block is freed. As a result, it is almost certainly an error to throw a pointer to a local object. It is an error for the same reasons that it is an error to return a pointer to a local object (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">225</a>) from a function. If the pointer points to an object in a block that is exited before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>, then that local object will have been destroyed before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">When we throw an expression, the static, compile-time type (&#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>) of that expression determines the type of the exception object. This point is essential to keep in mind, because many applications throw expressions whose type comes <a id="filepos4869804"/>from an inheritance hierarchy. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> expression dereferences a pointer to a base-class type, and that pointer points to a derived-type object, then the thrown object is sliced down (&#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>); only the base-class part is thrown.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Throwing a pointer requires that the object to which the pointer points exist wherever the corresponding handler resides.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.1.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.1:</strong> What is the type of the exception object in the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code>s?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">range_error r("error");</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">throw r;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">exception *p = &amp;r;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">throw *p;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">What would happen if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> in (b) were written as <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw p</span></tt></code>?</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.2:</strong> Explain what happens if an exception occurs at the indicated point:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void exercise(int *b, int *e)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;vector&lt;int&gt; v(b, e);<br class="calibre6"/>&#160;&#160;&#160;&#160;int *p = new int[v.size()];<br class="calibre6"/>&#160;&#160;&#160;&#160;ifstream in("ints");<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">exception occurs here</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.3:</strong> There are two ways to make the previous code work correctly if an exception is thrown. Describe them and implement them.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4873158" class="calibre37"><span class="calibre5">18.1.2. Catching an Exception</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <strong class="calibre5"><a id="filepos4873301" href="175-defined_terms.html#filepos5106683">exception declaration</a></strong> in a <a id="filepos4873381" href="175-defined_terms.html#filepos5105424"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">catch</span></span></tt></span></span></tt></code>
<strong class="calibre5">clause</strong></a> looks like a function parameter list with exactly one parameter. As in a parameter list, we can omit the name of the catch parameter if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> has no need to access the thrown expression.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The type of the declaration determines what kinds of exceptions the handler can catch. The type must be a complete type (&#167; <a href="075-7.3._additional_class_features.html#filepos1897012">7.3.3</a>, p. <a href="075-7.3._additional_class_features.html#filepos1897012">278</a>). The type can be an lvalue reference but may not be an rvalue reference (&#167; <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">When a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is entered, the parameter in its exception declaration is initialized by the exception object. As with function parameters, if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> parameter has a nonreference type, then the parameter in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is a copy of the exception object; changes made to the parameter inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> are made to a local copy, not to the exception object itself. If the parameter has a reference type, then like any reference parameter, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> parameter is just another name for the exception object. Changes made to the parameter are made to the exception object.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Also like a function parameter, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> parameter that has a base-class type can be initialized by an exception object that has a type derived from the parameter type. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> parameter has a nonreference type, then the exception object <a id="filepos4875631"/>will be sliced down (&#167; <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>), just as it would be if such an object were passed to an ordinary function by value. On the other hand, if the parameter is a reference to a base-class type, then the parameter is bound to the exception object in the usual way.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Again, as with a function parameter, the static type of the exception declaration determines the actions that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> may perform. If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> parameter has a base-class type, then the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> cannot use any members that are unique to the derived type.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Ordinarily, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> that takes an exception of a type related by inheritance ought to define its parameter as a reference.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Finding a Matching Handler</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">During the search for a matching <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> that is found is not necessarily the one that matches the exception best. Instead, the selected <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> is the <em class="calibre16">first</em> one that matches the exception at all. As a consequence, in a list of <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses, the most specialized <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> must appear first.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses are matched in the order in which they appear, programs that use exceptions from an inheritance hierarchy must order their <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses so that handlers for a derived type occur before a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> for its base type.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The rules for when an exception matches a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> exception declaration are much more restrictive than the rules used for matching arguments with parameter types. Most conversions are not allowed&#8212;the types of the exception and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> declaration must match exactly with only a few possible differences:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Conversions from non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> are allowed. That is, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> of a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object can match a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> specified to take a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Conversions from derived type to base type are allowed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; An array is converted to a pointer to the type of the array; a function is converted to the appropriate pointer to function type.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">No other conversions are allowed to match a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>. In particular, neither the standard arithmetic conversions nor conversions defined for class types are permitted.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Multiple <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses with types related by inheritance must be ordered from most derived type to least derived.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Rethrow</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes a single <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> cannot completely handle an exception. After some corrective actions, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> may decide that the exception must be handled by a function further up the call chain. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> passes its exception out to another <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> by <strong class="calibre5"><a id="filepos4881200" href="175-defined_terms.html#filepos5115285">rethrowing</a></strong> the exception. A rethrow is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> that is not followed by an expression:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">throw;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4881607"/>An empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> can appear only in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> or in a function called (directly or indirectly) from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>. If an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> is encountered when a handler is not active, <code class="calibre23"><tt class="calibre23"><span class="calibre24">terminate</span></tt></code> is called.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A rethrow does not specify an expression; the (current) exception object is passed up the chain.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In general, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> might change the contents of its parameter. If, after changing its parameter, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> rethrows the exception, then those changes will be propagated only if the <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code>&#8217;s exception declaration is a reference:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">catch (my_error &amp;eObj) {&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">specifier is a reference type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;eObj.status = errCodes::severeErr; // <span><span class="calibre45"><span class="calibre16">modifies the exception object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;throw; // <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">status</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of the exception object is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">severeErr</span></span></tt></span><br class="calibre6"/>} catch (other_error eObj) { // <span><span class="calibre45"><span class="calibre16">specifier is a nonreference type</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;eObj.status = errCodes::badErr;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">modifies the local copy only</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;throw; // <span><span class="calibre45"><span class="calibre16">the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">status</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">member of the exception object is unchanged</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Catch-All Handler</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes we want to catch any exception that might occur, regardless of type. Catching every possible exception can be a problem: Sometimes we don&#8217;t know what types might be thrown. Even when we do know all the types, it may be tedious to provide a specific <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clause for every possible exception. To catch all exceptions, we use an ellipsis for the exception declaration. Such handlers, sometimes known as <strong class="calibre5"><a id="filepos4884962" href="175-defined_terms.html#filepos5104804">catch-all</a></strong> handlers, have the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(...)</span></tt></code>. A catch-all clause matches any type of exception.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(...)</span></tt></code> is often used in combination with a rethrow expression. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> does whatever local work can be done and then rethrows the exception:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void manip() {<br class="calibre6"/>&#160;&#160;&#160;&#160;try {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">actions that cause an exception to be thrown</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;catch (...) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">work to partially handle the exception</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(...)</span></tt></code> clause can be used by itself or as one of several <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(...)</span></tt></code> is used in combination with other <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses, it must be last. Any <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> that follows a catch-all can never be matched.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4887288" class="calibre37"><span class="calibre5">18.1.3. Function <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">try</span></span></tt></span></span></tt></code> Blocks and Constructors</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In general, exceptions can occur at any point in the program&#8217;s execution. In particular, an exception might occur while processing a constructor initializer. Constructor initializers execute before the constructor body is entered. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> inside <a id="filepos4887878"/>the constructor body can&#8217;t handle an exception thrown by a constructor initializer because a <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block inside the constructor body would not yet be in effect when the exception is thrown.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.4:</strong> Looking ahead to the inheritance hierarchy in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a> (p. <a href="171-18.1._exception_handling.html#filepos4889339">783</a>), explain what&#8217;s wrong with the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block. Correct it.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">try {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use of the C++ standard library</span></span></span><br class="calibre6"/>} catch(exception) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>} catch(const runtime_error &amp;re) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// ...<br class="calibre6"/>} catch(overflow_error eobj) { /* ... */ }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre52"><a id="filepos4889339"/><img alt="Image" src="images/00132.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 18.1. Standard <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">exception</span></span></tt></span></span></tt></code> Class Hierarchy</span></p><div class="calibre12">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.5:</strong> Modify the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code> function to catch any of the exception types shown in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a> (p. <a href="171-18.1._exception_handling.html#filepos4889339">783</a>):</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use of the C++ standard library</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The handlers should print the error message associated with the exception before calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">abort</span></tt></code> (defined in the header <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstdlib</span></tt></code>) to terminate <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>.</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.6:</strong> Given the following exception types and <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses, write a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> expression that creates an exception object that can be caught by each <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clause:</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">class exceptionType { };</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(exceptionType *pet) { }</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(...) { }</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef int EXCPTYPE;</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">catch(EXCPTYPE) { }</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">To handle an exception from a constructor initializer, we must write the constructor as a <a id="filepos4892438" href="175-defined_terms.html#filepos5109234"><strong class="calibre5">function</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">try</span></span></tt></span></span></tt></code>
<strong class="calibre5">block</strong></a>. A function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block lets us associate a group of <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> clauses with the initialization phase of a constructor (or the destruction phase of a destructor) as well as with the constructor&#8217;s (or destructor&#8217;s) function body. As an example, we might wrap the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> constructors (&#167; <a href="154-16.1._defining_a_template.html#filepos4193169">16.1.2</a>, p. <a href="154-16.1._defining_a_template.html#filepos4193169">662</a>) in a function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt;<br class="calibre6"/>Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) try :<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/* <span><span class="calibre45"><span class="calibre16">empty body</span></span></span> */<br class="calibre6"/>} catch(const std::bad_alloc &amp;e) { handle_out_of_memory(e); }</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Notice that the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> appears before the colon that begins the constructor initializer list and before the curly brace that forms the (in this case empty) constructor function body. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">catch</span></tt></code> associated with this <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> can be used to handle <a id="filepos4894536"/>exceptions thrown either from within the member initialization list or from within the constructor body.</p><div class="calibre15">&#160;</div>
<p class="calibre25">It is worth noting that an exception can happen while initializing the constructor&#8217;s parameters. Such exceptions are <em class="calibre16">not</em> part of the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block. The function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block handles only exceptions that occur once the constructor begins executing. As with any other function call, if an exception occurs during parameter initialization, that exception is part of the calling expression and is handled in the caller&#8217;s context.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The only way for a constructor to handle an exception from a constructor initializer is to write the constructor as a function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> block.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.1.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.7:</strong> Define your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Blob</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">BlobPtr</span></tt></code> classes from <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a> to use function <code class="calibre23"><tt class="calibre23"><span class="calibre24">try</span></tt></code> blocks for their constructors.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4896504" class="calibre37"><span class="calibre5">18.1.4. The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">noexcept</span></span></tt></span></span></tt></code> Exception Specification</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">It can be helpful both to users and to the compiler to know that a function will not throw any exceptions. Knowing that a function will not throw simplifies the task of writing code that calls that function. Moreover, if the compiler knows that no exceptions will be thrown, it can (sometimes) perform optimizations that must be suppressed if code might throw.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4897184"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Under the new standard, a function can specify that it does not throw exceptions by providing a <a id="filepos4897368" href="175-defined_terms.html#filepos5113452"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">noexcept</span></span></tt></span></span></tt></code>
<strong class="calibre5">specification</strong></a>. The keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> following the function parameter list indicates that the function won&#8217;t throw:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void recoup(int) noexcept;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">won't throw</span></span></span><br class="calibre6"/>void alloc(int);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">might throw</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These declarations say that <code class="calibre23"><tt class="calibre23"><span class="calibre24">recoup</span></tt></code> will not throw any exceptions and that <code class="calibre23"><tt class="calibre23"><span class="calibre24">alloc</span></tt></code> might. We say that <code class="calibre23"><tt class="calibre23"><span class="calibre24">recoup</span></tt></code> has a <strong class="calibre5"><a id="filepos4898708" href="175-defined_terms.html#filepos5114294">nonthrowing specification</a></strong>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier must appear on all of the declarations and the corresponding definition of a function or on none of them. The specifier precedes a trailing return (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>). We may also specify <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> on the declaration and definition of a function pointer. It may not appear in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">typedef</span></tt></code> or type alias. In a member function the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier follows any <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> or reference qualifiers, and it precedes <code class="calibre23"><tt class="calibre23"><span class="calibre24">final, override</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">= 0</span></tt></code> on a virtual function.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Violating the Exception Specification</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">It is important to understand that the compiler does not check the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specification at compile time. In fact, the compiler is not permitted to reject a function with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier merely because it contains a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> or calls a function that might throw (however, kind compilers will warn about such usages):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4900567"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">this function will compile, even though it clearly violates its exception specification</span></span></span><br class="calibre6"/>void f() noexcept&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">promises not to throw any exception</span></span></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;throw exception();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">violates the exception specification</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">As a result, it is possible that a function that claims it will not throw will in fact throw. If a <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> function does throw, <code class="calibre23"><tt class="calibre23"><span class="calibre24">terminate</span></tt></code> is called, thereby enforcing the promise not to throw at run time. It is unspecified whether the stack is unwound. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> should be used in two cases: if we are confident that the function won&#8217;t throw, and/or if we don&#8217;t know what we&#8217;d do to handle the error anyway.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Specifying that a function won&#8217;t throw effectively promises the <em class="calibre16">callers</em> of the nonthrowing function that they will never need to deal with exceptions. Either the function won&#8217;t throw, or the whole program will terminate; the caller escapes responsibility either way.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The compiler in general cannot, and does not, verify exception specifications at compile time.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Backward Compatibility: Exception Specifications</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Earlier versions of C++ had a more elaborate scheme of exception specifications that allowed us to specify the types of exceptions that a function might throw. A function can specify the keyword <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> followed by a parenthesized list of types that the function might throw. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code> specifier appeared in the same place as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier does in the current language.</p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">This approach was never widely used and has been deprecated in the current standard. Although these more elaborate specifiers have been deprecated, there is one use of the old scheme that is in widespread use. A function that is designated by <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw()</span></tt></code> promises not to throw any exceptions:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void recoup(int) noexcept;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">recoup</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">doesn't throw</span></span></span><br class="calibre6"/>void recoup(int) throw();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent declaration</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">These declarations of <code class="calibre23"><tt class="calibre23"><span class="calibre24">recoup</span></tt></code> are equivalent. Both say that <code class="calibre23"><tt class="calibre23"><span class="calibre24">recoup</span></tt></code> won&#8217;t throw.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Arguments to the <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">noexcept</span></span></tt></span></span></tt></code> Specification</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier takes an optional argument that must be convertible to <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool:</span></tt></code> If the argument is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>, then the function won&#8217;t throw; if the argument is <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>, then the function might throw:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void recoup(int) noexcept(true);&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">recoup</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">won't throw</span></span></span><br class="calibre6"/>void alloc(int) noexcept(false);&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alloc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">can throw</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">noexcept</span></span></tt></span></span></tt></code> Operator</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos4906788"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Arguments to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier are often composed using the <a id="filepos4907003" href="175-defined_terms.html#filepos5112716"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">noexcept</span></span></tt></span></span></tt></code>
<strong class="calibre5">operator</strong></a>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> operator is a unary operator that returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> rvalue <a id="filepos4907407"/>constant expression that indicates whether a given expression might throw. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof</span></tt></code> (&#167; <a href="047-4.9._the_sizeof_operator.html#filepos1142429">4.9</a>, p. <a href="047-4.9._the_sizeof_operator.html#filepos1142429">156</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> does not evaluate its operand.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, this expression yields <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">noexcept(recoup(i)) // true <span><span class="calibre45"><span class="calibre16">if calling</span></span></span> recoup <span><span class="calibre45"><span class="calibre16">can't throw</span></span></span>, false <span><span class="calibre45"><span class="calibre16">otherwise</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">because we declared <code class="calibre23"><tt class="calibre23"><span class="calibre24">recoup</span></tt></code> with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier. More generally,</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">noexcept(e)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if all the functions called by <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> have nonthrowing specifications and <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code> itself does not contain a <code class="calibre23"><tt class="calibre23"><span class="calibre24">throw</span></tt></code>. Otherwise, <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept(e)</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> operator to form an exception specifier as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void f() noexcept(noexcept(g())); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">f</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has same exception specifier as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">g</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the function <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> promises not to throw, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> also is nonthrowing. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">g</span></tt></code> has no exception specifier, or has an exception specifier that allows exceptions, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">f</span></tt></code> also might throw.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> has two meanings: It is an exception specifier when it follows a function&#8217;s parameter list, and it is an operator that is often used as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> argument to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> exception specifier.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Exception Specifications and Pointers, Virtuals, and Copy Control</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Although the <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code> specifier is not part of a function&#8217;s type, whether a function has an exception specification affects the use of that function.</p><div class="calibre15">&#160;</div>
<p class="calibre25">A pointer to function and the function to which that pointer points must have compatible specifications. That is, if we declare a pointer that has a nonthrowing exception specification, we can use that pointer only to point to similarly qualified functions. A pointer that specifies (explicitly or implicitly) that it might throw can point to any function, even if that function includes a promise not to throw:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">recoup</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">promise not to throw</span></span></span><br class="calibre6"/>void (*pf1)(int) noexcept = recoup;<br class="calibre6"/><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">recoup</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">won't throw; it doesn't matter that pf2 might</span></span></span><br class="calibre6"/>void (*pf2)(int) = recoup;<br class="calibre6"/><br class="calibre6"/>pf1 = alloc; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">alloc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">might throw but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pf1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">said it wouldn't</span></span></span><br class="calibre6"/>pf2 = alloc; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ok: both pf2 and alloc might throw</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">If a virtual function includes a promise not to throw, the inherited virtuals must also promise not to throw. On the other hand, if the base allows exceptions, it is okay for the derived functions to be more restrictive and promise not to throw:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;virtual double f1(double) noexcept; // <span><span class="calibre45"><span class="calibre16">doesn't throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual int f2() noexcept(false);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">can throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;virtual void f3();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">can throw</span></span></span><br class="calibre6"/>};<br class="calibre6"/><br class="calibre6"/><a id="filepos4914987"/>class Derived : public Base {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;double f1(double);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::f1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">promises not to throw</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;int f2() noexcept(false); // <span><span class="calibre45"><span class="calibre16">ok: same specification as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Base::f2</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;void f3() noexcept;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Derived f3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is more restrictive</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">When the compiler synthesizes the copy-control members, it generates an exception specification for the synthesized member. If all the corresponding operation for all the members and base classes promise not to throw, then the synthesized member is <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept</span></tt></code>. If any function invoked by the synthesized member can throw, then the synthesized member is <code class="calibre23"><tt class="calibre23"><span class="calibre24">noexcept(false)</span></tt></code>. Moreover, if we do not provide an exception specification for a destructor that we do define, the compiler synthesizes one for us. The compiler generates the same specification as it would have generated had it synthesized the destructor for that class.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.1.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.8:</strong> Review the classes you&#8217;ve written and add appropriate exception specifications to their constructors and destructors. If you think one of your destructors might throw, change the code so that it cannot throw.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4917333" class="calibre37"><span class="calibre5">18.1.5. Exception Class Hierarchies</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The standard-library exception classes (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1391364">5.6.3</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1391364">197</a>) form the inheritance hierarchy (<a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a>) as shown in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The only operations that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code> types define are the copy constructor, copy-assignment operator, a virtual destructor, and a virtual member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> function returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code> that points to a null-terminated character array, and is guaranteed not to throw any exceptions.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_cast</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad_alloc</span></tt></code> classes also define a default constructor. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">runtime_error</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">logic_error</span></tt></code> classes do not have a default constructor but do have constructors that take a C-style character string or a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. Those arguments are intended to give additional information about the error. In these classes, <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> returns the message used to initialize the exception object. Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> is virtual, if we catch a reference to the base-type, a call to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> function will execute the version appropriate to the dynamic type of the exception object.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Exception Classes for a Bookstore Application</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Applications often extend the <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code> hierarchy by defining classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code> (or from one of the library classes derived from <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code>). These application-specific classes represent exceptional conditions specific to the application domain.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos4920228"/>If we were building a real bookstore application, our classes would have been much more complicated than the ones presented in this Primer. One such complexity would be how these classes handled exceptions. In fact, we probably would have defined our own hierarchy of exceptions to represent application-specific problems. Our design might include classes such as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">hypothetical exception classes for a bookstore application</span></span></span><br class="calibre6"/>class out_of_stock: public std::runtime_error {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;explicit out_of_stock(const std::string &amp;s):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::runtime_error(s) { }<br class="calibre6"/>};<br class="calibre6"/>class isbn_mismatch: public std::logic_error {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;explicit isbn_mismatch(const std::string &amp;s):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::logic_error(s) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;isbn_mismatch(const std::string &amp;s,<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const std::string &amp;lhs, const std::string &amp;rhs):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;std::logic_error(s), left(lhs), right(rhs) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;const std::string left, right;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our application-specific exception types inherit them from the standard exception classes. As with any hierarchy, we can think of the exception classes as being <a id="filepos4922219"/>organized into layers. As the hierarchy becomes deeper, each layer becomes a more specific exception. For example, the first and most general layer of the hierarchy is represented by class <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code>. All we know when we catch an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code> is that something has gone wrong.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The second layer specializes <code class="calibre23"><tt class="calibre23"><span class="calibre24">exception</span></tt></code> into two broad categories: run-time or logic errors. Run-time errors represent things that can be detected only when the program is executing. Logic errors are, in principle, errors that we could have detected in our application.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our bookstore exception classes further refine these categories. The class named <code class="calibre23"><tt class="calibre23"><span class="calibre24">out_of_stock</span></tt></code> represents something, particular to our application, that can go wrong at run time. It would be used to signal that an order cannot be fulfilled. The class <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn_mismatch</span></tt></code> represents a more particular form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">logic_error</span></tt></code>. In principle, a program could prevent and handle this error by comparing the results of <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn()</span></tt></code> on the objects.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using Our Own Exception Types</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We use our own exception classes in the same way that we use one of the standard library classes. One part of the program throws an object of one of these types, and another part catches and handles the indicated problem. As an example, we might define the compound addition operator for our <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> class to throw an error of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">isbn_mismatch</span></tt></code> if it detected that the <small class="calibre48">ISBN</small>s didn&#8217;t match:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">throws an exception if both objects do not refer to the same book</span></span></span><br class="calibre6"/>Sales_data&amp;<br class="calibre6"/>Sales_data::operator+=(const Sales_data&amp; rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (isbn() != rhs.isbn())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw isbn_mismatch("wrong isbns", isbn(), rhs.isbn());<br class="calibre6"/>&#160;&#160;&#160;&#160;units_sold += rhs.units_sold;<br class="calibre6"/>&#160;&#160;&#160;&#160;revenue += rhs.revenue;<br class="calibre6"/>&#160;&#160;&#160;&#160;return&#160;*this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Code that uses the compound addition operator (or ordinary addition operator, which itself uses the compound addition operator) can detect this error, write an appropriate error message, and continue:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">use the hypothetical bookstore exceptions</span></span></span><br class="calibre6"/>Sales_data item1, item2, sum;<br class="calibre6"/>while (cin &gt;&gt; item1 &gt;&gt; item2) {&#160;&#160;// <span><span class="calibre45"><span class="calibre16">read two transactions</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;try {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum = item1 + item2;&#160;&#160;&#160;&#160;&#160;//<span><span class="calibre45"><span class="calibre16">&#160;&#160;calculate their sum</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;} catch (const isbn_mismatch &amp;e) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;cerr &lt;&lt; e.what() &lt;&lt; ": left isbn(" &lt;&lt; e.left<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&lt; ") right isbn(" &lt;&lt; e.right &lt;&lt; ")" &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4926967"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 18.1.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.9:</strong> Define the bookstore exception classes described in this section and rewrite your <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> compound assigment operator to throw an exception.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.10:</strong> Write a program that uses the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> addition operator on objects that have differing <small class="calibre48">ISBN</small>s. Write two versions of the program: one that handles the exception and one that does not. Compare the behavior of the programs so that you become familiar with what happens when an uncaught exception occurs.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 18.11:</strong> Why is it important that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">what</span></tt></code> function doesn&#8217;t throw?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="170-chapter_18._tools_for_large_programs.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="172-18.2._namespaces.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
