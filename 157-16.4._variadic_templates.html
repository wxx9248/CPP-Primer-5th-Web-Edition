<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>16.4. Variadic Templates</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="156-16.3._overloading_and_templates.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="158-16.5._template_specializations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4464798" class="calibre29"><span class="bold">16.4. Variadic Templates</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<div class="calibre28"><a id="filepos4464966"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">A <strong class="calibre5"><a id="filepos4465063" href="160-defined_terms.html#filepos4557750">variadic template</a></strong> is a template function or class that can take a varying number of parameters. The varying parameters are known as a <strong class="calibre5"><a id="filepos4465258" href="160-defined_terms.html#filepos4553506">parameter pack</a></strong>. There are two kinds of parameter packs: A <strong class="calibre5"><a id="filepos4465377" href="160-defined_terms.html#filepos4556149">template parameter pack</a></strong> represents zero or <a id="filepos4465473"/>more template parameters, and a <strong class="calibre5"><a id="filepos4465521" href="160-defined_terms.html#filepos4551081">function parameter pack</a></strong> represents zero or more function parameters.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We use an ellipsis to indicate that a template or function parameter represents a pack. In a template parameter list, <code class="calibre23"><tt class="calibre23"><span class="calibre24">class...</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">typename...</span></tt></code> indicates that the following parameter represents a list of zero or more types; the name of a type followed by an ellipsis represents a list of zero or more nontype parameters of the given type. In the function parameter list, a parameter whose type is a template parameter pack is a function parameter pack. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Args</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a template parameter pack;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rest</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a function parameter pack</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Args</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">represents zero or more template type parameters</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rest</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">represents zero or more function parameters</span></span></span><br class="calibre6"/>template &lt;typename T, typename... Args&gt;<br class="calibre6"/>void foo(const T &amp;t, const Args&amp; ... rest);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">declares that <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code> is a variadic function that has one type parameter named <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> and a template parameter pack named <code class="calibre23"><tt class="calibre23"><span class="calibre24">Args</span></tt></code>. That pack represents zero or more additional type parameters. The function parameter list of <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code> has one parameter, whose type is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const &amp;</span></tt></code> to whatever type <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> has, and a function parameter pack named <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code>. That pack represents zero or more function parameters.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As usual, the compiler deduces the template parameter types from the function&#8217;s arguments. For a variadic template, the compiler also deduces the number of parameters in the pack. For example, given these calls:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0; double d = 3.14; string s = "how now brown cow";<br class="calibre6"/>foo(i, s, 42, d);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">three parameters in the pack</span></span></span><br class="calibre6"/>foo(s, 42, "hi");&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">two parameters in the pack</span></span></span><br class="calibre6"/>foo(d, s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">one parameter in the pack</span></span></span><br class="calibre6"/>foo("hi");&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">empty pack</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the compiler will instantiate four different instances of <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void foo(const int&amp;, const string&amp;, const int&amp;, const double&amp;);<br class="calibre6"/>void foo(const string&amp;, const int&amp;, const char[3]&amp;);<br class="calibre6"/>void foo(const double&amp;, const string&amp;);<br class="calibre6"/>void foo(const char[3]&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In each case, the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> is deduced from the type of the first argument. The remaining arguments (if any) provide the number of, and types for, the additional arguments to the function.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">sizeof...</span></span></tt></span></span></tt></code> Operator</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos4470813"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">When we need to know how many elements there are in a pack, we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof...</span></tt></code> operator. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof</span></tt></code> (&#167; <a href="047-4.9._the_sizeof_operator.html#filepos1142429">4.9</a>, p. <a href="047-4.9._the_sizeof_operator.html#filepos1142429">156</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof...</span></tt></code> returns a constant expression (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>) and does not evaluate its argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template&lt;typename ... Args&gt; void g(Args ... args) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; sizeof...(Args) &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">number of type parameters</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; sizeof...(args) &lt;&lt; endl;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">number of function parameters</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4472190"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.51:</strong> Determine what <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof...(Args)</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">sizeof...(rest)</span></tt></code> return for each call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">foo</span></tt></code> in this section.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.52:</strong> Write a program to check your answer to the previous question.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4472980" class="calibre37"><span class="calibre5">16.4.1. Writing a Variadic Function Template</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">In &#167; <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a> (p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>) we saw that we can use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">initializer_list</span></tt></code> to define a function that can take a varying number of arguments. However, the arguments must have the same type (or types that are convertible to a common type). Variadic functions are used when we know neither the number nor the types of the arguments we want to process. As an example, we&#8217;ll define a function like our earlier <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code> function, only this time we&#8217;ll allow the argument types to vary as well. We&#8217;ll start by defining a variadic function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> that will print the contents of a given list of arguments on a given stream.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Variadic functions are often recursive (&#167; <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">227</a>). The first call processes the first argument in the pack and calls itself on the remaining arguments. Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function will execute this way&#8212;each call will print its second argument on the stream denoted by its first argument. To stop the recursion, we&#8217;ll also need to define a nonvariadic <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function that will take a stream and an object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">function to end the recursion and print the last element</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this function must be declared before the variadic version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is defined</span></span></span><br class="calibre6"/>template&lt;typename T&gt;<br class="calibre6"/>ostream &amp;print(ostream &amp;os, const T &amp;t)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return os &lt;&lt; t; // <span><span class="calibre45"><span class="calibre16">no separator after the last element in the pack</span></span></span><br class="calibre6"/>}<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">this version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be called for all but the last element in the pack</span></span></span><br class="calibre6"/>template &lt;typename T, typename... Args&gt;<br class="calibre6"/>ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;os &lt;&lt; t &lt;&lt; ", ";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the first argument</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return print(os, rest...); // <span><span class="calibre45"><span class="calibre16">recursive call; print the other arguments</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> stops the recursion and prints the last argument in the initial call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. The second, variadic, version prints the argument bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code> and calls itself to print the remaining values in the function parameter pack.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The key part is the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> inside the variadic function:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">return print(os, rest...); // <span><span class="calibre45"><span class="calibre16">recursive call; print the other arguments</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The variadic version of our <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function takes three parameters: an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code>, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code>, and a parameter pack. Yet this call passes only two arguments. What happens is that the first argument in <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code> gets bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>. The remaining arguments in <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code> form the parameter pack for the next call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. Thus, on <a id="filepos4478416"/>each call, the first argument in the pack is removed from the pack and becomes the argument bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">t</span></tt></code>. That is, given:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(cout, i, s, 42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">two parameters in the pack</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the recursion will execute as follows:</p><div class="calibre15">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00107.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">The first two calls can match only the variadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> because the nonvariadic version isn&#8217;t viable. These calls pass four and three arguments, respectively, and the nonvariadic <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> takes only two arguments.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For the last call in the recursion, <code class="calibre23"><tt class="calibre23"><span class="calibre24">print(cout, 42)</span></tt></code>, both versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> are viable. This call passes exactly two arguments, and the type of the first argument is <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code>. Thus, the nonvariadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> is viable.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The variadic version is also viable. Unlike an ordinary argument, a parameter pack can be empty. Hence, the variadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> can be instantiated with only two parameters: one for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream&amp;</span></tt></code> parameter and the other for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code> parameter.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Both functions provide an equally good match for the call. However, a nonvariadic template is more specialized than a variadic template, so the nonvariadic version is chosen for this call (&#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a>, p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">695</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A declaration for the nonvariadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> must be in scope when the variadic version is defined. Otherwise, the variadic function will recurse indefinitely.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.4.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.53:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> functions and test them by printing one, two, and five arguments, each of which should have different types.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.54:</strong> What happens if we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> on a type that doesn&#8217;t have an <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> operator?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.55:</strong> Explain how the variadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> would execute if we declared the nonvariadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> after the definition of the variadic version.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4482888" class="calibre37"><span class="calibre5">16.4.2. Pack Expansion</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Aside from taking its size, the only other thing we can do with a parameter pack is to <strong class="calibre5">expand</strong> it. When we expand a pack, we also provide a <strong class="calibre5"><a id="filepos4483236" href="160-defined_terms.html#filepos4554103">pattern</a></strong> to be used on <a id="filepos4483311"/>each expanded element. Expanding a pack separates the pack into its constituent elements, applying the pattern to each element as it does so. We trigger an expansion by putting an ellipsis (. . . ) to the right of the pattern.</p><div class="calibre15">&#160;</div>
<p class="calibre25">For example, our <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> function contains two expansions:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T, typename... Args&gt;<br class="calibre6"/>ostream &amp;<br class="calibre6"/>print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)// <span><span class="calibre45"><span class="calibre16">expand</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Args</span></span></tt></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;os &lt;&lt; t &lt;&lt; ", ";<br class="calibre6"/>&#160;&#160;&#160;&#160;return print(os, rest...);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">expand</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rest</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The first expansion expands the template parameter pack and generates the function parameter list for <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. The second expansion appears in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. That pattern generates the argument list for the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The expansion of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Args</span></tt></code> applies the pattern <code class="calibre23"><tt class="calibre23"><span class="calibre24">const Args&amp;</span></tt></code> to each element in the template parameter pack <code class="calibre23"><tt class="calibre23"><span class="calibre24">Args</span></tt></code>. The expansion of this pattern is a comma-separated list of zero or more parameter types, each of which will have the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>
<em class="calibre16">type</em><code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;</span></tt></code>. For example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(cout, i, s, 42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">two parameters in the pack</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The types of the last two arguments along with the pattern determine the types of the trailing parameters. This call is instantiated as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ostream&amp;<br class="calibre6"/>print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The second expansion happens in the (recursive) call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code>. In this case, the pattern is the name of the function parameter pack (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code>). This pattern expands to a comma-separated list of the elements in the pack. Thus, this call is equivalent to</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(os, s, 42);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Understanding Pack Expansions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The expansion of the function parameter pack in <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> just expanded the pack into its constituent parts. More complicated patterns are also possible when we expand a function parameter pack. For example, we might write a second variadic function that calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> (&#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a>, p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">695</a>) on each of its arguments and then calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> to print the resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on each argument in the call to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print</span></span></tt></span><br class="calibre6"/>template &lt;typename... Args&gt;<br class="calibre6"/>ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return print(os, debug_rep(rest)...);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos4489246"/>The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">print</span></tt></code> uses the pattern <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(rest)</span></tt></code>. That pattern says that we want to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> on each element in the function parameter pack <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code>. The resulting expanded pack will be a comma-separated list of calls to <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code>. That is, a call such as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">errorMsg(cerr, fcnName, code.num(), otherData, "other", item);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">will execute as if we had written</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(cerr, debug_rep(fcnName), debug_rep(code.num()),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;debug_rep(otherData), debug_rep("otherData"),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;debug_rep(item));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In contrast, the following pattern would fail to compile:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">passes the pack to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep; print(os, debug_rep(a1, a2, ..., an))</span></span></tt></span><br class="calibre6"/>print(os, debug_rep(rest...)); // <span><span class="calibre45"><span class="calibre16">error: no matching function to call</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem here is that we expanded <code class="calibre23"><tt class="calibre23"><span class="calibre24">rest</span></tt></code> in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code>. This call would execute as if we had written</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">print(cerr, debug_rep(fcnName, code.num(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;otherData, "otherData", item));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this expansion, we attempted to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> with a list of five arguments. There is no version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> that matches this call. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> function is not variadic and there is no version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> that has five parameters.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The pattern in an expansion applies separately to each element in the pack.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.4.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.56:</strong> Write and test a variadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">errorMsg</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.57:</strong> Compare your variadic version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">errorMsg</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">error_msg</span></tt></code> function in &#167; <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a> (p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>). What are the advantages and disadvantages of each approach?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos4494279" class="calibre37"><span class="calibre5">16.4.3. Forwarding Parameter Packs</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can use variadic templates together with <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> to write functions that pass their arguments unchanged to some other function. To illustrate such functions, we&#8217;ll add an <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> member to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>). The <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> member of the library containers is a variadic member template (&#167; <a href="154-16.1._defining_a_template.html#filepos4283763">16.1.4</a>, p. <a href="154-16.1._defining_a_template.html#filepos4283763">673</a>) that uses its arguments to construct an element directly in space managed by the container.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos4495346"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Our version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> for <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> will also have to be variadic, because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> has a number of constructors that differ in terms of their parameters. <a id="filepos4495778"/>Because we&#8217;d like to be able to use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor, we&#8217;ll also need to preserve all the type information about the arguments passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As we&#8217;ve seen, preserving type information is a two-step process. First, to preserve type information in the arguments, we must define <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code>&#8217;s function parameters as rvalue references to a template type parameter (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4417678">16.2.7</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4417678">693</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class StrVec {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;...);<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remaining members as in</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 13.5 (p. 526)</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The pattern in the expansion of the template parameter pack, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&amp;&amp;</span></tt></code>, means that each function parameter will be an rvalue reference to its corresponding argument.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Second, we must use <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> to preserve the arguments&#8217; original types when <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> passes those arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4417678">16.2.7</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4417678">694</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;class... Args&gt;<br class="calibre6"/>inline<br class="calibre6"/>void StrVec::emplace_back(Args&amp;&amp;... args)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;chk_n_alloc(); // <span><span class="calibre45"><span class="calibre16">reallocates the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">StrVec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">if necessary</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;alloc.construct(first_free++, std::forward&lt;Args&gt;(args)...);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The body of <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">chk_n_alloc</span></tt></code> (&#167; <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>) to ensure that there is enough room for an element and calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> to create an element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">first_free</span></tt></code> spot. The expansion in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code>:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::forward&lt;Args&gt;(args)...</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">expands both the template parameter pack, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Args</span></tt></code>, and the function parameter pack, <code class="calibre23"><tt class="calibre23"><span class="calibre24">args</span></tt></code>. This pattern generates elements with the form</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::forward&lt;<span><span class="calibre45"><span class="calibre16">T<sub class="calibre59">i</sub></span></span></span>&gt;(<span><span class="calibre45"><span class="calibre16">t<sub class="calibre59">i</sub></span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">where <em class="calibre16">T<sub class="calibre59">i</sub></em> represents the type of the <em class="calibre16">i</em>th element in the template parameter pack and <em class="calibre16">t<sub class="calibre59">i</sub></em> represents the <em class="calibre16">i</em>th element in the function parameter pack. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code>, if we call</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">svec.emplace_back(10, 'c'); // <span><span class="calibre45"><span class="calibre16">adds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cccccccccc</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a new last element</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the pattern in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> will expand to</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::forward&lt;int&gt;(10), std::forward&lt;char&gt;(c)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">By using <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward</span></tt></code> in this call, we guarantee that if <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> is called with an rvalue, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> will also get an rvalue. For example, in this call:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">svec.emplace_back(s1 + s2); // <span><span class="calibre45"><span class="calibre16">uses the move constructor</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> is an rvalue, which is passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> as</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">std::forward&lt;string&gt;(string("the end"))</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The result type from <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward&lt;string&gt;</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">string&amp;&amp;</span></tt></code>, so <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> will be called with an rvalue reference. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> function will, in turn, forward this argument to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> move constructor to build this element.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos4503749"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Forwarding and Variadic Templates</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Variadic functions often forward their parameters to other functions. Such functions typically have a form similar to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> function:</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fun</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has zero or more parameters each of which is</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">an rvalue reference to a template parameter type</span></span></span><br class="calibre6"/>template&lt;typename... Args&gt;<br class="calibre6"/>void fun(Args&amp;&amp;... args) // <span><span class="calibre45"><span class="calibre16">expands</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Args</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a list of rvalue references</span></span></span><br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the argument to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">work</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">expands both</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Args</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">args</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;work(std::forward&lt;Args&gt;(args)...);<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Here we want to forward all of <code class="calibre23"><tt class="calibre23"><span class="calibre24">fun</span></tt></code>&#8217;s arguments to another function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">work</span></tt></code> that presumably does the real work of the function. Like our call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">construct</span></tt></code> inside <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code>, the expansion in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">work</span></tt></code> expands both the template parameter pack and the function parameter pack.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Because the parameters to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fun</span></tt></code> are rvalue references, we can pass arguments of any type to <code class="calibre23"><tt class="calibre23"><span class="calibre24">fun</span></tt></code>; because we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::forward</span></tt></code> to pass those arguments, all type information about those arguments will be preserved in the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">work</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.4.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.58:</strong> Write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> function for your <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrVec</span></tt></code> class and for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Vec</span></tt></code> class that you wrote for the exercises in &#167; <a href="154-16.1._defining_a_template.html#filepos4193169">16.1.2</a> (p. <a href="154-16.1._defining_a_template.html#filepos4193169">668</a>).</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.59:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, explain <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec.emplace_back(s)</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.60:</strong> Explain how <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">451</a>) works.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.61:</strong> Define your own version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">make_shared</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="156-16.3._overloading_and_templates.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="158-16.5._template_specializations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
