<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>9.3. Sequential Container Operations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="090-9.2._container_library_overview.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="092-9.4._how_a_vector_grows.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2263761" class="calibre29"><span class="bold">9.3. Sequential Container Operations</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">The sequential and associative containers differ in how they organize their elements. These differences affect how elements are stored, accessed, added, and removed. The previous section covered operations common to all containers (those listed in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>)). We&#8217;ll cover the operations specific to the sequential containers in the remainder of this chapter.</p><div class="calibre15">&#160;</div>
<h4 id="filepos2264356" class="calibre37"><span class="calibre5">9.3.1. Adding Elements to a Sequential Container</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Excepting <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, all of the library containers provide flexible memory management. We can add or remove elements dynamically changing the size of the container at run time. <a href="091-9.3._sequential_container_operations.html#filepos2265086">Table 9.5</a> (p. <a href="091-9.3._sequential_container_operations.html#filepos2265086">343</a>) lists the operations that add elements to a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) sequential container.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2265086"/>Table 9.5. Operations That Add Elements to a Sequential Container</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00051.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">When we use these operations, we must remember that the containers use different strategies for allocating elements and that these strategies affect performance. Adding elements anywhere but at the end of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, or anywhere but the beginning or end of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, requires elements to be moved. <a id="filepos2265807"/>Moreover, adding elements to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> may cause the entire object to be reallocated. Reallocating an object requires allocating new memory and moving elements from the old space to the new.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">push_back</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="032-3.3._library_vector_type.html#filepos767585">3.3.2</a> (p. <a href="032-3.3._library_vector_type.html#filepos767585">100</a>) we saw that <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> appends an element to the back of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Aside from <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>, every sequential container (including the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> type) supports <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, the following loop reads one <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> at a time into <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">read from standard input, putting each word onto the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">container</span></span></tt></span><br class="calibre6"/>string word;<br class="calibre6"/>while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;&#160;&#160;container.push_back(word);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> creates a new element at the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">container</span></tt></code>, increasing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">container</span></tt></code> by 1. The value of that element is a copy of <code class="calibre23"><tt class="calibre23"><span class="calibre24">word</span></tt></code>. The type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">container</span></tt></code> can be any of <code class="calibre23"><tt class="calibre23"><span class="calibre24">list, vector</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Because <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is just a container of characters, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> to add characters to the end of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void pluralize(size_t cnt, string &amp;word)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (cnt &gt; 1)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;word.push_back('<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>');&#160;&#160;// <span><span class="calibre45"><span class="calibre16">same as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">word += 's'</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Container Elements Are Copies</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we use an object to initialize a container, or insert an object into a container, a copy of that object&#8217;s value is placed in the container, not the object itself. Just as when we pass an object to a nonreference parameter (&#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>), there is no relationship between the element in the container and the object from which that value originated. Subsequent changes to the element in the container have no effect on the original object, and vice versa.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">push_front</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In addition to <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> containers support an analogous operation named <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code>. This operation inserts a new element at the front of the container:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;int&gt; ilist;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">add elements to the start of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ilist</span></span></tt></span><br class="calibre6"/>for (size_t ix = 0; ix != 4; ++ix)<br class="calibre6"/>&#160;&#160;&#160;&#160;ilist.push_front(ix);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This loop adds the elements <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">2</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">3</span></tt></code> to the beginning of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ilist</span></tt></code>. Each element is inserted at the <em class="calibre16">new beginning</em> of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>. That is, when we insert <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, it goes in <a id="filepos2272668"/>front of <code class="calibre23"><tt class="calibre23"><span class="calibre24">0</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">2</span></tt></code> in front of <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, and so forth. Thus, the elements added in a loop such as this one wind up in reverse order. After executing this loop, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ilist</span></tt></code> holds the sequence <code class="calibre23"><tt class="calibre23"><span class="calibre24">3,2,1,0</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Note that <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, which like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> offers fast random access to its elements, provides the <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code> member even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> does not. A <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> guarantees constant-time insert and delete of elements at the beginning and end of the container. As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, inserting elements other than at the front or back of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> is a potentially expensive operation.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Adding Elements at a Specified Point in the Container</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code> operations provide convenient ways to insert a single element at the end or beginning of a sequential container. More generally, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> members let us insert zero or more elements at any point in the container. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> members are supported for <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> provides specialized versions of these members that we&#8217;ll cover in &#167; <a href="091-9.3._sequential_container_operations.html#filepos2317246">9.3.4</a> (p. <a href="091-9.3._sequential_container_operations.html#filepos2317246">350</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">Each of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> functions takes an iterator as its first argument. The iterator indicates where in the container to put the element(s). It can refer to any position in the container, including one past the end of the container. Because the iterator <a id="filepos2275648"/>might refer to a nonexistent element off the end of the container, and because it is useful to have a way to insert elements at the beginning of a container, element(s) are inserted <em class="calibre16">before</em> the position denoted by the iterator. For example, this statement</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">slist.insert(iter, "Hello!"); // <span><span class="calibre45"><span class="calibre16">insert</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"Hello!"</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">just before</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iter</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">inserts a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> with value <code class="calibre23"><tt class="calibre23"><span class="calibre24">"Hello"</span></tt></code> just before the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Even though some containers do not have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code> operation, there is no similar constraint on <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>. We can <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> elements at the beginning of a container without worrying about whether the container has <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; svec;<br class="calibre6"/>list&lt;string&gt; slist;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">equivalent to calling</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">slist.push_front("Hello!");</span></span></tt></span><br class="calibre6"/>slist.insert(slist.begin(), "Hello!");<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">no</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_front</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">but we can</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">insert</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">before</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin()</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">warning: inserting anywhere but at the end of a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">might be slow</span></span></span><br class="calibre6"/>svec.insert(svec.begin(), "Hello!");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is legal to insert anywhere in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector, deque</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. However, doing so can be an expensive operation.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Inserting a Range of Elements</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> that appear after the initial iterator argument are analogous to the container constructors that take the same parameters. The version that takes an element count and a value adds the specified number of identical elements before the given position:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">svec.insert(svec.end(), 10, "Anna");</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This code inserts ten elements at the end of <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec</span></tt></code> and initializes each of those elements to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string "Anna"</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> that take a pair of iterators or an initializer list insert the elements from the given range before the given position:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; v = {"quasi", "simba", "frollo", "scar"};<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">insert the last two elements of</span></span></span> v <span><span class="calibre45"><span class="calibre16">at the beginning of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">slist</span></span></tt></span><br class="calibre6"/>slist.insert(slist.begin(), v.end() - 2, v.end());<br class="calibre6"/>slist.insert(slist.end(), {"these", "words", "will",<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"go", "at", "the", "end"});<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">run-time error: iterators denoting the range to copy from</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">must not refer to the same container as the one we are changing</span></span></span><br class="calibre6"/>slist.insert(slist.begin(), slist.begin(), slist.end());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we pass a pair of iterators, those iterators may not refer to the same container as the one to which we are adding elements.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2282312"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Under the new standard, the versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> that take a count or a range return an iterator to the first element that was inserted. (In prior versions of the library, these operations returned <code class="calibre23"><tt class="calibre23"><span class="calibre24">void.)</span></tt></code> If the range is empty, no elements are inserted, and the operation returns its first parameter.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2282884"/>Using the Return from <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">insert</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can use the value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> to repeatedly insert elements at a specified position in the container:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;string&gt; 1st;<br class="calibre6"/>auto iter = 1st.begin();<br class="calibre6"/>while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;&#160;iter = 1st.insert(iter, word); // <span><span class="calibre45"><span class="calibre16">same as calling</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_front</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is important to understand how this loop operates&#8212;in particular, to understand why the loop is equivalent to calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Before the loop, we initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">1st.begin()</span></tt></code>. The first call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> takes the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> we just read and puts it in front of the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code>. The value returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> is an iterator referring to this new element. We assign that iterator to <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> and repeat the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code>, reading another word. As long as there are words to insert, each trip through the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> inserts a new element ahead of <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> and reassigns to <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> the location of the newly inserted element. That element is the (new) first element. Thus, each iteration inserts an element ahead of the first element in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using the Emplace Operations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The new standard introduced three new members&#8212;<code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_front, emplace</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code>&#8212;that construct rather than copy elements. These operations correspond to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front, insert</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> operations in that they let us put an element at the front of the container, in front of a given position, or at the back of the container, respectively.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2286643"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">When we call a push or insert member, we pass objects of the element type and those objects are copied into the container. When we call an emplace member, we pass arguments to a constructor for the element type. The emplace members use those arguments to construct an element directly in space managed by the container. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> holds <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>) elements:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">construct a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object at the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">uses the three-argument</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">constructor</span></span></tt></span><br class="calibre6"/>c.emplace_back("978-0590353403", 25, 15.99);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: there is no version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_back</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that takes three arguments</span></span></span><br class="calibre6"/>c.push_back("978-0590353403", 25, 15.99);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: we create a temporary</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object to pass to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">push_back</span></span></tt></span><br class="calibre6"/>c.push_back(Sales_data("978-0590353403", 25, 15.99));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code> and the second call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> both create new <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> objects. In the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_back</span></tt></code>, that object is created directly in space managed by the container. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> creates a local temporary object that is pushed onto the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The arguments to an emplace function vary depending on the element type. The arguments must match a constructor for the element type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos2289837"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to an element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, which holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements</span></span></span><br class="calibre6"/>c.emplace_back(); // <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">default constructor</span></span></span><br class="calibre6"/>c.emplace(iter, "999-999999999"); // <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data(string)</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">uses the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">constructor that takes an</span></span></span>
<span><span class="calibre50">ISBN</span></span><span><span class="calibre45"><span class="calibre16">, a count, and a price</span></span></span><br class="calibre6"/>c.emplace_front("978-0590353403", 25, 15.99);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <em class="calibre16">emplace</em> functions construct elements in the container. The arguments to these functions must match a constructor for the element type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.18:</strong> Write a program to read a sequence of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s from the standard input into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>. Use iterators to write a loop to print the elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.19:</strong> Rewrite the program from the previous exercise to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>. List the changes you needed to make.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.20:</strong> Write a program to copy elements from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;int&gt;</span></tt></code> into two <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>s. The even-valued elements should go into one <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> and the odd ones into the other.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.21:</strong> Explain how the loop from page <a href="091-9.3._sequential_container_operations.html#filepos2282884">345</a> that used the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> to add elements to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> would work if we inserted into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> instead.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.22:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">iv</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, what is wrong with the following program? How might you correct the problem(s)?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;::iterator iter = iv.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mid = iv.begin() + iv.size()/2;<br class="calibre6"/>while (iter != mid)<br class="calibre6"/>&#160;&#160;&#160;&#160;if (*iter == some_val)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iv.insert(iter, 2 * some_val);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2294924" class="calibre37"><span class="calibre5">9.3.2. Accessing Elements</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14"><a href="091-9.3._sequential_container_operations.html#filepos2295366">Table 9.6</a> lists the operations we can use to access elements in a sequential container. The access operations are undefined if the container has no elements.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2295366"/>Table 9.6. Operations to Access Elements in a Sequential Container</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00052.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">Each sequential container, including <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, has a <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> member, and all except <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> also have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> member. These operations return a reference to the first and last element, respectively:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">check that there are elements before dereferencing an iterator or calling</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">front</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">back</span></span></tt></span><br class="calibre6"/>if (!c.empty()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are copies of the value of the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto val = *c.begin(), val2 = c.front();<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">val4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are copies of the of the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto last = c.end();<br class="calibre6"/>&#160;&#160;&#160;&#160;auto val3 = *(--last); // <span><span class="calibre45"><span class="calibre16">can't decrement</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">forward_list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">iterators</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto val4 = c.back();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">not supported by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">forward_list</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2298247"/>This program obtains references to the first and last elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> in two different ways. The direct approach is to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code>. Indirectly, we can obtain a reference to the same element by dereferencing the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> or decrementing and then dereferencing the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Two things are noteworthy in this program: The <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> iterator refers to the (nonexistent) element one past the end of the container. To fetch the last element we must first decrement that iterator. The other important point is that before calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code> (or dereferencing the iterators from <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>), we check that <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> isn&#8217;t empty. If the container were empty, the operations inside the <code class="calibre23"><tt class="calibre23"><span class="calibre24">if</span></tt></code> would be undefined.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Access Members Return References</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The members that access elements in a container (i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">back</span></tt></code>, subscript, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code>) return references. If the container is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, the return is a reference to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. If the container is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, the return is an ordinary reference that we can use to change the value of the fetched element:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (!c.empty()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;c.front()&#160;&#160;= 42;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">assigns</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto &amp;v =&#160;&#160;c.back();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">get a reference to the last element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;v = 1024;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">changes the element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;auto v2 =&#160;&#160;c.back();&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a reference; it's a copy of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c.back()</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;v2 = 0;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">no change to the element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c</span></span></tt></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As usual, if we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to store the return from one of these functions and we want to use that variable to change the element, we must remember to define our variable as a reference type.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Subscripting and Safe Random Access</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The containers that provide fast random access (<code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) also provide the subscript operator (&#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos778112">102</a>). As we&#8217;ve seen, the <a id="filepos2303373"/>subscript operator takes an index and returns a reference to the element at that position in the container. The index must be &#8220;in range,&#8221; (i.e., greater than or equal to 0 and less than the size of the container). It is up to the program to ensure that the index is valid; the subscript operator does not check whether the index is in range. Using an out-of-range value for an index is a serious programming error, but one that the compiler will not detect.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we want to ensure that our index is valid, we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code> member instead. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code> member acts like the subscript operator, but if the index is invalid, <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code> throws an <code class="calibre23"><tt class="calibre23"><span class="calibre24">out_of_range</span></tt></code> exception (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>):</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; svec; // <span><span class="calibre45"><span class="calibre16">empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; svec[0];&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">run-time error: there are no elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">svec</span></span></tt></span><span><span class="calibre45"><span class="calibre16">!</span></span></span><br class="calibre6"/>cout &lt;&lt; svec.at(0);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">throws an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">out_of_range</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">exception</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.23:</strong> In the first program in this section on page <a href="091-9.3._sequential_container_operations.html#filepos2289837">346</a>, what would the values of <code class="calibre23"><tt class="calibre23"><span class="calibre24">val</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">val2, val3</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">val4</span></tt></code> be if <code class="calibre23"><tt class="calibre23"><span class="calibre24">c.size()</span></tt></code> is <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.24:</strong> Write a program that fetches the first element in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> using <code class="calibre23"><tt class="calibre23"><span class="calibre24">at</span></tt></code>, the subscript operator, <code class="calibre23"><tt class="calibre23"><span class="calibre24">front</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>. Test your program on an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2306887" class="calibre37"><span class="calibre5">9.3.3. Erasing Elements</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Just as there are several ways to add elements to a (non<code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) container there are also several ways to remove elements. These members are listed in <a href="091-9.3._sequential_container_operations.html#filepos2307392">Table 9.7</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2307392"/>Table 9.7. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">erase</span></span></tt></span></span></tt></code> Operations on Sequential Containers</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00053.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The members that remove elements do not check their argument(s). The programmer must ensure that element(s) exist before removing them.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">pop_front</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">pop_back</span></span></tt></span></span></tt></code> Members</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_front</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code> functions remove the first and last elements, respectively. Just as there is no <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_front</span></tt></code> for <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, there is also no <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_front</span></tt></code> for those types. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> does not have <code class="calibre23"><tt class="calibre23"><span class="calibre24">pop_back</span></tt></code>. Like the element access members, we may not use a pop operation on an empty container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These operations return <code class="calibre23"><tt class="calibre23"><span class="calibre24">void</span></tt></code>. If you need the value you are about to pop, you must store that value before doing the pop:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">while (!ilist.empty()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;process(ilist.front()); // <span><span class="calibre45"><span class="calibre16">do something with the current top of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ilist</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ilist.pop_front();&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">done; remove the first element</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2310418"/>Removing an Element from within the Container</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> members remove element(s) at a specified point in the container. We can delete a single element denoted by an iterator or a range of elements marked by a pair of iterators. Both forms of <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> return an iterator referring to the location <em class="calibre16">after</em> the (last) element that was removed. That is, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code> is the element following <code class="calibre23"><tt class="calibre23"><span class="calibre24">i</span></tt></code>, then <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase(i)</span></tt></code> will return an iterator referring to <code class="calibre23"><tt class="calibre23"><span class="calibre24">j</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, the following loop erases the odd elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;int&gt; lst = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>auto it = lst.begin();<br class="calibre6"/>while (it != lst.end())<br class="calibre6"/>&#160;&#160;&#160;&#160;if (*it % 2)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the element is odd</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;it = lst.erase(it);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">erase this element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++it;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">On each iteration, we check whether the current element is odd. If so, we <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> that element, setting <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> to denote the element after the one we erased. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">*it</span></tt></code> is even, we increment <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> so we&#8217;ll look at the next element on the next iteration.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Removing Multiple Elements</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The iterator-pair version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> lets us delete a range of elements:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">delete the range of elements between two iterators</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">returns an iterator to the element just after the last removed element</span></span></span><br class="calibre6"/>elem1 = slist.erase(elem1, elem2); // <span><span class="calibre45"><span class="calibre16">after the call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">elem1 == elem2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The iterator <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem1</span></tt></code> refers to the first element we want to erase, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem2</span></tt></code> refers to one past the last element we want to remove.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2314343"/>To delete all the elements in a container, we can either call <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> or pass the iterators from <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">slist.clear(); // <span><span class="calibre45"><span class="calibre16">delete all the elements within the container</span></span></span><br class="calibre6"/>slist.erase(slist.begin(), slist.end()); // <span><span class="calibre45"><span class="calibre16">equivalent</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.25:</strong> In the program on page <a href="091-9.3._sequential_container_operations.html#filepos2310418">349</a> that erased a range of elements, what happens if <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem2</span></tt></code> are equal? What if <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem2</span></tt></code> or both <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">elem2</span></tt></code> are the off-the-end iterator?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.26:</strong> Using the following definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code>, copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code>. Use the single-iterator form of <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> to remove the elements with odd values from your <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> and the even values from your <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2317246" class="calibre37"><span class="calibre5">9.3.4. Specialized <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">forward_list</span></span></tt></span></span></tt></code> Operations</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">To understand why <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> has special versions of the operations to add and remove elements, consider what must happen when we remove an element from a singly linked list. As illustrated in <a href="091-9.3._sequential_container_operations.html#filepos2318240">Figure 9.1</a>, removing an element changes the links in the sequence. In this case, removing <em class="calibre16">elem</em><sub class="calibre59">3</sub> changes <em class="calibre16">elem</em><sub class="calibre59">2</sub>; <em class="calibre16">elem</em><sub class="calibre59">2</sub> had pointed to <em class="calibre16">elem</em><sub class="calibre59">3</sub>, but after we remove <em class="calibre16">elem</em><sub class="calibre59">3</sub>, <em class="calibre16">elem</em><sub class="calibre59">2</sub> points to <em class="calibre16">elem</em><sub class="calibre59">4</sub>.</p><div class="calibre15">&#160;</div>
<div class="calibre52"><a id="filepos2318240"/><img alt="Image" src="images/00054.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5">Figure 9.1. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">forward_list</span></span></tt></span></span></tt></code> Specialized Operations</span></p><div class="calibre12">&#160;</div>
<p class="calibre25">When we add or remove an element, the element before the one we added or removed has a different successor. To add or remove an element, we need access to its predecessor in order to update that element&#8217;s links. However, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> is a singly linked list. In a singly linked list there is no easy way to get to an element&#8217;s predecessor. For this reason, the operations to add or remove elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> operate by changing the element <em class="calibre16">after</em> the given element. That way, we always have access to the elements that are affected by the change.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because these operations behave differently from the operations on the other containers, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> does not define <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>. Instead it defines members (listed in <a href="091-9.3._sequential_container_operations.html#filepos2320799">Table 9.8</a>) named <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert_after</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">emplace_after</span></tt></code>, <a id="filepos2320001"/>and <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase_after</span></tt></code>. For example, in our illustration, to remove <em class="calibre16">elem</em><sub class="calibre59">3</sub>, we&#8217;d call <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase_after</span></tt></code> on an iterator that denoted <em class="calibre16">elem</em><sub class="calibre59">2</sub>. To support these operations, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> also defines <code class="calibre23"><tt class="calibre23"><span class="calibre24">before_begin</span></tt></code>, which returns an <strong class="calibre5"><a id="filepos2320526" href="096-defined_terms.html#filepos2451895">off-the-beginning</a></strong> iterator. This iterator lets us add or remove elements &#8220;after&#8221; the nonexistent element before the first one in the list.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2320799"/>Table 9.8. Operations to Insert or Remove Elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">forward_list</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00055.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">When we add or remove elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>, we have to keep track of two iterators&#8212;one to the element we&#8217;re checking and one to that element&#8217;s predecessor. As an example, we&#8217;ll rewrite the loop from page <a href="091-9.3._sequential_container_operations.html#filepos2310418">349</a> that removed the odd-valued elements from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">forward_list&lt;int&gt; flst = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>auto prev = flst.before_begin(); // <span><span class="calibre45"><span class="calibre16">denotes element "off the start" of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flst</span></span></tt></span><br class="calibre6"/>auto curr = flst.begin();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">denotes the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">flst</span></span></tt></span><br class="calibre6"/>while (curr != flst.end()) {&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">while there are still elements to process</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (*curr % 2)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the element is odd</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;curr = flst.erase_after(prev); // <span><span class="calibre45"><span class="calibre16">erase it and move</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">curr</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;prev = curr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">move the iterators to denote the next</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++curr;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">element and one before the next element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> denotes the element we&#8217;re checking, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code> denotes the element before <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>. We call <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>, so that the first iteration checks whether the first element is even or odd. We initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">before_begin</span></tt></code>, which returns an iterator to the nonexistent element just before <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we find an odd element, we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase_after</span></tt></code>. This call erases the element after the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code>; that is, it erases the element denoted <a id="filepos2325018"/>by <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>. We reset <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> to the return from <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase_after</span></tt></code>, which makes <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> denote the next element in the sequence and we leave <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code> unchanged; <code class="calibre23"><tt class="calibre23"><span class="calibre24">prev</span></tt></code> still denotes the element before the (new) value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code>. If the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">curr</span></tt></code> is not odd, then we have to move both iterators, which we do in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">else</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.27:</strong> Write a program to find and remove the odd-valued elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list&lt;int&gt;</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.28:</strong> Write a function that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list&lt;string&gt;</span></tt></code> and two additional <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> arguments. The function should find the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and insert the second immediately following the first. If the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> is not found, then insert the second <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> at the end of the list.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2327136" class="calibre37"><span class="calibre5">9.3.5. Resizing a Container</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">With the usual exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code>, described in <a href="091-9.3._sequential_container_operations.html#filepos2329363">Table 9.9</a>, to make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;int&gt; ilist(10, 42); // <span><span class="calibre45"><span class="calibre16">ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s: each has value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42</span></span></tt></span><br class="calibre6"/>ilist.resize(15);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">adds five elements of value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the back of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ilist</span></span></tt></span><br class="calibre6"/>ilist.resize(25, -1); // <span><span class="calibre45"><span class="calibre16">adds ten elements of value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to the back of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ilist</span></span></tt></span><br class="calibre6"/>ilist.resize(5);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">erases 20 elements from the back of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ilist</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2329363"/>Table 9.9. Sequential Container Size Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00056.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> operation takes an optional element-value argument that it uses to initialize any elements that are added to the container. If this argument is absent, added elements are value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>). If the container holds elements of a class type and <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> adds elements, we must supply an initializer or the element type must have a default constructor.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2330188"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.29:</strong> Given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec</span></tt></code> holds 25 elements, what does <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec.resize(100)</span></tt></code> do? What if we next wrote <code class="calibre23"><tt class="calibre23"><span class="calibre24">vec.resize(10)</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.30:</strong> What, if any, restrictions does using the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> that takes a single argument place on the element type?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2331099" class="calibre37"><span class="calibre5">9.3.6. Container Operations May Invalidate Iterators</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. Using an invalidated pointer, reference, or iterator is a serious programming error that is likely to lead to the same kinds of problems as using an uninitialized pointer (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">54</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">After an operation that adds elements to a container</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Iterators, pointers, and references to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> are invalid if the container was reallocated. If no reallocation happens, indirect references to elements before the insertion remain valid; those to elements after the insertion are invalid.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Iterators, pointers, and references to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> are invalid if we add elements anywhere but at the front or back. If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Iterators, pointers, and references (including the off-the-end and the before-the-beginning iterators) to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> remain valid,</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. After all, those elements have been destroyed. After we remove an element,</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; All other iterators, references, or pointers (including the off-the-end and the before-the-beginning iterators) to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> remain valid.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; All other iterators, references, or pointers to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> are invalidated if the removed elements are anywhere but the front or back. If we remove elements at the back of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; they are also unaffected if we remove from the front.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; All other iterators, references, or pointers to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> remain valid for elements before the removal point. Note: The off-the-end iterator is always invalidated when we remove elements.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is a serious run-time error to use an iterator, pointer, or reference that has been invalidated.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><a id="filepos2335296"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Managing Iterators</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When you use an iterator (or a reference or pointer to a container element), it is a good idea to minimize the part of the program during which an iterator must stay valid.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Because code that adds or removes elements to a container can invalidate iterators, you need to ensure that the iterator is repositioned, as appropriate, after each operation that changes the container. This advice is especially important for <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Writing Loops That Change a Container</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">Loops that add or remove elements of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector, string</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> must cater to the fact that iterators, references, or pointers might be invalidated. The program must ensure that the iterator, reference, or pointer is refreshed on each trip through the loop. Refreshing an iterator is easy if the loop calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>. Those operations return iterators, which we can use to reset the iterator:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">silly loop to remove even-valued elements and insert a duplicate of odd-valued elements</span></span></span><br class="calibre6"/>vector&lt;int&gt; vi = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>auto iter = vi.begin(); // <span><span class="calibre45"><span class="calibre16">call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cbegin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">because we're changing</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vi</span></span></tt></span><br class="calibre6"/>while (iter != vi.end()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;if (*iter % 2) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter = vi.insert(iter, *iter);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">duplicate the current element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter += 2; // <span><span class="calibre45"><span class="calibre16">advance past this element and the one inserted before it</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;} else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter = vi.erase(iter);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remove even elements</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">don't advance the iterator;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denotes the element after the one we erased</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This program removes the even-valued elements and duplicates each odd-valued one. We refresh the iterator after both the <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> because either operation can invalidate the iterator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code>, there is no need to increment the iterator, because the iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">erase</span></tt></code> denotes the next element in the sequence. After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code>, we increment the iterator twice. Remember, <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> inserts <em class="calibre16">before</em> the position it is given and returns an iterator to the inserted element. Thus, after calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert, iter</span></tt></code> denotes the (newly added) element in front of the one we are processing. We add two to skip over the element we added and the one we just processed. Doing so positions the iterator on the next, unprocessed element.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Avoid Storing the Iterator Returned from <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">end</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">When we add or remove elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, or add elements or remove any but the first element in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> is <em class="calibre16">always</em> invalidated. Thus, loops that add or remove elements should always call <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> rather than use a stored copy. Partly for this reason, C++ standard libraries are usually implemented so that calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code> is a very fast operation.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, consider a loop that processes each element and adds a new element following the original. We want the loop to ignore the added elements, <a id="filepos2341868"/>and to process only the original elements. After each insertion, we&#8217;ll position the iterator to denote the next original element. If we attempt to &#8220;optimize&#8221; the loop, by storing the iterator returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code>, we&#8217;ll have a disaster:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">disaster: the behavior of this loop is undefined</span></span></span><br class="calibre6"/>auto begin = v.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;end = v.end(); // <span><span class="calibre45"><span class="calibre16">bad idea, saving the value of the end iterator</span></span></span><br class="calibre6"/>while (begin != end) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do some processing</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">insert the new value and reassign</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">which otherwise would be invalid</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++begin;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">because we want to insert after this element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;begin = v.insert(begin, 42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">insert the new value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++begin;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">past</span></span></span>
<span><span class="calibre45"><span class="calibre16">the element we just added</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The behavior of this code is undefined. On many implementations, we&#8217;ll get an infinite loop. The problem is that we stored the value returned by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operation in a local variable named <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. In the body of the loop, we added an element. Adding an element invalidates the iterator stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. That iterator neither refers to an element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">v</span></tt></code> nor any longer refers to one past the last element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">v</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Don&#8217;t cache the iterator returned from <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code> in loops that insert or delete elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque, string</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Rather than storing the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end()</span></tt></code> iterator, we must recompute it after each insertion:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">safer: recalculate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">end</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on each trip whenever the loop adds/erases elements</span></span></span><br class="calibre6"/>while (begin != v.end()) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">do some processing</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++begin;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">because we want to insert after this element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;begin = v.insert(begin, 42);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">insert the new value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++begin;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">past the element we just added</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="090-9.2._container_library_overview.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="092-9.4._how_a_vector_grows.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
