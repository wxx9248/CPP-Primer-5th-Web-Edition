<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>13.2. Copy Control and Resource Management</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="121-13.1._copy_assign_and_destroy.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="123-13.3._swap.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3281447" class="calibre29"><span class="bold">13.2. Copy Control and Resource Management</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Ordinarily, classes that manage resources that do not reside in the class must define the copy-control members. As we saw in &#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>), such classes will need destructors to free the resources allocated by the object. Once a class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In order to define these members, we first have to decide what copying an object of our type will mean. In general, we have two choices: We can define the copy operations to make the class behave like a value or like a pointer.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Classes that behave like values have their own state. When we copy a valuelike object, the copy and the original are independent of each other. Changes made to the copy have no effect on the original, and vice versa.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Classes that act like pointers share state. When we copy objects of such classes, the copy and the original use the same underlying data. Changes made to the copy also change the original, and vice versa.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Of the library classes we&#8217;ve used, the library containers and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> class have valuelike behavior. Not surprisingly, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class provides pointerlike behavior, as does our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>). The IO types and <a/><code class="calibre23"><tt class="calibre23"><span class="calibre24">unique_ptr</span></tt></code> do not allow copying or assignment, so they provide neither valuelike nor pointerlike behavior.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To illustrate these two approaches, we&#8217;ll define the copy-control members for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class used in the exercises. First, we&#8217;ll make the class act like a value; then we&#8217;ll reimplement the class making it behave like a pointer.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class has two members, an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Ordinarily, classes copy members of built-in type (other than pointers) directly; such members are values and hence ordinarily ought to behave like values. What we do when we copy the pointer member determines whether a class like <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> has valuelike or pointerlike behavior.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.22:</strong> Assume that we want <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> to behave like a value. That is, each object should have its own copy of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which the objects point. We&#8217;ll show the definitions of the copy-control members in the next section. However, you already know everything you need to know to implement these members. Write the <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> copy constructor and copy-assignment operator before reading on.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3285596" class="calibre37"><span class="calibre5">13.2.1. Classes That Act Like Values</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. That means each <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> object must have its own copy of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> points. To implement valuelike behavior <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> needs</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A copy constructor that copies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, not just the pointer</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A destructor to free the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; A copy-assignment operator to free the object&#8217;s existing <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and copy the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> from its right-hand operand</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">The valuelike version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> is</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class HasPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const std::string &amp;s = std::string()):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps(new std::string(s)), i(0) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">each</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">HasPtr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has its own copy of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ps</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const HasPtr &amp;p):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps(new std::string(*p.ps)), i(p.i) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr&amp; operator=(const HasPtr &amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;~HasPtr() { delete ps; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *ps;<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;i;<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3288692"/>Our class is simple enough that we&#8217;ve defined all but the assignment operator in the class body. The first constructor takes an (optional) <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. That constructor dynamically allocates its own copy of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and stores a pointer to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code>. The copy constructor also allocates its own, separate copy of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The destructor frees the memory allocated in its constructors by executing <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> on the pointer member, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Valuelike Copy-Assignment Operator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Assignment operators typically combine the actions of the destructor and the copy constructor. Like the destructor, assignment destroys the left-hand operand&#8217;s resources. Like the copy constructor, assignment copies data from the right-hand operand. However, it is crucially important that these actions be done in a sequence that is correct even if an object is assigned to itself. Moreover, when possible, we should also write our assignment operators so that they will leave the left-hand operand in a sensible state should an exception occur (&#167; <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">5.6.2</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">196</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">In this case, we can handle self-assignment&#8212;and make our code safe should an exception happen&#8212;by first copying the right-hand side. After the copy is made, we&#8217;ll free the left-hand side and update the pointer to point to the newly allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;auto newp = new string(*rhs.ps);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy the underlying</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free the old memory</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ps = newp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy data from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into this object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;i = rhs.i;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return this object</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this assignment operator, we quite clearly first do the work of the constructor: The initializer of <code class="calibre23"><tt class="calibre23"><span class="calibre24">newp</span></tt></code> is identical to the initializer of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>&#8217;s copy constructor. As in the destructor, we next <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete</span></tt></code> the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> currently points. What remains is to copy the pointer to the newly allocated <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value from <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> into this object.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Key Concept: Assignment Operators</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">There are two points to keep in mind when you write an assignment operator:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Assignment operators must work correctly if an object is assigned to itself.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Most assignment operators share work with the destructor and copy constructor.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A good pattern to use when you write an assignment operator is to first copy the right-hand operand into a local temporary. <em class="calibre16">After</em> the copy is done, it is safe to destroy the existing members of the left-hand operand. Once the left-hand operand is destroyed, copy the data from the temporary into the members of the left-hand operand.</p></blockquote><div class="calibre15">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">To illustrate the importance of guarding against self-assignment, consider what would happen if we wrote the assignment operator as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">WRONG way to write an assignment operator!</span></span></span><br class="calibre6"/>HasPtr&amp;<br class="calibre6"/>HasPtr::operator=(const HasPtr &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;delete ps;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">frees the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which this object points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*this</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are the same object, we're copying from deleted memory!</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ps = new string(*(rhs.ps));<br class="calibre6"/>&#160;&#160;&#160;&#160;i = rhs.i;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> and this object are the same object, deleting <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> frees the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which both <code class="calibre23"><tt class="calibre23"><span class="calibre24">*this</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> point. When we attempt to copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">* (rhs.ps)</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">new</span></tt></code> expression, that pointer points to invalid memory. What happens is undefined.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It is crucially important for assignment operators to work correctly, even when an object is assigned to itself. A good way to do so is to copy the right-hand operand before destroying the left-hand operand.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.23:</strong> Compare the copy-control members that you wrote for the solutions to the previous section&#8217;s exercises to the code presented here. Be sure you understand the differences, if any, between your code and ours.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.24:</strong> What would happen if the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> in this section didn&#8217;t define a destructor? What if <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> didn&#8217;t define the copy constructor?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.25:</strong> Assume we want to define a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> that acts like a value. Also assume that we want to continue to use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> so that our <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlobPtr</span></tt></code> class can still use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">weak_ptr</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Your revised class will need a copy constructor and copy-assignment operator but will not need a destructor. Explain what the copy constructor and copy-assignment operators must do. Explain why the class does not need a destructor.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.26:</strong> Write your own version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">StrBlob</span></tt></code> class described in the previous exercise.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3299202" class="calibre37"><span class="calibre5">13.2.2. Defining Classes That Act Like Pointers</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">For our <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> class to act like a pointer, we need the copy constructor and copy-assignment operator to copy the pointer member, not the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which that pointer points. Our class will still need its own destructor to free the memory allocated by the constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>). In this case, though, the destructor cannot unilaterally free its associated <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. It can do so only when the last <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> pointing to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> goes away.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The easiest way to make a class act like a pointer is to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code>s to manage the resources in the class. Copying (or assigning) a <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> copies <a id="filepos3300661"/>(assigns) the pointer to which the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> points. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class itself keeps track of how many users are sharing the pointed-to object. When there are no more users, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">shared_ptr</span></tt></code> class takes care of freeing the resource.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, sometimes we want to manage a resource directly. In such cases, it can be useful to use a <strong class="calibre5"><a id="filepos3301263" href="128-defined_terms.html#filepos3541341">reference count</a></strong> (&#167; <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>). To show how reference counting works, we&#8217;ll redefine <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> to provide pointerlike behavior, but we will do our own reference counting.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Reference Counts</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Reference counting works as follows:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; In addition to initializing the object, each constructor (other than the copy constructor) creates a counter. This counter will keep track of how many objects share state with the object we are creating. When we create an object, there is only one such object, so we initialize the counter to 1.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The copy constructor does not allocate a new counter; instead, it copies the data members of its given object, including the counter. The copy constructor increments this shared counter, indicating that there is another user of that object&#8217;s state.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The destructor decrements the counter, indicating that there is one less user of the shared state. If the count goes to zero, the destructor deletes that state.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The copy-assignment operator increments the right-hand operand&#8217;s counter and decrements the counter of the left-hand operand. If the counter for the left-hand operand goes to zero, there are no more users. In this case, the copy-assignment operator must destroy the state of the left-hand operand.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">The only wrinkle is deciding where to put the reference count. The counter cannot be a direct member of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> object. To see why, consider what happens in the following example:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr p1("Hiya!");<br class="calibre6"/>HasPtr p2(p1);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">point to the same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>HasPtr p3(p1);&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p1</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">all point to the same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the reference count is stored in each object, how can we update it correctly when <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code> is created? We could increment the count in <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> and copy that count into <code class="calibre23"><tt class="calibre23"><span class="calibre24">p3</span></tt></code>, but how would we update the counter in <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2?</span></tt></code></p><div class="calibre15">&#160;</div>
<p class="calibre25">One way to solve this problem is to store the counter in dynamic memory. When we create an object, we&#8217;ll also allocate a new counter. When we copy or assign an object, we&#8217;ll copy the pointer to the counter. That way the copy and the original will point to the same counter.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Defining a Reference-Counted Class</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Using a reference count, we can write the pointerlike version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3306070"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class HasPtr {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">constructor allocates a new</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and a new counter, which it sets to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">1</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const std::string &amp;s = std::string()):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;ps(new std::string(s)), i(0), use(new std::size_t(1)) {}<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy constructor copies all three data members and increments the counter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr(const HasPtr &amp;p):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ps(p.ps), i(p.i), use(p.use) { ++*use; }<br class="calibre6"/>&#160;&#160;&#160;&#160;HasPtr&amp; operator=(const HasPtr&amp;);<br class="calibre6"/>&#160;&#160;&#160;&#160;~HasPtr();<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;std::string *ps;<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;i;<br class="calibre6"/>&#160;&#160;&#160;&#160;std::size_t *use;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">member to keep track of how many objects share</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*ps</span></span></tt></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, we&#8217;ve added a new data member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">use</span></tt></code> that will keep track of how many objects share the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The constructor that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> allocates this counter and initializes it to <code class="calibre23"><tt class="calibre23"><span class="calibre24">1</span></tt></code>, indicating that there is one user of this object&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointerlike Copy Members &#8220;Fiddle&#8221; the Reference Count</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When we copy or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code> object, we want the copy and the original to point to the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. That is, when we copy a <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>, we&#8217;ll copy <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> itself, not the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> points. When we make a copy, we also increment the counter associated with that <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The copy constructor (which we defined inside the class) copies all three members from its given <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>. This constructor also increments the <code class="calibre23"><tt class="calibre23"><span class="calibre24">use</span></tt></code> member, indicating that there is another user for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">p.ps</span></tt></code> point.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The destructor cannot unconditionally <code class="calibre23"><tt class="calibre23"><span class="calibre24">delete ps</span></tt></code>&#8212;there might be other objects pointing to that memory. Instead, the destructor decrements the reference count, indicating that one less object shares the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. If the counter goes to zero, then the destructor frees the memory to which both <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">use</span></tt></code> point:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr::~HasPtr()<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;if (--*use == 0) {&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the reference count goes to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">delete the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete use;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">and the counter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The copy-assignment operator, as usual, does the work common to the copy constructor and to the destructor. That is, the assignment operator must increment the counter of the right-hand operand (i.e., the work of the copy constructor) and decrement the counter of the left-hand operand, deleting the memory used if appropriate (i.e., the work of the destructor).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Also, as usual, the operator must handle self-assignment. We do so by incrementing the count in <code class="calibre23"><tt class="calibre23"><span class="calibre24">rhs</span></tt></code> before decrementing the count in the left-hand object. <a id="filepos3312210"/>That way if both objects are the same, the counter will have been incremented before we check to see if <code class="calibre23"><tt class="calibre23"><span class="calibre24">ps</span></tt></code> (and <code class="calibre23"><tt class="calibre23"><span class="calibre24">use</span></tt></code>) should be deleted:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;++*rhs.use;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">increment the use count of the right-hand operand</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (--*use == 0) {&#160;&#160;// <span><span class="calibre45"><span class="calibre16">then decrement this object's counter</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete ps;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if no other users</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;delete use;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">free this object's allocated members</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>&#160;&#160;&#160;&#160;ps = rhs.ps;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copy data from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">rhs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into this object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;i = rhs.i;<br class="calibre6"/>&#160;&#160;&#160;&#160;use = rhs.use;<br class="calibre6"/>&#160;&#160;&#160;&#160;return *this;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">return this object</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 13.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.27:</strong> Define your own reference-counted version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">HasPtr</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 13.28:</strong> Given the following classes, implement a default constructor and the necessary copy-control members.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class TreeNode {<br class="calibre6"/>&#160;private:<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;std::string value;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;TreeNode&#160;&#160;&#160;&#160;*left;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;TreeNode&#160;&#160;&#160;&#160;*right;<br class="calibre6"/>&#160;};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class BinStrTree {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;private:<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TreeNode *root;<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="121-13.1._copy_assign_and_destroy.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="123-13.3._swap.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
