<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>9.2. Container Library Overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="089-9.1._overview_of_the_sequential_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="091-9.3._sequential_container_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2188055" class="calibre29"><span class="bold">9.2. Container Library Overview</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The operations on the container types form a kind of hierarchy:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Some operations (<a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>)) are provided by all container types.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2188610"/>Table 9.2. Container Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00047.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00048.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Other operations are specific to the sequential (<a href="090-9.2._container_library_overview.html#filepos2189318">Table 9.3</a> (p. <a href="090-9.2._container_library_overview.html#filepos2189318">335</a>)), the associative (<a href="109-11.3._operations_on_associative_containers.html#filepos2831111">Table 11.7</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">438</a>)), or the unordered (<a href="110-11.4._the_unordered_containers.html#filepos2880096">Table 11.8</a> (p. <a href="110-11.4._the_unordered_containers.html#filepos2880096">445</a>)) containers.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2189318"/>Table 9.3. Defining and Initializing Containers</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00049.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Still others are common to only a smaller subset of the containers.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos2189692"/>In this section, we&#8217;ll cover aspects common to all of the containers. The remainder of this chapter will then focus solely on sequential containers; we&#8217;ll cover operations specific to the associative containers in <a href="106-chapter_11._associative_containers.html#filepos2718579">Chapter 11</a>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In general, each container is defined in a header file with the same name as the type. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> is in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code> header, <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> header, and so on. The containers are class templates (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s, we must supply additional information to generate a particular container type. For most, but not all, of the containers, the information we must supply is the element type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;Sales_data&gt;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">objects</span></span></span><br class="calibre6"/>deque&lt;double&gt;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">deque</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">doubles</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Constraints on Types That a Container Can Hold</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Almost any type can be used as the element type of a sequential container. In particular, we can define a container whose element type is itself another container. We define such containers exactly as we do any other container type: We specify the element type (which in this case is a container type) inside angle brackets:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;vector&lt;string&gt;&gt; lines;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vectors</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here <code class="calibre23"><tt class="calibre23"><span class="calibre24">lines</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> whose elements are <code class="calibre23"><tt class="calibre23"><span class="calibre24">vectors</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Older compilers may require a space between the angle brackets, for example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;vector&lt;string&gt; &gt;</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Although we can store almost any type in a container, some container operations impose requirements of their own on the element type. We can define a container for a type that does not support an operation-specific requirement, but we can use an operation only if the element type meets that operation&#8217;s requirements.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As an example, the sequential container constructor that takes a size argument (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) uses the element type&#8217;s default constructor. Some classes do not have a default constructor. We can define a container that holds objects of such types, but we cannot construct such containers using only an element count:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">assume</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">noDefault</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a type without a default constructor</span></span></span><br class="calibre6"/>vector&lt;noDefault&gt; v1(10, init); // <span><span class="calibre45"><span class="calibre16">ok: element initializer supplied</span></span></span><br class="calibre6"/>vector&lt;noDefault&gt; v2(10);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: must supply an element initializer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we describe the container operations, we&#8217;ll note the additional constraints, if any, that each container operation places on the element type.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.2:</strong> Define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> that holds elements that are <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>s that hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2196283" class="calibre37"><span class="calibre5"><a/><a id="filepos2196324"/>9.2.1. Iterators</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As with the containers, iterators have a common interface: If an iterator provides an operation, then the operation is supported in the same way for each iterator that supplies that operation. For example, all the iterators on the standard container types let us access an element from a container, and they all do so by providing the dereference operator. Similarly, the iterators for the library containers all define the increment operator to move from one element to the next.</p><div class="calibre15">&#160;</div>
<p class="calibre25">With one exception, the container iterators support all the operations listed in <a href="033-3.4._introducing_iterators.html#filepos810064">Table 3.6</a> (p. <a href="033-3.4._introducing_iterators.html#filepos810064">107</a>). The exception is that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> iterators do not support the decrement (<code class="calibre23"><tt class="calibre23"><span class="calibre24">--</span></tt></code>) operator. The iterator arithmetic operations listed in <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a> (p. <a href="033-3.4._introducing_iterators.html#filepos840512">111</a>) apply only to iterators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">string, vector, deque</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>. We cannot use these operations on iterators for any of the other container types.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Iterator Ranges</span></h5><div class="calibre38">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The concept of an iterator range is fundamental to the standard library.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">An <strong class="calibre5"><a id="filepos2198345" href="096-defined_terms.html#filepos2449746">iterator range</a></strong> is denoted by a pair of iterators each of which refers to an element, or to <em class="calibre16">one past the last element,</em> in the same container. These two iterators, often referred to as <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>&#8212;or (somewhat misleadingly) as <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">last</span></tt></code>&#8212;mark a range of elements from the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">last</span></tt></code>, although commonly used, is a bit misleading, because the second iterator never refers to the last element of the range. Instead, it refers to a point one past the last element. The elements in the range include the element denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> and every element from <code class="calibre23"><tt class="calibre23"><span class="calibre24">first</span></tt></code> up to but not including <code class="calibre23"><tt class="calibre23"><span class="calibre24">last</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This element range is called a <strong class="calibre5"><a id="filepos2199691" href="096-defined_terms.html#filepos2450433">left-inclusive interval</a></strong>. The standard mathematical notation for such a range is</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">[ begin, end)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">indicating that the range begins with <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and ends with, but does not include, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. The iterators <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> must refer to the same container. The iterator <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> may be equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> but must not refer to an element before the one denoted by <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Requirements on Iterators Forming an Iterator Range</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Two iterators, <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, form an iterator range, if</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; They refer to elements of, or one past the end of, the same container, and</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; It is possible to reach <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> by repeatedly incrementing <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>. In other words, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> must not precede <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The compiler cannot enforce these requirements. It is up to us to ensure that our programs follow these conventions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2202427"/>Programming Implications of Using Left-Inclusive Ranges</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The library uses left-inclusive ranges because such ranges have three convenient properties. Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> denote a valid iterator range, then</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> equals <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, the range is empty</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> is not equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, there is at least one element in the range, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> refers to the first element in that range</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We can increment <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> some number of times until <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin == end</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">These properties mean that we can safely write loops such as the following to process a range of elements:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">while (begin&#160;&#160;&#160;!= end) {<br class="calibre6"/>&#160;&#160;&#160;&#160;*begin =&#160;&#160;val;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: range isn't empty so</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">begin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">denotes an element</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++begin;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">advance the iterator to get the next element</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> form a valid iterator range, we know that if <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> == <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, then the range is empty. In this case, we exit the loop. If the range is nonempty, we know that <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> refers to an element in this nonempty range. Therefore, inside the body of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code>, we know that it is safe to dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> because <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> must refer to an element. Finally, because the loop body increments <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>, we also know the loop will eventually terminate.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.3:</strong> What are the constraints on the iterators that form iterator ranges?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.4:</strong> Write a function that takes a pair of iterators to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code> and an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value. Look for that value in the range and return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> indicating whether it was found.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.5:</strong> Rewrite the previous program to return an iterator to the requested element. Note that the program must handle the case where the element is not found.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.6:</strong> What is wrong with the following program? How might you correct it?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;int&gt; lst1;<br class="calibre6"/>list&lt;int&gt;::iterator iter1 = lst1.begin(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter2 = lst1.end();<br class="calibre6"/>while (iter1 &lt; iter2) /* ... */</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2207848" class="calibre37"><span class="calibre5">9.2.2. Container Type Members</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Each container defines several types, shown in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>). We have already used three of these container-defined types: <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_type</span></tt></code> (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>), <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">108</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2208614"/>In addition to the iterator types we&#8217;ve already used, most containers provide reverse iterators. Briefly, a reverse iterator is an iterator that goes backward through a container and inverts the meaning of the iterator operations. For example, saying <code class="calibre23"><tt class="calibre23"><span class="calibre24">++</span></tt></code> on a reverse iterator yields the previous element. We&#8217;ll have more to say about reverse iterators in &#167; <a href="101-10.4._revisiting_iterators.html#filepos2654416">10.4.3</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2654416">407</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">The remaining type aliases let us use the type of the elements stored in a container without knowing what that type is. If we need the element type, we refer to the container&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">value_type</span></tt></code>. If we need a reference to that type, we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">reference</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_reference</span></tt></code>. These element-related type aliases are most useful in generic programs, which we&#8217;ll cover in <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">To use one of these types, we must name the class of which they are a member:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iter</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type defined by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list&lt;string&gt;</span></span></tt></span><br class="calibre6"/>list&lt;string&gt;::iterator iter;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">count</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">difference_type</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type defined by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector&lt;int&gt;</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt;::difference_type count;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These declarations use the scope operator (&#167; <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">8</a>) to say that we want the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> member of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;string&gt;</span></tt></code> class and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">difference_type</span></tt></code> defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>, respectively.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.7:</strong> What type should be used as the index into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.8:</strong> What type should be used to read elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s? To write them?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2212546" class="calibre37"><span class="calibre5">9.2.3. <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">begin</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">end</span></span></tt></span></span></tt></code> Members</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operations (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>) yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As shown in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>), there are several versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>: The versions with an <code class="calibre23"><tt class="calibre23"><span class="calibre24">r</span></tt></code> return reverse iterators (which we cover in &#167; <a href="101-10.4._revisiting_iterators.html#filepos2654416">10.4.3</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2654416">407</a>)). Those that start with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> return the <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of the related iterator:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;string&gt; a = {"Milton", "Shakespeare", "Austen"};<br class="calibre6"/>auto it1 = a.begin();&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list&lt;string&gt;::iterator</span></span></tt></span><br class="calibre6"/>auto it2 = a.rbegin(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list&lt;string&gt;::reverse_iterator</span></span></tt></span><br class="calibre6"/>auto it3 = a.cbegin(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list&lt;string&gt;::const_iterator</span></span></tt></span><br class="calibre6"/>auto it4 = a.crbegin();// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">list&lt;string&gt;::const_reverse_iterator</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The functions that do not begin with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> are overloaded. That is, there are actually two members named <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>. One is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>) that returns the container&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> type. The other is non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and returns the container&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> type. Similarly for <code class="calibre23"><tt class="calibre23"><span class="calibre24">rbegin</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">rend</span></tt></code>. When we <a id="filepos2216072"/>call one of these members on a non<code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object, we get the version that returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code>. We get a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> version of the iterators <em class="calibre16">only</em> when we call these functions on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object. As with pointers and references to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>, we can convert a plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> to the corresponding <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code>, but not vice versa.</p><div class="calibre15">&#160;</div>
<div class="calibre28"><a id="filepos2216888"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> versions were introduced by the new standard to support using <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> functions (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>). In the past, we had no choice but to say which type of iterator we want:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">type is explicitly specified</span></span></span><br class="calibre6"/>list&lt;string&gt;::iterator it5 = a.begin();<br class="calibre6"/>list&lt;string&gt;::const_iterator it6 = a.begin();<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">or</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const_iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">depending on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a</span></span></tt></span><span><span class="calibre45"><span class="calibre16">'s type of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a</span></span></tt></span><br class="calibre6"/>auto it7 = a.begin();&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const_iterator</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">only if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const</span></span></tt></span><br class="calibre6"/>auto it8 = a.cbegin(); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it8</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const_iterator</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, the iterator type we get depends on the container type. How we intend to use the iterator is irrelevant. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">c</span></tt></code> versions let us get a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const_iterator</span></tt></code> regardless of the type of the container.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00017.jpg" class="calibre9"/> Best Practices</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When write access is not needed, use <code class="calibre23"><tt class="calibre23"><span class="calibre24">cbegin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cend</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.9:</strong> What is the difference between the <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cbegin</span></tt></code> functions?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.10:</strong> What are the types of the following four objects?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; v1;<br class="calibre6"/>const vector&lt;int&gt; v2;<br class="calibre6"/>auto it1 = v1.begin(), it2 = v2.begin();<br class="calibre6"/>auto it3 = v1.cbegin(), it4 = v2.cbegin();</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2221429" class="calibre37"><span class="calibre5">9.2.4. Defining and Initializing a Container</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Every container type defines a default constructor (&#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>). With the exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, the default constructor creates an empty container of the specified type. Again excepting <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, the other constructors take arguments that specify the size of the container and initial values for the elements.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Initializing a Container as a Copy of Another Container</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) we can copy a range of elements denoted by a pair of iterators.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To create a container as a copy of another container, the container and element types must match. When we pass iterators, there is no requirement that the container types be identical. Moreover, the element types in the new and original <a id="filepos2222871"/>containers can differ as long as it is possible to convert (&#167; <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a>, p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>) the elements we&#8217;re copying to the element type of the container we are initializing:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">each container has three elements, initialized from the given initializers</span></span></span><br class="calibre6"/>list&lt;string&gt; authors = {"Milton", "Shakespeare", "Austen"};<br class="calibre6"/>vector&lt;const char*&gt; articles = {"a", "an", "the"};<br class="calibre6"/>list&lt;string&gt; list2(authors);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: types match</span></span></span><br class="calibre6"/>deque&lt;string&gt; authList(authors); // <span><span class="calibre45"><span class="calibre16">error: container types don't match</span></span></span><br class="calibre6"/>vector&lt;string&gt; words(articles);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: element types must match</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: converts</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const char*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>forward_list&lt;string&gt; words(articles.begin(), articles.end());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When we initialize a container as a copy of another container, the container type and element type of both containers must be identical.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The constructor that takes two iterators uses them to denote a range of elements that we want to copy. As usual, the iterators mark the first and one past the last element to be copied. The new container has the same size as the number of elements in the range. Each element in the new container is initialized by the value of the corresponding element in the range.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Because the iterators denote a range, we can use this constructor to copy a subsequence of a container. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">it</span></tt></code> is an iterator denoting an element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">authors</span></tt></code>, we can write</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">copies up to but not including the element denoted by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">it</span></span></tt></span><br class="calibre6"/>deque&lt;string&gt; authList(authors.begin(), it);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2226365"/>List Initialization</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos2226442"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can list initialize (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) a container:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">each container has three elements, initialized from the given initializers</span></span></span><br class="calibre6"/>list&lt;string&gt; authors = {"Milton", "Shakespeare", "Austen"};<br class="calibre6"/>vector&lt;const char*&gt; articles = {"a", "an", "the"};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we do so, we explicitly specify values for each element in the container. For types other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, the initializer list also implicitly specifies the size of the container: The container will have as many elements as there are initializers.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Sequential Container Size-Related Constructors</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In addition to the constructors that sequential containers have in common with associative containers, we can also initialize the sequential containers (other than <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) from a size and an (optional) element initializer. If we do not supply an element initializer, the library creates a value-initialized one for us &#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a> (p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; ivec(10, -1);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">elements, each initialized to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-1</span></span></tt></span><br class="calibre6"/>list&lt;string&gt; svec(10, "hi!");&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s;</span></span></span>
<span><span class="calibre45"><span class="calibre16">each element is</span></span></span>&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">"hi!"</span></span></tt></span><br class="calibre6"/>forward_list&lt;int&gt; ivec(10);&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ten elements, each initialized to 0</span></span></span><br class="calibre6"/>deque&lt;string&gt; svec(10);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ten elements, each an empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">We can use the constructor that takes a size argument if the element type is a built-in type or a class type that has a default constructor (&#167; <a href="090-9.2._container_library_overview.html#filepos2188055">9.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2188055">329</a>). If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The constructors that take a size are valid <em class="calibre16">only</em> for sequential containers; they are not supported for the associative containers.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">array</span></span></tt></span></span></tt></code>s Have Fixed Size</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Just as the size of a built-in array is part of its type, the size of a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> is part of its type. When we define an <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, in addition to specifying the element type, we also specify the container size:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">array&lt;int, 42&gt;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">type is:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42 int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>array&lt;string, 10&gt; // <span><span class="calibre45"><span class="calibre16">type is:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">10 string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> type we must specify both the element type and the size:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">array&lt;int, 10&gt;::size_type i; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">type includes element type and size</span></span></span><br class="calibre6"/>array&lt;int&gt;::size_type j;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a type</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the size is part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>&#8217;s type, <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> does not support the normal container constructors. Those constructors, implicitly or explicitly, determine the size of the container. It would be redundant (at best) and error-prone to allow users to pass a size argument to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> constructor.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The fixed-size nature of <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s also affects the behavior of the constructors that <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> does define. Unlike the other containers, a default-constructed <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>
<a id="filepos2234338"/>is not empty: It has as many elements as its size. These elements are default initialized (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>) just as are elements in a built-in array (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>). If we list initialize the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, the number of the initializers must be equal to or less than the size of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>. If there are fewer initializers than the size of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>, the initializers are used for the first elements and any remaining elements are value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>). In both cases, if the element type is a class type, the class must have a default constructor in order to permit value initialization:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">array&lt;int, 10&gt; ia1;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ten default-initialized</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>array&lt;int, 10&gt; ia2 = {0,1,2,3,4,5,6,7,8,9};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">list initialization</span></span></span><br class="calibre6"/>array&lt;int, 10&gt; ia3 = {42};&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia3[0]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">42,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">remaining elements are</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">It is worth noting that although we cannot copy or assign objects of built-in array types (&#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), there is no such restriction on <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int digs[10] = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>int cpy[10] = digs;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no copy or assignment for built-in arrays</span></span></span><br class="calibre6"/>array&lt;int, 10&gt; digits = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>array&lt;int, 10&gt; copy = digits;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: so long as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">types match</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As with any container, the initializer must have the same type as the container we are creating. For <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s, the element type and the size must be the same, because the size of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> is part of its type.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.11:</strong> Show an example of each of the six ways to create and initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Explain what values each <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> contains.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.12:</strong> Explain the differences between the constructor that takes a container to copy and the constructor that takes two iterators.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.13:</strong> How would you initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;double&gt;</span></tt></code> from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;int&gt;</span></tt></code>? From a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>? Write code to check your answers.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2239281" class="calibre37"><span class="calibre5">9.2.5. Assignment and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The assignment-related operators, listed in <a href="090-9.2._container_library_overview.html#filepos2240913">Table 9.4</a> (overleaf) act on the entire container. The assignment operator replaces the entire range of elements in the left-hand container with copies of the elements from the right-hand operand:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">c1 = c2;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">replace the contents of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with a copy of the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c2</span></span></tt></span><br class="calibre6"/>c1 = {a,b,c}; // <span><span class="calibre45"><span class="calibre16">after the assignment</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">c1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">3</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2240913"/>Table 9.4. Container Assignment Operations</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00050.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre14">After the first assignment, the left- and right-hand containers are equal. If the containers had been of unequal size, after the assignment both containers would have the size of the right-hand operand. After the second assignment, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">c1</span></tt></code> is 3, which is the number of values provided in the braced list.</p><div class="calibre15">&#160;</div>
<p class="calibre25"><a id="filepos2241618"/>Unlike built-in arrays, the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> type does allow assignment. The left-and right-hand operands must have the same type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">array&lt;int, 10&gt; a1 = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>array&lt;int, 10&gt; a2 = {0}; // <span><span class="calibre45"><span class="calibre16">elements all have value</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>a1 = a2;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">replaces elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a1</span></span></tt></span><br class="calibre6"/>a2 = {0}; // <span><span class="calibre45"><span class="calibre16">error: cannot assign to an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">array</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from a braced list</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the size of the right-hand operand might differ from the size of the left-hand operand, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> type does not support <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> and it does not allow assignment from a braced list of values.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">assign</span></span></tt></span></span></tt></code> (Sequential Containers Only)</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The assignment operator requires that the left-hand and right-hand operands have the same type. It copies all the elements from the right-hand operand into the left-hand operand. The sequential containers (except <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>) also define a member named <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> that lets us assign from a different but compatible type, or assign from a subsequence of a container. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> operation replaces all the elements in the left-hand container with (copies of) the elements specified by its arguments. For example, we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> to assign a range of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code> values from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> into a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">list&lt;string&gt; names;<br class="calibre6"/>vector&lt;const char*&gt; oldstyle;<br class="calibre6"/>names = oldstyle;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: container types don't match</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: can convert from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const char*</span></span></tt></span><span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>names.assign(oldstyle.cbegin(), oldstyle.cend());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2245488"/>The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> replaces the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">names</span></tt></code> with copies of the elements in the range denoted by the iterators. The arguments to <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> determine how many elements and what values the container will have.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Because the existing elements are replaced, the iterators passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> must not refer to the container on which <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> is called.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">assign</span></tt></code> takes an integral value and an element value. It replaces the elements in the container with the specified number of elements, each of which has the specified element value:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">slist1.clear();</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">followed by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">slist1.insert(slist1.begin(), 10, "Hiya!");</span></span></tt></span><br class="calibre6"/>list&lt;string&gt; slist1(1);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">one element, which is the empty</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>slist1.assign(10, "Hiya!"); // <span><span class="calibre45"><span class="calibre16">ten elements; each one is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Hiya</span></span></tt></span> !</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">swap</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> operation exchanges the contents of two containers of the same type. After the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, the elements in the two containers are interchanged:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; svec1(10); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with ten elements</span></span></span><br class="calibre6"/>vector&lt;string&gt; svec2(24); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with 24 elements</span></span></span><br class="calibre6"/>swap(svec1, svec2);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">After the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap, svec1</span></tt></code> contains 24 <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> elements and <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec2</span></tt></code> contains ten. With the exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s, swapping two containers is guaranteed to be fast&#8212;the elements themselves are not swapped; internal data structures are swapped.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Excepting <code class="calibre23"><tt class="calibre23"><span class="calibre24">array, swap</span></tt></code> does not copy, delete, or insert any elements and is guaranteed to run in constant time.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">The fact that elements are not moved means that, with the exception of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, iterators, references, and pointers into the containers are not invalidated. They refer to the same elements as they did before the swap. However, after the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, those elements are in a different container. For example, had <code class="calibre23"><tt class="calibre23"><span class="calibre24">iter</span></tt></code> denoted the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> at position <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec1 [3]</span></tt></code> before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, it will denote the element at position <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec2[3]</span></tt></code> after the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. Differently from the containers, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> may invalidate iterators, references and pointers.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Unlike how <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> behaves for the other containers, swapping two <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s does exchange the elements. As a result, swapping two <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>s requires time proportional to the number of elements in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">After the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>, pointers, references, and iterators remain bound to the same element they denoted before the <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. Of course, the value of that element has been swapped with the corresponding element in the other <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2252464"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">In the new library, the containers offer both a member and nonmember version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. Earlier versions of the library defined only the member version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>. The nonmember <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code> is of most importance in generic programs. As a matter of habit, it is best to use the nonmember version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">swap</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2253151"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.5</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.14:</strong> Write a program to assign the elements from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code> pointers to C-style character strings to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2253841" class="calibre37"><span class="calibre5">9.2.6. Container Size Operations</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">With one exception, the container types have three size-related operations. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> member (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">87</a>) returns the number of elements in the container; <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code> returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">bool</span></tt></code> that is <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> is zero and <code class="calibre23"><tt class="calibre23"><span class="calibre24">false</span></tt></code> otherwise; and <code class="calibre23"><tt class="calibre23"><span class="calibre24">max_size</span></tt></code> returns a number that is greater than or equal to the number of elements a container of that type can contain. For reasons we&#8217;ll explain in the next section, <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code> provides <code class="calibre23"><tt class="calibre23"><span class="calibre24">max_size</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">empty</span></tt></code>, but not <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos2255277" class="calibre37"><span class="calibre5">9.2.7. Relational Operators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Every container type supports the equality operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">!=</span></tt></code>); all the containers except the unordered associative containers also support the relational operators (<code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;=</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;=</span></tt></code>). The right- and left-hand operands must be the same kind of container and must hold elements of the same type. That is, we can compare a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code> only with another <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>. We cannot compare a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code> with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;int&gt;</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;double&gt;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Comparing two containers performs a pairwise comparison of the elements. These operators work similarly to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> relationals (&#167; <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>):</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The following examples illustrate how these operators work:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; v1 = { 1, 3, 5, 7, 9, 12 };<br class="calibre6"/>vector&lt;int&gt; v2 = { 1, 3, 9 };<br class="calibre6"/>vector&lt;int&gt; v3 = { 1, 3, 5, 7 };<br class="calibre6"/>vector&lt;int&gt; v4 = { 1, 3, 5, 7, 9, 12 };<br class="calibre6"/>v1 &lt; v2&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true; v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">differ at element</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">[2]</span></span></tt></span><span><span class="calibre45"><span class="calibre16">:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span><span><tt class="calibre23"><span class="calibre46"><span class="calibre16">[2]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is less than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v2[2]</span></span></tt></span><br class="calibre6"/>v1 &lt; v3&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">all elements are equal, but</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has fewer of them;</span></span></span><br class="calibre6"/>v1 == v4 // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">true;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">each element is equal and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v4</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">have the same</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size()</span></span></tt></span><br class="calibre6"/>v1 == v2 // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false; v2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has fewer elements than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">v1</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2260185"/>Relational Operators Use Their Element&#8217;s Relational Operator</span></h5><div class="calibre38">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">The container equality operators use the element&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> operator, and the relational operators use the element&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator. If the element type doesn&#8217;t support the required operator, then we cannot use the corresponding operations on containers holding that type. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> type that we defined in <a href="072-chapter_7._classes.html#filepos1741323">Chapter 7</a> does not define either the <code class="calibre23"><tt class="calibre23"><span class="calibre24">==</span></tt></code> or the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operation. Therefore, we cannot compare two containers that hold <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code> elements:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;Sales_data&gt; storeA, storeB;<br class="calibre6"/>if (storeA &lt; storeB) // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Sales_data</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has no less-than operator</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.2.7</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.15:</strong> Write a program to determine whether two <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>s are equal.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.16:</strong> Repeat the previous program, but compare elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list&lt;int&gt;</span></tt></code> to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt;</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.17:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">c1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">c2</span></tt></code> are containers, what (if any) constraints does the following usage place on the types of <code class="calibre23"><tt class="calibre23"><span class="calibre24">c1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">c2?</span></tt></code></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (c1 &lt; c2)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="089-9.1._overview_of_the_sequential_containers.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="091-9.3._sequential_container_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
