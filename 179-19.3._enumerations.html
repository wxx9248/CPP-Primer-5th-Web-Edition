<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>19.3. Enumerations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="178-19.2._runtime_type_identification.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="180-19.4._pointer_to_class_member.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos5202480" class="calibre29"><span class="bold">19.3. Enumerations</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14"><strong class="calibre5"><a id="filepos5202609" href="186-defined_terms.html#filepos5400473">Enumerations</a></strong> let us group together sets of integral constants. Like classes, each enumeration defines a new type. Enumerations are literal types (&#167; <a href="077-7.5._constructors_revisited.html#filepos2019288">7.5.6</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2019288">299</a>).</p><div class="calibre15">&#160;</div>
<p class="calibre25">C++ has two kinds of enumerations: scoped and unscoped. The new standard introduced <strong class="calibre5"><a id="filepos5203043" href="186-defined_terms.html#filepos5408904">scoped enumerations</a></strong>. We define a scoped enumeration using the keywords <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum class</span></tt></code> (or, equivalently, <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum struct</span></tt></code>), followed by the enumeration name and a comma-separated list of <strong class="calibre5"><a id="filepos5203408" href="186-defined_terms.html#filepos5400698">enumerators</a></strong> enclosed in curly braces. A semicolon follows the close curly:</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos5203580"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">enum class open_modes {input, output, append};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we defined an enumeration type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">open_modes</span></tt></code> that has three enumerators: <code class="calibre23"><tt class="calibre23"><span class="calibre24">input</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">output</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">append</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We define an <strong class="calibre5"><a id="filepos5204446" href="186-defined_terms.html#filepos5411279">unscoped enumeration</a></strong> by omitting the <code class="calibre23"><tt class="calibre23"><span class="calibre24">class</span></tt></code> (or <code class="calibre23"><tt class="calibre23"><span class="calibre24">struct</span></tt></code>) keyword. The enumeration name is optional in an unscoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">enum color {red, yellow, green};&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">unscoped enumeration</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">unnamed, unscoped</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">enum</span></span></tt></span><br class="calibre6"/>enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> is unnamed, we may define objects of that type only as part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> definition. As with a class definition, we can provide a comma-separated list of declarators between the close curly and the semicolon that ends the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> definition (&#167; <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>).</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos5206115"/>Enumerators</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The names of the enumerators in a scoped enumeration follow normal scoping rules and are inaccessible outside the scope of the enumeration. The enumerator names in an unscoped enumeration are placed into the same scope as the enumeration itself:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">enum color {red, yellow, green};&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">unscoped enumeration</span></span></span><br class="calibre6"/>enum stoplight {red, yellow, green};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: redefines enumerators</span></span></span><br class="calibre6"/>enum class peppers {red, yellow, green}; // <span><span class="calibre45"><span class="calibre16">ok: enumerators are hidden</span></span></span><br class="calibre6"/>color eyes = green; // <span><span class="calibre45"><span class="calibre16">ok: enumerators are in scope for an unscoped enumeration</span></span></span><br class="calibre6"/>peppers p = green;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: enumerators from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">peppers</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are not in scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">color::green is</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">in scope but has the wrong type</span></span></span><br class="calibre6"/>color hair = color::red;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: we can explicitly access the enumerators</span></span></span><br class="calibre6"/>peppers p2 = peppers::red; // <span><span class="calibre45"><span class="calibre16">ok: using</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">red</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">peppers</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">By default, enumerator values start at 0 and each enumerator has a value 1 greater than the preceding one. However, we can also supply initializers for one or more enumerators:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">enum class intTypes {<br class="calibre6"/>&#160;&#160;&#160;&#160;charTyp = 8, shortTyp = 16, intTyp = 16,<br class="calibre6"/>&#160;&#160;&#160;&#160;longTyp = 32, long_longTyp = 64<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">As we see with the enumerators for <code class="calibre23"><tt class="calibre23"><span class="calibre24">intTyp</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">shortTyp</span></tt></code>, an enumerator value need not be unique. When we omit an initializer, the enumerator has a value 1 greater than the preceding enumerator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Enumerators are <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> and, if initialized, their initializers must be constant expressions (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>). Consequently, each enumerator is itself a constant expression. Because the enumerators are constant expressions, we can use them where a constant expression is required. For example, we can define <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> variables of enumeration type:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr intTypes charbits = intTypes::charTyp;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Similarly, we can use an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> as the expression in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">switch</span></tt></code> statement and use the value of its enumerators as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">case</span></tt></code> labels (&#167; <a href="056-5.3._conditional_statements.html#filepos1278126">5.3.2</a>, p. <a href="056-5.3._conditional_statements.html#filepos1278126">178</a>). For the same reason, we can also use an enumeration type as a nontype template parameter (&#167; <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">654</a>). and can initialize class <code class="calibre23"><tt class="calibre23"><span class="calibre24">static</span></tt></code> data members of enumeration type inside the class definition (&#167; <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">302</a>).</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Like Classes, Enumerations Define New Types</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">So long as the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> is named, we can define and initialize objects of that type. An <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> object may be initialized or assigned only by one of its enumerators or by another object of the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">open_modes om = 2;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">open_modes</span></span></tt></span><br class="calibre6"/>om = open_modes::input; // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">input</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an enumerator of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">open_modes</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos5212883"/>Objects or enumerators of an unscoped enumeration type are automatically converted to an integral type. As a result, they can be used where an integral value is required:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = color::red;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: unscoped enumerator implicitly converted to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int j = peppers::red; // <span><span class="calibre45"><span class="calibre16">error: scoped enumerations are not implicitly converted</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Specifying the Size of an <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">enum</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos5213988"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Although each <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> defines a unique type, it is represented by one of the built-in integral types. Under the new standard, we may specify that type by following the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> name with a colon and the name of the type we want to use:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">enum intValues : unsigned long long {<br class="calibre6"/>&#160;&#160;&#160;&#160;charTyp = 255, shortTyp = 65535, intTyp = 65535,<br class="calibre6"/>&#160;&#160;&#160;&#160;longTyp = 4294967295UL,<br class="calibre6"/>&#160;&#160;&#160;&#160;long_longTyp = 18446744073709551615ULL<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we do not specify the underlying type, then by default scoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>s have <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> as the underlying type. There is no default for unscoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>s; all we know is that the underlying type is large enough to hold the enumerator values. When the underlying type is specified (including implicitly specified for a scoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>), it is an error for an enumerator to have a value that is too large to fit in that type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Being able to specify the underlying type of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> lets us control the type used across different implementations. We can be confident that our program compiled under one implementation will generate the same code when we compile it on another.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Forward Declarations for Enumerations</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos5216202"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Under the new standard, we can forward declare an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>. An <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> forward declaration must specify (implicitly or explicitly) the underlying size of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">forward declaration of unscoped enum</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">named</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">intValues</span></span></span><br class="calibre6"/>enum intValues : unsigned long long; // <span><span class="calibre45"><span class="calibre16">unscoped, must specify a type</span></span></span><br class="calibre6"/>enum class open_modes;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">scoped</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">enum</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s can use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by default</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because there is no default size for an unscoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>, every declaration must include the size of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>. We can declare a scoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> without specifying a size, in which case the size is implicitly defined as <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with any declaration, all the declarations and the definition of a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> must match one another. In the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code>s, this requirement means that the size of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> must be the same across all declarations and the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> definition. Moreover, we cannot declare a name as an unscoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> in one context and redeclare it as a scoped <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> later:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">error: declarations and definition must agree whether the enum is scoped or unscoped</span></span></span><br class="calibre6"/>enum class intValues;<br class="calibre6"/>enum intValues;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">intValues</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">previously declared as scoped</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">enum</span></span></tt></span><br class="calibre6"/>enum intValues : long; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">intValues</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">previously declared as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos5220246"/>Parameter Matching and Enumerations</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Because an object of <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> type may be initialized only by another object of that <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> type or by one of its enumerators (&#167; <a href="179-19.3._enumerations.html#filepos5202480">19.3</a>, p. <a href="179-19.3._enumerations.html#filepos5202480">833</a>), an integral value that happens to have the same value as an enumerator cannot be used to call a function expecting an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">unscoped enumeration; the underlying type is machine dependent</span></span></span><br class="calibre6"/>enum Tokens {INLINE = 128, VIRTUAL = 129};<br class="calibre6"/>void ff(Tokens);<br class="calibre6"/>void ff(int);<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;Tokens curTok = INLINE;<br class="calibre6"/>&#160;&#160;&#160;&#160;ff(128);&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">exactly matches</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff(int)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ff(INLINE); // <span><span class="calibre45"><span class="calibre16">exactly matches</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff(Tokens)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ff(curTok); // <span><span class="calibre45"><span class="calibre16">exactly matches</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ff(Tokens)</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return 0;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Although we cannot pass an integral value to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> parameter, we can pass an object or enumerator of an unscoped enumeration to a parameter of integral type. When we do so, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> value promotes to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> or to a larger integral type. The actual promotion type depends on the underlying type of the enumeration:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">void newf(unsigned char);<br class="calibre6"/>void newf(int);<br class="calibre6"/>unsigned char uc = VIRTUAL;<br class="calibre6"/>newf(VIRTUAL);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">newf(int)</span></span></tt></span><br class="calibre6"/>newf(uc);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">newf(unsigned char</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum Tokens</span></tt></code> has only two enumerators, the larger of which has the value <code class="calibre23"><tt class="calibre23"><span class="calibre24">129</span></tt></code>. That value can be represented by the type <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code>, and many compilers will use <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code> as the underlying type for <code class="calibre23"><tt class="calibre23"><span class="calibre24">Tokens</span></tt></code>. Regardless of its underlying type, objects and the enumerators of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Tokens</span></tt></code> are promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Enumerators and values of an <code class="calibre23"><tt class="calibre23"><span class="calibre24">enum</span></tt></code> type are not promoted to <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned char</span></tt></code>, even if the values of the enumerators would fit.</p><div class="calibre15">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="178-19.2._runtime_type_identification.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="180-19.4._pointer_to_class_member.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
