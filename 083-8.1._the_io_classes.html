<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>8.1. The IO Classes</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="082-chapter_8._the_io_library.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="084-8.2._file_input_and_output.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2076693" class="calibre29"><span class="bold">8.1. The IO Classes</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">The IO types and objects that we&#8217;ve used so far manipulate <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> data. By default these objects are connected to the user&#8217;s console window. Of course, real programs cannot be limited to doing IO solely to or from a console window. Programs often need to read or write named files. Moreover, it can be convenient to use IO operations to process the characters in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Applications also may have to read and write languages that require wide-character support.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To support these different kinds of IO processing, the library defines a collection of IO types in addition to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> types that we have already used. These types, which are listed in <a href="083-8.1._the_io_classes.html#filepos2078474">Table 8.1</a>, are defined in three separate headers: <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostream</span></tt></code> defines the basic types used to read from and write to a stream, <code class="calibre23"><tt class="calibre23"><span class="calibre24">fstream</span></tt></code> defines the types used to read and write named files, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">sstream</span></tt></code> defines the types used to read and write in-memory <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s.</p><div class="calibre22">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2078474"/>Table 8.1. IO Library Types and Headers</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00041.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25"><a id="filepos2078675"/>To support languages that use wide characters, the library defines a set of types and objects that manipulate <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code> data (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">32</a>). The names of the wide-character versions begin with a <code class="calibre23"><tt class="calibre23"><span class="calibre24">w</span></tt></code>. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">wcin, wcout</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">wcerr</span></tt></code> are the wide-character objects that correspond to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin, cout</span></tt></code>, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code>, respectively. The wide-character types and objects are defined in the same header as the plain <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> types. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">fstream</span></tt></code> header defines both the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">wifstream</span></tt></code> types.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Relationships among the IO Types</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Conceptually, neither the kind of device nor the character size affects the IO operations we want to perform. For example, we&#8217;d like to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> to read data regardless of whether we&#8217;re reading a console window, a disk file, or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. Similarly, we&#8217;d like to use that operator regardless of whether the characters we read fit in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> or require a <code class="calibre23"><tt class="calibre23"><span class="calibre24">wchar_t</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The library lets us ignore the differences among these different kinds of streams by using <strong class="calibre5"><a id="filepos2080823" href="087-defined_terms.html#filepos2168159">inheritance</a></strong>. As with templates (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>), we can use classes related by inheritance without understanding the details of how inheritance works. We&#8217;ll cover how C++ supports inheritance in <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a> and in &#167; <a href="173-18.3._multiple_and_virtual_inheritance.html#filepos5026780">18.3</a> (p. <a href="173-18.3._multiple_and_virtual_inheritance.html#filepos5026780">802</a>).</p><div class="calibre22">&#160;</div>
<p class="calibre25">Briefly, inheritance lets us say that a particular class inherits from another class. Ordinarily, we can use an object of an inherited class as if it were an object of the same type as the class from which it inherits.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The types <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">istringstream</span></tt></code> inherit from <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code>. Thus, we can use objects of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">istringstream</span></tt></code> as if they were <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> objects. We can use objects of these types in the same ways as we have used <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code>. For example, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">getline</span></tt></code> on an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">istringstream</span></tt></code> object, and we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> to read data from an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ifstream</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">istringstream</span></tt></code>. Similarly, the types <code class="calibre23"><tt class="calibre23"><span class="calibre24">ofstream</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostringstream</span></tt></code> inherit from <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code>. Therefore, we can use objects of these types in the same ways that we have used <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Everything that we cover in the remainder of this section applies equally to plain streams, file streams, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> streams and to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> or wide-character stream versions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2083864" class="calibre37"><span class="calibre5">8.1.1. No Copy or Assign for IO Objects</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">As we saw in &#167; <a href="073-7.1._defining_abstract_data_types.html#filepos1792181">7.1.3</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1792181">261</a>), we cannot copy or assign objects of the IO types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ofstream out1, out2;<br class="calibre6"/>out1 = out2;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign stream objects</span></span></span><br class="calibre6"/>ofstream print(ofstream); // <span><span class="calibre45"><span class="calibre16">error: can't initialize the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ofstream</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">parameter</span></span></span><br class="calibre6"/>out2 = print(out2);&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot copy stream objects</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because we can&#8217;t copy the IO types, we cannot have a parameter or return type that is one of the stream types (&#167; <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>). Functions that do IO typically pass and return the stream through references. Reading or writing an IO object changes its state, so the reference must not be <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h4 id="filepos2085669" class="calibre37"><span class="calibre5"><a id="filepos2085702"/>8.1.2. Condition States</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Inherent in doing IO is the fact that errors can occur. Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct. The IO classes define functions and flags, listed in <a href="083-8.1._the_io_classes.html#filepos2086262">Table 8.2</a>, that let us access and manipulate the <strong class="calibre5"><a id="filepos2086111" href="087-defined_terms.html#filepos2165704">condition state</a></strong> of a stream.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2086262"/>Table 8.2. IO Library Condition State</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00042.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">As an example of an IO error, consider the following code:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ival;<br class="calibre6"/>cin &gt;&gt; ival;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">If we enter <code class="calibre23"><tt class="calibre23"><span class="calibre24">Boo</span></tt></code> on the standard input, the read will fail. The input operator expected to read an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> but got the character <code class="calibre23"><tt class="calibre23"><span class="calibre24">B</span></tt></code> instead. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> will be put in an error state. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> will be in an error state if we enter an end-of-file.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Once an error has occurred, subsequent IO operations on that stream will fail. We can read from or write to a stream only when it is in a non-error state. Because a stream might be in an error state, code ordinarily should check whether a stream is okay before attempting to use it. The easiest way to determine the state of a stream object is to use that object as a condition:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok: read operation successful . . .</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> condition checks the state of the stream returned from the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;&gt;</span></tt></code> expression. If that input operation succeeds, the state remains valid and the condition will succeed.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Interrogating the State of a Stream</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Using a stream as a condition tells us only whether the stream is valid. It does not tell us what happened. Sometimes we also need to know why the stream is invalid. For example, what we do after hitting end-of-file is likely to differ from what we&#8217;d do if we encounter an error on the IO device.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The IO library defines a machine-dependent integral type named <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostate</span></tt></code> that it uses to convey information about the state of a stream. This type is used as a collection of bits, in the same way that we used the <code class="calibre23"><tt class="calibre23"><span class="calibre24">quiz1</span></tt></code> variable in &#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a> (p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">154</a>). The IO classes define four <code class="calibre23"><tt class="calibre23"><span class="calibre24">constexpr</span></tt></code> values (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>) of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostate</span></tt></code> that represent particular bit patterns. These values are used to indicate particular kinds of IO conditions. They can be used with the bitwise operators (&#167; <a href="046-4.8._the_bitwise_operators.html#filepos1120642">4.8</a>, p. <a href="046-4.8._the_bitwise_operators.html#filepos1120642">152</a>) to test or set multiple flags in one operation.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">badbit</span></tt></code> indicates a system-level failure, such as an unrecoverable read or write error. It is usually not possible to use a stream once <code class="calibre23"><tt class="calibre23"><span class="calibre24">badbit</span></tt></code> has been set. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">failbit</span></tt></code> is set after a recoverable error, such as reading a character when numeric data was expected. It is often possible to correct such problems and continue using the stream. Reaching end-of-file sets both <code class="calibre23"><tt class="calibre23"><span class="calibre24">eofbit</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">failbit</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">goodbit</span></tt></code>, which is guaranteed to have the value 0, indicates no failures on the stream. If any of <code class="calibre23"><tt class="calibre23"><span class="calibre24">badbit</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">failbit</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">eofbit</span></tt></code> are set, then a condition that evaluates that stream will fail.</p><div class="calibre22">&#160;</div>
<p class="calibre25">The library also defines a set of functions to interrogate the state of these flags. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">good</span></tt></code> operation returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if none of the error bits is set. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad</span></tt></code>, <code class="calibre23"><tt class="calibre23"><span class="calibre24">fail</span></tt></code>, <a id="filepos2091624"/>and <code class="calibre23"><tt class="calibre23"><span class="calibre24">eof</span></tt></code> operations return <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> when the corresponding bit is on. In addition, <code class="calibre23"><tt class="calibre23"><span class="calibre24">fail</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad</span></tt></code> is set. By implication, the right way to determine the overall state of a stream is to use either <code class="calibre23"><tt class="calibre23"><span class="calibre24">good</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">fail</span></tt></code>. Indeed, the code that is executed when we use a stream as a condition is equivalent to calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">!fail()</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">eof</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">bad</span></tt></code> operations reveal only whether those specific errors have occurred.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Managing the Condition State</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">rdstate</span></tt></code> member returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostate</span></tt></code> value that corresponds to the current state of the stream. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">setstate</span></tt></code> operation turns on the given condition bit(s) to indicate that a problem occurred. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> member is overloaded (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">230</a>): One version takes no arguments and a second version takes a single argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostate</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> that takes no arguments turns off all the failure bits. After <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear()</span></tt></code>, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">good</span></tt></code> returns <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code>. We might use these members as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">remember the current state of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span><br class="calibre6"/>auto old_state = cin.rdstate();&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">remember the current state of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span><br class="calibre6"/>cin.clear();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">make</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">valid</span></span></span><br class="calibre6"/>process_input(cin);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span><br class="calibre6"/>cin.setstate(old_state);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">now reset</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to its old state</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">The version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">clear</span></tt></code> that takes an argument expects an <code class="calibre23"><tt class="calibre23"><span class="calibre24">iostate</span></tt></code> value that represents the new state of the stream. To turn off a single condition, we use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">rdstate</span></tt></code> member and the bitwise operators to produce the desired new state.</p><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2096162"/>For example, the following turns off <code class="calibre23"><tt class="calibre23"><span class="calibre24">failbit</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">badbit</span></tt></code> but leaves <code class="calibre23"><tt class="calibre23"><span class="calibre24">eofbit</span></tt></code> untouched:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">turns off</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">failbit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">badbit</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">but all other bits unchanged</span></span></span><br class="calibre6"/>cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 8.1.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 8.1:</strong> Write a function that takes and returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream&amp;</span></tt></code>. The function should read the stream until it hits end-of-file. The function should print what it reads to the standard output. Reset the stream so that it is valid before returning the stream.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 8.2:</strong> Test your function by calling it, passing <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> as an argument.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 8.3:</strong> What causes the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> to terminate?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><br class="calibre6"/>while (cin &gt;&gt; i) /*&#160;&#160;...&#160;&#160;&#160;&#160;*/</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos2098548" class="calibre37"><span class="calibre5">8.1.3. Managing the Output Buffer</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Each output stream manages a buffer, which it uses to hold the data that the program reads and writes. For example, when the following code is executed</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">os &lt;&lt; "please enter a value: ";</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">the literal string might be printed immediately, or the operating system might store the data in a buffer to be printed later. Using a buffer allows the operating system to combine several output operations from our program into a single system-level write. Because writing to a device can be time-consuming, letting the operating system combine several output operations into a single write can provide an important performance boost.</p><div class="calibre15">&#160;</div>
<p class="calibre25">There are several conditions that cause the buffer to be flushed&#8212;that is, to be written&#8212;to the actual output device or file:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The program completes normally. All output buffers are flushed as part of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">return</span></tt></code> from <code class="calibre23"><tt class="calibre23"><span class="calibre24">main</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; At some indeterminate time, the buffer can become full, in which case it will be flushed before writing the next value.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We can flush the buffer explicitly using a manipulator such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">endl</span></tt></code> (&#167; <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">7</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unitbuf</span></tt></code> manipulator to set the stream&#8217;s internal state to empty the buffer after each output operation. By default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">unitbuf</span></tt></code> is set for <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code>, so that writes to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code> are flushed immediately.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; An output stream might be tied to another stream. In this case, the buffer of the tied stream is flushed whenever the tied stream is read or written. By default, <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code> are both tied to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>. Hence, reading <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code> or writing to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code> flushes the buffer in <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos2101910"/>Flushing the Output Buffer</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Our programs have already used the <code class="calibre23"><tt class="calibre23"><span class="calibre24">endl</span></tt></code> manipulator, which ends the current line and flushes the buffer. There are two other similar manipulators: <code class="calibre23"><tt class="calibre23"><span class="calibre24">flush</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ends. flush</span></tt></code> flushes the stream but adds no characters to the output; <code class="calibre23"><tt class="calibre23"><span class="calibre24">ends</span></tt></code> inserts a null character into the buffer and then flushes it:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; "hi!" &lt;&lt; endl;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">writes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and a newline, then flushes the buffer</span></span></span><br class="calibre6"/>cout &lt;&lt; "hi!" &lt;&lt; flush;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">writes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hi,</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">then flushes the buffer; adds no data</span></span></span><br class="calibre6"/>cout &lt;&lt; "hi!" &lt;&lt; ends;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">writes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">hi</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and a null, then flushes the buffer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">unitbuf</span></span></tt></span></span></tt></code> Manipulator</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">If we want to flush after every output, we can use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">unitbuf</span></tt></code> manipulator. This manipulator tells the stream to do a <code class="calibre23"><tt class="calibre23"><span class="calibre24">flush</span></tt></code> after every subsequent write. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">nounitbuf</span></tt></code> manipulator restores the stream to use normal, system-managed buffer flushing:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; unitbuf;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">all writes will be flushed immediately</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">any output is flushed immediately, no buffering</span></span></span><br class="calibre6"/>cout &lt;&lt; nounitbuf;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">returns to normal buffering</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Caution: Buffers Are Not Flushed If the Program Crashes</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Output buffers are <em class="calibre16">not</em> flushed if the program terminates abnormally. When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">When you debug a program that has crashed, it is essential to make sure that any output you <em class="calibre16">think</em> should have been written was actually flushed. Countless hours of programmer time have been wasted tracking through code that appeared not to have executed when in fact the buffer had not been flushed and the output was pending when the program crashed.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Tying Input and Output Streams Together</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">When an input stream is tied to an output stream, any attempt to read the input stream will first flush the buffer associated with the output stream. The library ties <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cin</span></tt></code>, so the statement</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cin &gt;&gt; ival;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">causes the buffer associated with <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> to be flushed.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Interactive systems usually should tie their input stream to their output stream. Doing so means that all output, which might include prompts to the user, will be written before attempting to read the input.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">There are two overloaded (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">230</a>) versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">tie:</span></tt></code> One version takes no argument and returns a pointer to the output stream, if any, to which this object is currently tied. The function returns the null pointer if the stream is not tied.</p><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos2108081"/>The second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">tie</span></tt></code> takes a pointer to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> and ties itself to that <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code>. That is, <code class="calibre23"><tt class="calibre23"><span class="calibre24">x.tie(&amp;o)</span></tt></code> ties the stream <code class="calibre23"><tt class="calibre23"><span class="calibre24">x</span></tt></code> to the output stream <code class="calibre23"><tt class="calibre23"><span class="calibre24">o</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can tie either an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> or an <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code> object to another <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cin.tie(&amp;cout);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">illustration only: the library ties</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">for us</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">old_tie</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the stream (if any) currently tied to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span><br class="calibre6"/>ostream *old_tie = cin.tie(nullptr); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is no longer tied</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ties</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cerr</span></span></tt></span><span><span class="calibre45"><span class="calibre16">; not a good idea because</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be tied to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span><br class="calibre6"/>cin.tie(&amp;cerr);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">reading cin flushes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cerr</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, not</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span><br class="calibre6"/>cin.tie(old_tie); // <span><span class="calibre45"><span class="calibre16">reestablish normal tie between</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cin</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">To tie a given stream to a new output stream, we pass <code class="calibre23"><tt class="calibre23"><span class="calibre24">tie</span></tt></code> a pointer to the new stream. To untie the stream completely, we pass a null pointer. Each stream can be tied to at most one stream at a time. However, multiple streams can tie themselves to the same <code class="calibre23"><tt class="calibre23"><span class="calibre24">ostream</span></tt></code>.</p><div class="calibre15">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="082-chapter_8._the_io_library.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="084-8.2._file_input_and_output.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
