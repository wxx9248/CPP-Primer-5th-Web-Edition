<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>3.5. Arrays</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="033-3.4._introducing_iterators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="035-3.6._multidimensional_arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos853883" class="calibre29"><span class="bold">3.5. Arrays</span></h3><div class="calibre12">&#160;</div>
<p class="calibre14">An array is a data structure that is similar to the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> type (&#167; <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>) but offers a different trade-off between performance and flexibility. Like a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, an array is a container of unnamed objects of a single type that we access by position. Unlike a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, arrays have fixed size; we cannot add elements to an array. Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If you don&#8217;t know exactly how many elements you need, use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos855259" class="calibre37"><span class="calibre5">3.5.1. Defining and Initializing Built-in Arrays</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Arrays are a compound type (&#167; <a href="023-2.3._compound_types.html#filepos394806">2.3</a>, p. <a href="023-2.3._compound_types.html#filepos394806">50</a>). An array declarator has the form <code class="calibre23"><tt class="calibre23"><span class="calibre24">a[d]</span></tt></code>, where <code class="calibre23"><tt class="calibre23"><span class="calibre24">a</span></tt></code> is the name being defined and <code class="calibre23"><tt class="calibre23"><span class="calibre24">d</span></tt></code> is the dimension of the array. The dimension specifies the number of elements and must be greater than zero. The number of elements in an array is part of the array&#8217;s type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned cnt = 42;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">not a constant expression</span></span></span><br class="calibre6"/>constexpr unsigned sz = 42; // <span><span class="calibre45"><span class="calibre16">constant expression</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">constexpr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">see &#167; 2.4.4 (p. 66)</span></span></span><br class="calibre6"/>int arr[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *parr[sz];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of 42 pointers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>string bad[cnt];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cnt</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a constant expression</span></span></span><br class="calibre6"/>string strs[get_size()]; // <span><span class="calibre45"><span class="calibre16">ok if</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">get_size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">constexpr</span></span></tt></span>, <span><span class="calibre45"><span class="calibre16">error otherwise</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">By default, the elements in an array are default initialized (&#167; <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>).</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">As with variables of built-in type, a default-initialized array of built-in type that is defined inside a function will have undefined values.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">When we define an array, we must specify a type for the array. We cannot use <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> to deduce the type from a list of initializers. As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, arrays hold objects. Thus, there are no arrays of references.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos859478"/>Explicitly Initializing Array Elements</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can list initialize (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) the elements in an array. When we do so, we can omit the dimension. If we omit the dimension, the compiler infers it from the number of initializers. If we specify a dimension, the number of initializers must not exceed the specified size. If the dimension is greater than the number of initializers, the initializers are used for the first elements and any remaining elements are value initialized (&#167; <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const unsigned sz = 3;<br class="calibre6"/>int ia1[sz] = {0,1,2};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of three</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">with values</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0, 1, 2</span></span></tt></span><br class="calibre6"/>int a2[] = {0, 1, 2};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">an array of dimension 3</span></span></span><br class="calibre6"/>int a3[5] = {0, 1, 2};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a3[] = {0, 1, 2, 0, 0}</span></span></tt></span><br class="calibre6"/>string a4[3] = {"hi", "bye"}; // <span><span class="calibre45"><span class="calibre16">same as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">a4[] =&#160;&#160;{"hi", "bye", ""}</span></span></tt></span><br class="calibre6"/>int a5[2] = {0,1,2};&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: too many initializers</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Character Arrays Are Special</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Character arrays have an additional form of initialization: We can initialize such arrays from a string literal (&#167; <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>). When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char a1[] = {'C', '+', '+'};&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">list initialization, no null</span></span></span><br class="calibre6"/>char a2[] = {'C', '+', '+', '\0'}; // <span><span class="calibre45"><span class="calibre16">list initialization, explicit null</span></span></span><br class="calibre6"/>char a3[] = "C++";&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">null terminator added automatically</span></span></span><br class="calibre6"/>const char a4[6] = "Daniel";&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: no space for the null!</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The dimension of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a1</span></tt></code> is 3; the dimensions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a2</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">a3</span></tt></code> are both 4. The definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">a4</span></tt></code> is in error. Although the literal contains only six explicit characters, the array size must be at least seven&#8212;six to hold the literal and one for the null.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">No Copy or Assignment</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We cannot initialize an array as a copy of another array, nor is it legal to assign one array to another:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int a[] = {0, 1, 2}; // <span><span class="calibre45"><span class="calibre16">array of three</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int a2[] = a;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot initialize one array with another</span></span></span><br class="calibre6"/>a2 = a;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: cannot assign one array to another</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Some compilers allow array assignment as a <strong class="calibre5"><a id="filepos865318" href="037-defined_terms.html#filepos979689">compiler extension</a></strong>. It is usually a good idea to avoid using nonstandard features. Programs that use such features, will not work with a different compiler.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Understanding Complicated Array Declarations</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s, arrays can hold objects of most any type. For example, we can have an array of pointers. Because an array is an object, we can define both pointers and references to arrays. Defining arrays that hold pointers is fairly straightforward, defining a pointer or reference to an array is a bit more complicated:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos866213"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *ptrs[10];&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ptrs</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten pointers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int &amp;refs[10] = /* ? */;&#160;&#160;//&#160;&#160;<span><span class="calibre45"><span class="calibre16">error: no arrays of references</span></span></span><br class="calibre6"/>int (*Parray)[10] = &amp;arr; //&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Parray</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int (&amp;arrRef)[10] = arr;&#160;&#160;//&#160;&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arrRef</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">refers to an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">By default, type modifiers bind right to left. Reading the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptrs</span></tt></code> from right to left (&#167; <a href="023-2.3._compound_types.html#filepos445809">2.3.3</a>, p. <a href="023-2.3._compound_types.html#filepos445809">58</a>) is easy: We see that we&#8217;re defining an array of size 10, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptrs</span></tt></code>, that holds pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Reading the definition of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Parray</span></tt></code> from right to left isn&#8217;t as helpful. Because the array dimension follows the name being declared, it can be easier to read array declarations from the inside out rather than from right to left. Reading from the inside out makes it much easier to understand the type of <code class="calibre23"><tt class="calibre23"><span class="calibre24">Parray</span></tt></code>. We start by observing that the parentheses around <code class="calibre23"><tt class="calibre23"><span class="calibre24">*Parray</span></tt></code> mean that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Parray</span></tt></code> is a pointer. Looking right, we see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">Parray</span></tt></code> points to an array of size 10. Looking left, we see that the elements in that array are <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">Parray</span></tt></code> is a pointer to an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Similarly, <code class="calibre23"><tt class="calibre23"><span class="calibre24">(&amp;arrRef)</span></tt></code> says that <code class="calibre23"><tt class="calibre23"><span class="calibre24">arrRef</span></tt></code> is a reference. The type to which it refers is an array of size 10. That array holds elements of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Of course, there are no limits on how many type modifiers can be used:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *(&amp;arry)[10] = ptrs; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arry</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a reference to an array of ten pointers</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Reading this declaration from the inside out, we see that <code class="calibre23"><tt class="calibre23"><span class="calibre24">arry</span></tt></code> is a reference. Looking right, we see that the object to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">arry</span></tt></code> refers is an array of size 10. Looking left, we see that the element type is pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>. Thus, <code class="calibre23"><tt class="calibre23"><span class="calibre24">arry</span></tt></code> is a reference to an array of ten pointers.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">It can be easier to understand array declarations by starting with the array&#8217;s name and reading them from the inside out.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.5.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.27:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">txt_size</span></tt></code> is a function that takes no arguments and returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value, which of the following definitions are illegal? Explain why.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">unsigned buf_size = 1024;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(a)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int ia[buf_size];</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(b)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int ia[4 * 7 - 14];</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(c)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">int ia[txt_size()];</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre53"><strong class="calibre5">(d)</strong>
<code class="calibre23"><tt class="calibre23"><span class="calibre24">char st[11] = "fundamental";</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.28:</strong> What are the values in the following arrays?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string sa[10];<br class="calibre6"/>int ia[10];<br class="calibre6"/>int main() {<br class="calibre6"/>&#160;&#160;&#160;&#160;string sa2[10];<br class="calibre6"/>&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;ia2[10];<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.29:</strong> List some of the drawbacks of using an array instead of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos873638" class="calibre37"><span class="calibre5"><a id="filepos873671"/>3.5.2. Accessing the Elements of an Array</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As with the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> types, we can use a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> or the subscript operator to access elements of an array. As usual, the indices start at 0. For an array of ten elements, the indices are 0 through 9, not 1 through 10.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we use a variable to subscript an array, we normally should define that variable to have type <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos874465" href="037-defined_terms.html#filepos987232">size_t</a></span></span></tt></span></span></tt></code>. <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code> type is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstddef</span></tt></code> header, which is the C++ version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">stddef.h</span></tt></code> header from the C library.</p><div class="calibre22">&#160;</div>
<p class="calibre25">With the exception that arrays are fixed size, we use arrays in ways that are similar to how we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s. For example, we can reimplement our grading program from &#167; <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a> (p. <a href="032-3.3._library_vector_type.html#filepos778112">104</a>) to use an array to hold the cluster counters:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100</span></span></span><br class="calibre6"/>unsigned scores[11] = {}; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">11</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">buckets, all value initialized to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">0</span></span></tt></span><br class="calibre6"/>unsigned grade;<br class="calibre6"/>while (cin &gt;&gt; grade) {<br class="calibre6"/>&#160;&#160;&#160;&#160;if (grade &lt;= 100)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++scores[grade/10]; // <span><span class="calibre45"><span class="calibre16">increment the counter for the current cluster</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The only obvious difference between this program and the one on page <a href="032-3.3._library_vector_type.html#filepos789121">104</a> is the declaration of <code class="calibre23"><tt class="calibre23"><span class="calibre24">scores</span></tt></code>. In this program <code class="calibre23"><tt class="calibre23"><span class="calibre24">scores</span></tt></code> is an array of 11 <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> elements. The not so obvious difference is that the subscript operator in this program is the one that is defined as part of the language. This operator can be used on operands of array type. The subscript operator used in the program on page <a href="032-3.3._library_vector_type.html#filepos789121">104</a> was defined by the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> template and applies to operands of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As in the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, it is best to use a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> when we want to traverse the entire array. For example, we can print the resulting <code class="calibre23"><tt class="calibre23"><span class="calibre24">scores</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (auto i : scores)&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">for each counter in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">scores</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; i &lt;&lt; " ";&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the value of that counter</span></span></span><br class="calibre6"/>cout &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because the dimension is part of each array type, the system knows how many elements are in <code class="calibre23"><tt class="calibre23"><span class="calibre24">scores</span></tt></code>. Using a range <code class="calibre23"><tt class="calibre23"><span class="calibre24">for</span></tt></code> means that we don&#8217;t have to manage the traversal ourselves.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Checking Subscript Values</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As with <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, it is up to the programmer to ensure that the subscript value is in range&#8212;that is, that the index value is equal to or greater than zero and less than the size of the array. Nothing stops a program from stepping across an array boundary except careful attention to detail and thorough testing of the code. It is possible for programs to compile and execute yet still be fatally wrong.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The most common source of security problems are buffer overflow bugs. Such bugs occur when a program fails to check a subscript and mistakenly uses memory outside the range of an array or similar data structure.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos880253"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.5.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.30:</strong> Identify the indexing errors in the following code:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr size_t array_size = 10;<br class="calibre6"/>int ia[array_size];<br class="calibre6"/>for (size_t ix = 1; ix &lt;= array_size; ++ix)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;ia[ix] = ix;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.31:</strong> Write a program to define an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. Give each element the same value as its position in the array.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.32:</strong> Copy the array you defined in the previous exercise into another array. Rewrite your program to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.33:</strong> What would happen if we did not initialize the <code class="calibre23"><tt class="calibre23"><span class="calibre24">scores</span></tt></code> array in the program on page <a href="034-3.5._arrays.html#filepos873671">116</a>?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos881970" class="calibre37"><span class="calibre5">3.5.3. Pointers and Arrays</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In C++ pointers and arrays are closely intertwined. In particular, as we&#8217;ll see, when we use an array, the compiler ordinarily converts the array to a pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Normally, we obtain a pointer to an object by using the address-of operator (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>). Generally speaking, the address-of operator may be applied to any object. The elements in an array are objects. When we subscript an array, the result is the object at that location in the array. As with any other object, we can obtain a pointer to an array element by taking the address of that element:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string nums[] = {"one", "two", "three"};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>string *p = &amp;nums[0];&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">nums</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">However, arrays have a special property&#8212;in most places when we use an array, the compiler automatically substitutes a pointer to the first element:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string *p2 = nums;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2 = &amp;nums[0]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">There are various implications of the fact that operations on arrays are often really operations on pointers. One such implication is that when we use an array as an initializer for a variable defined using <code class="calibre23"><tt class="calibre23"><span class="calibre24">auto</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>), the deduced type is a pointer, not an array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,1,2,3,4,5,6,7,8,9}; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>auto ia2(ia); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that points to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span><br class="calibre6"/>ia2 = 42;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer, and we can't assign an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to a pointer</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Although <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> is an array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> as an initializer, the compiler treats that initialization as if we had written</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos887176"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto ia2(&amp;ia[0]);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">now it's clear that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">It is worth noting that this conversion does not happen when we use <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype</span></tt></code> (&#167; <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>). The type returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">decltype(ia)</span></tt></code> is array of ten <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia3</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>ia3 = p;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">error: can't assign an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to an array</span></span></span><br class="calibre6"/>ia3[4] = i; // <span><span class="calibre45"><span class="calibre16">ok: assigns the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to an element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia3</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointers Are Iterators</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Pointers that address elements in an array have additional operations beyond those we described in &#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a> (p. <a href="023-2.3._compound_types.html#filepos409391">52</a>). In particular, pointers to array elements support the same operations as iterators on <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s (&#167; <a href="033-3.4._introducing_iterators.html#filepos802543">3.4</a>, p. <a href="033-3.4._introducing_iterators.html#filepos802543">106</a>). For example, we can use the increment operator to move from one element in an array to the next:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int arr[] = {0,1,2,3,4,5,6,7,8,9};<br class="calibre6"/>int *p = arr; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span><br class="calibre6"/>++p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr[1]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Just as we can use iterators to traverse the elements in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, we can use pointers to traverse the elements in an array. Of course, to do so, we need to obtain pointers to the first and one past the last element. As we&#8217;ve just seen, we can obtain a pointer to the first element by using the array itself or by taking the address-of the first element. We can obtain an off-the-end pointer by using another special property of arrays. We can take the address of the nonexistent element one past the last element of an array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *e = &amp;arr[10]; // <span><span class="calibre45"><span class="calibre16">pointer just past the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we used the subscript operator to index a nonexisting element; <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> has ten elements, so the last element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> is at index position 9. The only thing we can do with this element is take its address, which we do to initialize <code class="calibre23"><tt class="calibre23"><span class="calibre24">e</span></tt></code>. Like an off-the-end iterator (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>), an off-the-end pointer does not point to an element. As a result, we may not dereference or increment an off-the-end pointer.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Using these pointers we can write a loop to print the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for (int *b = arr; b != e; ++b)<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; *b &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">print the elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">begin</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">end</span></span></tt></span></span></tt></code> Functions</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><a id="filepos894049"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre14">Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>. These functions act like the similarly named container members (&#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>). However, arrays are not class types, so these functions are not member functions. Instead, they take an argument that is an array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,1,2,3,4,5,6,7,8,9}; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is an array of ten</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>int *beg = begin(ia); // <span><span class="calibre45"><span class="calibre16">pointer to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span><br class="calibre6"/>int *last = end(ia);&#160;&#160;// <span><span class="calibre45"><span class="calibre16">pointer one past the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos895796"/><code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> returns a pointer to the first, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> returns a pointer one past the last element in the given array: These functions are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">iterator</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Using <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code>, it is easy to write a loop to process the elements in an array. For example, assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> is an array that holds <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> values, we might find the first negative value in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pbeg</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pend</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points just past the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span><br class="calibre6"/>int *pbeg = begin(arr),&#160;&#160;*pend = end(arr);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">find the first negative element, stopping if we've seen all the elements</span></span></span><br class="calibre6"/>while (pbeg != pend &amp;&amp; *pbeg &gt;= 0)<br class="calibre6"/>&#160;&#160;&#160;&#160;++pbeg;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We start by defining two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> pointers named <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pend</span></tt></code>. We position <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> to denote the first element and <code class="calibre23"><tt class="calibre23"><span class="calibre24">pend</span></tt></code> to point one past the last element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">while</span></tt></code> condition uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">pend</span></tt></code> to know whether it is safe to dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code>. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">pbeg</span></tt></code> does point at an element, we dereference and check whether the underlying element is negative. If so, the condition fails and we exit the loop. If not, we increment the pointer to look at the next element.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">A pointer &#8220;one past&#8221; the end of a built-in array behaves the same way as the iterator returned by the <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> operation of a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. In particular, we may not dereference or increment an off-the-end pointer.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Pointer Arithmetic</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Pointers that address array elements can use all the iterator operations listed in <a href="033-3.4._introducing_iterators.html#filepos810064">Table 3.6</a> (p. <a href="033-3.4._introducing_iterators.html#filepos810064">107</a>) and <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a> (p. <a href="033-3.4._introducing_iterators.html#filepos840512">111</a>). These operations&#8212;dereference, increment, comparisons, addition of an integral value, subtraction of two pointers&#8212;have the same meaning when applied to pointers that point at elements in a built-in array as they do when applied to iterators.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we add (or subtract) an integral value to (or from) a pointer, the result is a new pointer. That new pointer points to the element the given number ahead of (or behind) the original pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">constexpr size_t sz = 5;<br class="calibre6"/>int arr[sz] = {1,2,3,4,5};<br class="calibre6"/>int *ip = arr;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int *ip = &amp;arr[0]</span></span></tt></span><br class="calibre6"/>int *ip2 = ip + 4; // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ip2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr[4]</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, the last element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The result of adding <code class="calibre23"><tt class="calibre23"><span class="calibre24">4</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">ip</span></tt></code> is a pointer that points to the element four elements further on in the array from the one to which <code class="calibre23"><tt class="calibre23"><span class="calibre24">ip</span></tt></code> currently points.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The result of adding an integral value to a pointer must be a pointer to an element in the same array, or a pointer just past the end of the array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is converted to a pointer to its first element;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points one past the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span><br class="calibre6"/>int *p = arr + sz; // <span><span class="calibre45"><span class="calibre16">use caution -- do not dereference!</span></span></span><br class="calibre6"/>int *p2 = arr + 10; // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has only 5 elements;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has undefined value</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When we add <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code>, the compiler converts <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> to a pointer to the first element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code>. When we add <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> to that pointer, we get a pointer that points <code class="calibre23"><tt class="calibre23"><span class="calibre24">sz</span></tt></code> positions <a id="filepos903915"/>(i.e., <code class="calibre23"><tt class="calibre23"><span class="calibre24">5</span></tt></code> positions) past the first one. That is, it points one past the last element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code>. Computing a pointer more than one past the last element is an error, although the compiler is unlikely to detect such errors.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As with iterators, subtracting two pointers gives us the distance between those pointers. The pointers must point to elements in the same array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">auto n = end(arr) - begin(arr); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">n</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is 5, the number of elements in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">arr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The result of subtracting two pointers is a library type named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5"><a id="filepos905249" href="037-defined_terms.html#filepos985738">ptrdiff_t</a></span></span></tt></span></span></tt></code>. Like <code class="calibre23"><tt class="calibre23"><span class="calibre24">size_t</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptrdiff_t</span></tt></code> type is a machine-specific type and is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstddef</span></tt></code> header. Because subtraction might yield a negative distance, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ptrdiff_t</span></tt></code> is a signed integral type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can use the relational operators to compare pointers that point to elements of an array, or one past the last element in that array. For example, we can traverse the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">arr</span></tt></code> as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *b = arr, *e = arr + sz;<br class="calibre6"/>while (b &lt; e) {<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">use</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*b</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;++b;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We cannot use the relational operators on pointers to two unrelated objects:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = 0, sz = 42;<br class="calibre6"/>int *p = &amp;i, *e = &amp;sz;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">undefined:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">e</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are unrelated; comparison is meaningless!</span></span></span><br class="calibre6"/>while (p &lt; e)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Although the utility may be obscure at this point, it is worth noting that pointer arithmetic is also valid for null pointers (&#167; <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>) and for pointers that point to an object that is not an array. In the latter case, the pointers must point to the same object, or one past that object. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code> is a null pointer, we can add or subtract an integral constant expression (&#167; <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>) whose value is 0 to <code class="calibre23"><tt class="calibre23"><span class="calibre24">p</span></tt></code>. We can also subtract two null pointers from one another, in which case the result is 0.</p><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Interaction between Dereference and Pointer Arithmetic</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The result of adding an integral value to a pointer is itself a pointer. Assuming the resulting pointer points to an element, we can dereference the resulting pointer:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,2,4,6,8}; // <span><span class="calibre45"><span class="calibre16">array with 5 elements of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>int last = *(ia + 4); // <span><span class="calibre45"><span class="calibre16">ok: initializes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">last</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to 8, the value of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[4]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">*(ia + 4)</span></tt></code> calculates the address four elements past <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> and dereferences the resulting pointer. This expression is equivalent to writing <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia[4]</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Recall that in &#167; <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a> (p. <a href="033-3.4._introducing_iterators.html#filepos804727">109</a>) we noted that parentheses are required in expressions that contain dereference and dot operators. Similarly, the parentheses around this pointer addition are essential. Writing</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">last = *ia + 4;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">last</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">= 4, equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[0]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">+ 4</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">means dereference <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia</span></tt></code> and add <code class="calibre23"><tt class="calibre23"><span class="calibre24">4</span></tt></code> to the dereferenced value. We&#8217;ll cover the reasons for this behavior in &#167; <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a> (p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>).</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5"><a id="filepos911392"/>Subscripts and Pointers</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00011.jpg" class="calibre9"/></div>
<p class="calibre14">As we&#8217;ve seen, in most places when we use the name of an array, we are really using a pointer to the first element in that array. One place where the compiler does this transformation is when we subscript an array. Given</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int ia[] = {0,2,4,6,8};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">array with 5 elements of type</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">if we write <code class="calibre23"><tt class="calibre23"><span class="calibre24">ia[0]</span></tt></code>, that is an expression that uses the name of an array. When we subscript an array, we are really subscripting a pointer to an element in that array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = ia[2];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is converted to a pointer to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[2]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">fetches the element to which</span></span></span>&#160;<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">(ia + 2)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>int *p = ia;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the first element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia</span></span></tt></span><br class="calibre6"/>i = *(p + 2);&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i = ia[2]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int *p = &amp;ia[2];&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the element indexed by</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span><br class="calibre6"/>int j = p[1];&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p[1]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">*(p + 1),</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p[1]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the same element as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[3]</span></span></tt></span><br class="calibre6"/>int k = p[-2];&#160;&#160;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p[-2]</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is the same element as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ia[0]</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">This last example points out an important difference between arrays and library types such as <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that have subscript operators. The library types force the index used with a subscript to be an unsigned value. The built-in subscript operator does not. The index used with the built-in subscript operator can be a negative value. Of course, the resulting address must point to an element in (or one past the end of) the array to which the original pointer points.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Unlike subscripts for <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, the index of the built-in subscript operator is not an <code class="calibre23"><tt class="calibre23"><span class="calibre24">unsigned</span></tt></code> type.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.5.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.34:</strong> Given that <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> point to elements in the same array, what does the following code do? Are there values of <code class="calibre23"><tt class="calibre23"><span class="calibre24">p1</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">p2</span></tt></code> that make this code illegal?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">p1 += p2 - p1;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.35:</strong> Using pointers, write a program to set the elements in an array to zero.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.36:</strong> Write a program to compare two arrays for equality. Write a similar program to compare two <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos918393" class="calibre37"><span class="calibre5"><a id="filepos918426"/>3.5.4. C-Style Character Strings</span></h4><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Although C++ supports C-style strings, they should not be used by C++ programs. C-style strings are a surprisingly rich source of bugs and are the root cause of many security problems. They&#8217;re also harder to use!</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Character string literals are an instance of a more general construct that C++ inherits from C: <strong class="calibre5"><a id="filepos919251" href="037-defined_terms.html#filepos978817">C-style character strings</a></strong>. C-style strings are not a type. Instead, they are a convention for how to represent and use character strings. Strings that follow this convention are stored in character arrays and are <strong class="calibre5"><a id="filepos919525" href="037-defined_terms.html#filepos984804">null terminated</a></strong>. By null-terminated we mean that the last character in the string is followed by a null character (<code class="calibre23"><tt class="calibre23"><span class="calibre24">'\0'</span></tt></code>). Ordinarily we use pointers to manipulate these strings.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">C Library String Functions</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The Standard C library provides a set of functions, listed in <a href="034-3.5._arrays.html#filepos920404">Table 3.8</a>, that operate on C-style strings. These functions are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">cstring</span></tt></code> header, which is the C++ version of the C header <code class="calibre23"><tt class="calibre23"><span class="calibre24">string.h</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos920404"/>Table 3.8. C-Style Character String Functions</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00029.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The functions in <a href="034-3.5._arrays.html#filepos920404">Table 3.8</a> do not verify their string parameters.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">The pointer(s) passed to these routines must point to null-terminated array(s):</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char ca[] = {'C', '+', '+'};&#160;&#160;// <span><span class="calibre45"><span class="calibre16">not null terminated</span></span></span><br class="calibre6"/>cout &lt;&lt; strlen(ca) &lt;&lt; endl;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">disaster:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ca</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">isn't null terminated</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">In this case, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca</span></tt></code> is an array of <code class="calibre23"><tt class="calibre23"><span class="calibre24">char</span></tt></code> but is not null terminated. The result is undefined. The most likely effect of this call is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">strlen</span></tt></code> will keep looking through the memory that follows <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca</span></tt></code> until it encounters a null character.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Comparing Strings</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Comparing two C-style strings is done quite differently from how we compare library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. When we compare two library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, we use the normal relational or equality operators:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s1 = "A string example";<br class="calibre6"/>string s2 = "A different string";<br class="calibre6"/>if (s1 &lt; s2)&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">false</span></span></tt></span><span><span class="calibre45"><span class="calibre16">:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is less than</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s1</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos923633"/>Using these operators on similarly defined C-style strings compares the pointer values, not the strings themselves:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char ca1[] = "A string example";<br class="calibre6"/>const char ca2[] = "A different string";<br class="calibre6"/>if (ca1 &lt; ca2)&#160;&#160;// <span><span class="calibre45"><span class="calibre16">undefined: compares two unrelated addresses</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Remember that when we use an array, we are really using a pointer to the first element in the array (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">117</a>). Hence, this condition actually compares two <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code> values. Those pointers do not address the same object, so the comparison is undefined.</p><div class="calibre15">&#160;</div>
<p class="calibre25">To compare the strings, rather than the pointer values, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcmp</span></tt></code>. That function returns 0 if the strings are equal, or a positive or negative value, depending on whether the first string is larger or smaller than the second:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">if (strcmp(ca1, ca2) &lt; 0) // <span><span class="calibre45"><span class="calibre16">same effect as</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">comparison</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s1 &lt; s2</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Caller Is Responsible for Size of a Destination String</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Concatenating or copying C-style strings is also very different from the same operations on library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. For example, if we wanted to concatenate the two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s <code class="calibre23"><tt class="calibre23"><span class="calibre24">s1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">s2</span></tt></code> defined above, we can do so directly:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">initialize</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largeStr</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as a concatenation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s1</span></span></tt></span><span><span class="calibre45"><span class="calibre16">, a space, and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s2</span></span></tt></span><br class="calibre6"/>string largeStr = s1 + " " + s2;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Doing the same with our two arrays, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca1</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca2</span></tt></code>, would be an error. The expression <code class="calibre23"><tt class="calibre23"><span class="calibre24">ca1 + ca2</span></tt></code> tries to add two pointers, which is illegal and meaningless.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Instead we can use <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcat</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcpy</span></tt></code>. However, to use these functions, we must pass an array to hold the resulting string. The array we pass <em class="calibre16">must</em> be large enough to hold the generated string, including the null character at the end. The code we show here, although a common usage pattern, is fraught with potential for serious error:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">disastrous if we miscalculated the size of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largeStr</span></span></tt></span><br class="calibre6"/>strcpy(largeStr, ca1);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">copies</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ca1</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">into</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largeStr</span></span></tt></span><br class="calibre6"/>strcat(largeStr, " ");&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">adds a space at the end of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largeStr</span></span></tt></span><br class="calibre6"/>strcat(largeStr, ca2);&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">concatenates</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ca2</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">onto</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">largeStr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem is that we can easily miscalculate the size needed for <code class="calibre23"><tt class="calibre23"><span class="calibre24">largeStr</span></tt></code>. Moreover, any time we change the values we want to store in <code class="calibre23"><tt class="calibre23"><span class="calibre24">largeStr</span></tt></code>, we have to remember to double-check that we calculated its size correctly. Unfortunately, programs similar to this code are widely distributed. Programs with such code are error-prone and often lead to serious security leaks.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">For most applications, in addition to being safer, it is also more efficient to use library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s rather than C-style strings.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos930611"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 3.5.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.37:</strong> What does the following program do?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const char ca[] = {'h', 'e', 'l', 'l', 'o'};<br class="calibre6"/>const char *cp = ca;<br class="calibre6"/>while (*cp) {<br class="calibre6"/>&#160;&#160;&#160;&#160;cout &lt;&lt; *cp &lt;&lt; endl;<br class="calibre6"/>&#160;&#160;&#160;&#160;++cp;<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.38:</strong> In this section, we noted that it was not only illegal but meaningless to try to add two pointers. Why would adding two pointers be meaningless?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.39:</strong> Write a program to compare two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. Now write a program to compare the values of two C-style character strings.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 3.40:</strong> Write a program to define two character arrays initialized from string literals. Now define a third character array to hold the concatenation of the two arrays. Use <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcpy</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">strcat</span></tt></code> to copy the two arrays into the third.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos932486" class="calibre37"><span class="calibre5">3.5.5. Interfacing to Older Code</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Many C++ programs predate the standard library and do not use the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style character strings. The C++ library offers facilities to make the interface easier to manage.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Mixing Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">string</span></span></tt></span></span></tt></code>s and C-Style Strings</span></h5><div class="calibre38">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">In &#167; <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a> (p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) we saw that we can initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> from a string literal:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s("Hello World");&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">holds</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">Hello World</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">More generally, we can use a null-terminated character array anywhere that we can use a string literal:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We can use a null-terminated character array to initialize or assign a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; We can use a null-terminated character array as one operand (but not both operands) to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> addition operator or as the right-hand operand in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> compound assignment (<code class="calibre23"><tt class="calibre23"><span class="calibre24">+=</span></tt></code>) operator.</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre25">The reverse functionality is not provided: There is no direct way to use a library <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> when a C-style string is required. For example, there is no way to initialize a character pointer from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. There is, however, a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> member function named <code class="calibre23"><tt class="calibre23"><span class="calibre24">c_str</span></tt></code> that we can often use to accomplish what we want:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">char *str = s; // <span><span class="calibre45"><span class="calibre16">error: can't initialize a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char*</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">from a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>const char *str = s.c_str(); // <span><span class="calibre45"><span class="calibre16">ok</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos936545"/>The name <code class="calibre23"><tt class="calibre23"><span class="calibre24">c_str</span></tt></code> indicates that the function returns a C-style character string. That is, it returns a pointer to the beginning of a null-terminated character array that holds the same data as the characters in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. The type of the pointer is <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code>, which prevents us from changing the contents of the array.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The array returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">c_str</span></tt></code> is not guaranteed to be valid indefinitely. Any subsequent use of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> that might change the value of <code class="calibre23"><tt class="calibre23"><span class="calibre24">s</span></tt></code> can invalidate this array.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">If a program needs continuing access to the contents of the array returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">str()</span></tt></code>, the program must copy the array returned by <code class="calibre23"><tt class="calibre23"><span class="calibre24">c_str</span></tt></code>.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using an Array to Initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">vector</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">In &#167; <a href="034-3.5._arrays.html#filepos855259">3.5.1</a> (p. <a href="034-3.5._arrays.html#filepos855259">114</a>) we noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. However, we can use an array to initialize a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. To do so, we specify the address of the first element and one past the last element that we wish to copy:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int int_arr[] = {0, 1, 2, 3, 4, 5};<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ivec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">has six elements; each is a copy of the corresponding element in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int_arr</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt; ivec(begin(int_arr), end(int_arr));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The two pointers used to construct <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code> mark the range of values to use to initialize the elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code>. The second pointer points one past the last element to be copied. In this case, we used the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">end</span></tt></code> functions (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) to pass pointers to the first and one past the last elements in <code class="calibre23"><tt class="calibre23"><span class="calibre24">int_arr</span></tt></code>. As a result, <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code> will have six elements each of which will have the same value as the corresponding element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">int_arr</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The specified range can be a subset of the array:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">copies three elements:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int_arr[1]</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int_arr[2]</span></span></tt></span><span><span class="calibre45"><span class="calibre16">,</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int_arr[3]</span></span></tt></span><br class="calibre6"/>vector&lt;int&gt; subVec(int_arr + 1, int_arr + 4);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This initialization creates <code class="calibre23"><tt class="calibre23"><span class="calibre24">subVec</span></tt></code> with three elements. The values of these elements are copies of the values in <code class="calibre23"><tt class="calibre23"><span class="calibre24">int_arr[1]</span></tt></code> through <code class="calibre23"><tt class="calibre23"><span class="calibre24">int_arr[3]</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre35"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre14"><span class="calibre5"><a/>Advice: Use Library Types Instead of Arrays</span></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Pointers and arrays are surprisingly error-prone. Part of the problem is conceptual: Pointers are used for low-level manipulations and it is easy to make bookkeeping mistakes. Other problems arise because of the syntax, particularly the declaration syntax used with pointers.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre36"><p class="calibre25">Modern C++ programs should use <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s and iterators instead of built-in arrays and pointers, and use <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s rather than C-style array-based character strings.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="033-3.4._introducing_iterators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="035-3.6._multidimensional_arrays.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
