<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>9.4. How a vector Grows</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="091-9.3._sequential_container_operations.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="093-9.5._additional_string_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos2347166" class="calibre29"><span class="bold">9.4. How a <code class="calibre54"><tt class="calibre54"><span class="calibre55"><span class="calibre2"><tt class="calibre54"><span class="calibre56"><span class="bold">vector</span></span></tt></span></span></tt></code> Grows</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">To support fast random access, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> elements are stored contiguously&#8212;each element is adjacent to the previous element. Ordinarily, we should not care about how a library type is implemented; all we should care about is how to use it. However, in the case of <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, part of the implementation leaks into its interface.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Given that elements are contiguous, and that the size of the container is flexible, consider what must happen when we add an element to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>: If there is no room for the new element, the container can&#8217;t just add an element somewhere else in memory&#8212;the elements must be contiguous. Instead, the container must allocate new memory to hold the existing elements plus the new one, move the elements from the old location into the new space, add the new element, and deallocate the old memory. If <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> did this memory allocation and deallocation each time we added an element, performance would be unacceptably slow.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos2348960"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.3.6</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.31:</strong> The program on page <a href="091-9.3._sequential_container_operations.html#filepos2335296">354</a> to remove even-valued elements and duplicate odd ones will not work on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">forward_list</span></tt></code>. Why? Revise the program so that it works on these types as well.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.32:</strong> In the program onpage <a href="091-9.3._sequential_container_operations.html#filepos2335296">354</a> would it be legal to write the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> as follows? If not, why not?</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">iter = vi.insert(iter, *iter++);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.33:</strong> In the final example in this section what would happen if we did not assign the result of <code class="calibre23"><tt class="calibre23"><span class="calibre24">insert</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">begin</span></tt></code>? Write a program that omits this assignment to see if your expectation was correct.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.34:</strong> Assuming <code class="calibre23"><tt class="calibre23"><span class="calibre24">vi</span></tt></code> is a container of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s that includes even and odd values, predict the behavior of the following loop. After you&#8217;ve analyzed this loop, write a program to test whether your expectations were correct.</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">iter = vi.begin();<br class="calibre6"/>while (iter != vi.end())<br class="calibre6"/>&#160;&#160;&#160;&#160;if (*iter % 2)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;iter = vi.insert(iter, *iter);<br class="calibre6"/>&#160;&#160;&#160;&#160;++iter;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">To avoid these costs, library implementors use allocation strategies that reduce the number of times the container is reallocated. When they have to get new memory, <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> implementations typically allocate capacity beyond what is immediately needed. The container holds this storage in reserve and uses it to allocate new elements as they are added. Thus, there is no need to reallocate the container for each new element.</p><div class="calibre22">&#160;</div>
<p class="calibre25">This allocation strategy is dramatically more efficient than reallocating the container each time an element is added. In fact, its performance is good enough that in practice a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> usually grows more efficiently than a <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> or a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque</span></tt></code>, even though the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> has to move all of its elements each time it reallocates memory.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Members to Manage Capacity</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> types provide members, described in <a href="092-9.4._how_a_vector_grows.html#filepos2353756">Table 9.10</a>, that let us interact with the memory-allocation part of the implementation. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> operation tells us how many elements the container can hold before it must allocate more space. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> operation lets us tell the container how many elements it should be prepared to hold.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos2353756"/>Table 9.10. Container Size Management</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00057.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14"><code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> does not change the number of elements in the container; it affects only how much memory the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> preallocates.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> changes the capacity of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> only if the requested space exceeds the current capacity. If the requested size is greater than the current <a id="filepos2354820"/>capacity, <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> allocates at least as much as (and may allocate more than) the requested amount.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If the requested size is less than or equal to the existing capacity, <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> does nothing. In particular, calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> with a size smaller than <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> does not cause the container to give back memory. Thus, after calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code>, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> will be greater than or equal to the argument passed to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code>.</p><div class="calibre22">&#160;</div>
<p class="calibre25">As a result, a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> will never reduce the amount of space that the container uses. Similarly, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> members (&#167; <a href="091-9.3._sequential_container_operations.html#filepos2327136">9.3.5</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2327136">352</a>) change only the number of elements in the container, not its capacity. We cannot use <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> to reduce the memory a container holds in reserve.</p><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos2356389"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25">Under the new library, we can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">shrink_to_fit</span></tt></code> to ask a <code class="calibre23"><tt class="calibre23"><span class="calibre24">deque, vector</span></tt></code>, or <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> to return unneeded memory. This function indicates that we no longer need any excess capacity. However, the implementation is free to ignore this request. There is no guarantee that a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">shrink_to_fit</span></tt></code> will return memory.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">capacity</span></span></tt></span></span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">size</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">It is important to understand the difference between <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> of a container is the number of elements it already holds; its <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> is how many elements it can hold before more space must be allocated.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The following code illustrates the interaction between <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code>:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;int&gt; ivec;<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be zero;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is implementation defined</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">give</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ivec</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">24 elements</span></span></span><br class="calibre6"/>for (vector&lt;int&gt;::size_type ix = 0; ix != 24; ++ix)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;ivec.push_back(ix);<br class="calibre6"/><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be 24;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be &gt;= 24 and is implementation defined</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">When run on our system, this code produces the following output:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ivec: size: 0 capacity: 0</span></span></tt></span><br class="calibre6"/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ivec: size: 24 capacity: 32</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a/>We know that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> of an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> is zero, and evidently our library also sets the <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> of an empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to zero. When we add elements to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>, we know that the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> is the same as the number of elements we&#8217;ve added. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> must be at least as large as <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> but can be larger. The details of how much excess capacity is allocated vary by implementations of the library. Under this implementation, adding 24 elements one at a time results in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> of 32.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Visually we can think of the current state of <code class="calibre23"><tt class="calibre23"><span class="calibre24">ivec</span></tt></code> as</p><div class="calibre22">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00058.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<p class="calibre25">We can now <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> some additional space:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ivec.reserve(50); // <span><span class="calibre45"><span class="calibre16">sets</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to at least 50; might be more</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be 24;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be &gt;= 50 and is implementation defined</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here, the output indicates that the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> allocated exactly as much space as we requested:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ivec: size: 24 capacity: 50</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We might next use up that reserved capacity as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">add elements to use up the excess capacity</span></span></span><br class="calibre6"/>while (ivec.size() != ivec.capacity())<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;ivec.push_back(0);<br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be unchanged and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are now equal</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The output indicates that at this point we&#8217;ve used up the reserved capacity, and <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> are equal:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ivec: size: 50 capacity: 50</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Because we used only reserved capacity, there is no need for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> to do any allocation. In fact, as long as no operation exceeds the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s capacity, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> must not reallocate its elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we now add another element, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> will have to reallocate itself:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ivec.push_back(42); // <span><span class="calibre45"><span class="calibre16">add one more element</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be 51;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">will be &gt;= 51 and is implementation defined</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The output from this portion of the program</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24"><a/><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">ivec: size: 51 capacity: 100</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">indicates that this <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> implementation appears to follow a strategy of doubling the current capacity each time it has to allocate new storage.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can call <code class="calibre23"><tt class="calibre23"><span class="calibre24">shrink_to_fit</span></tt></code> to ask that memory beyond what is needed for the current size be returned to the system:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">ivec.shrink_to_fit(); // <span><span class="calibre45"><span class="calibre16">ask for the memory to be returned</span></span></span><br class="calibre6"/>// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">should be unchanged;</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">capacity</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is implementation defined</span></span></span><br class="calibre6"/>cout &lt;&lt; "ivec: size: " &lt;&lt; ivec.size()<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&lt;&lt; " capacity: "&#160;&#160;&lt;&lt; ivec.capacity() &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">shrink_to_fit</span></tt></code> is only a request; there is no guarantee that the library will return the memory.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Each <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> implementation can choose its own allocation strategy. However, it must not allocate new memory until it is forced to do so.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">A <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> may be reallocated only when the user performs an insert operation when the <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code> equals <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> or by a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">reserve</span></tt></code> with a value that exceeds the current <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code>. How much memory is allocated beyond the specified amount is up to the implementation.</p><div class="calibre22">&#160;</div>
<p class="calibre25">Every implementation is required to follow a strategy that ensures that it is efficient to use <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code> to add elements to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>. Technically speaking, the execution time of creating an <em class="calibre16">n</em>-element <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> by calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">push_back</span></tt></code>
<em class="calibre16">n</em> times on an initially empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> must never be more than a constant multiple of <em class="calibre16">n</em>.</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 9.4</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.35:</strong> Explain the difference between a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>&#8217;s <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> and its <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.36:</strong> Can a container have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> less than its <code class="calibre23"><tt class="calibre23"><span class="calibre24">size</span></tt></code>?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.37:</strong> Why don&#8217;t <code class="calibre23"><tt class="calibre23"><span class="calibre24">list</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">array</span></tt></code> have a <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> member?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.38:</strong> Write a program to explore how <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>s grow in the library you use.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.39:</strong> Explain what the following program fragment does:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt; svec;<br class="calibre6"/>svec.reserve(1024);<br class="calibre6"/>string word;<br class="calibre6"/>while (cin &gt;&gt; word)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;svec.push_back(word);<br class="calibre6"/>svec.resize(svec.size()+svec.size()/2);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 9.40:</strong> If the program in the previous exercise reads 256 words, what is its likely <code class="calibre23"><tt class="calibre23"><span class="calibre24">capacity</span></tt></code> after it is <code class="calibre23"><tt class="calibre23"><span class="calibre24">resize</span></tt></code>d? What if it reads 512? 1,000? 1,048?</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="091-9.3._sequential_container_operations.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="093-9.5._additional_string_operations.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
