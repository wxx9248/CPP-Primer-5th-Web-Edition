<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>14.8. Function-Call Operator</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="136-14.7._member_access_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="138-14.9._overloading_conversions_and_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos3657799" class="calibre29"><span class="bold"><a id="filepos3657832" class="calibre2"/>14.8. Function-Call Operator</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00009.jpg" class="calibre9"/></div>
<p class="calibre14">Classes that overload the call operator allow objects of its type to be used as if they were a function. Because such classes can also store state, they can be more flexible than ordinary functions.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As a simple example, the following <code class="calibre23"><tt class="calibre23"><span class="calibre24">struct</span></tt></code>, named <code class="calibre23"><tt class="calibre23"><span class="calibre24">absInt</span></tt></code>, has a call operator that returns the absolute value of its argument:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">struct absInt {<br class="calibre6"/>&#160;&#160;&#160;&#160;int operator()(int val) const {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return val &lt; 0 ? -val : val;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This class defines a single operation: the function-call operator. That operator takes an argument of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> and returns the argument&#8217;s absolute value.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We use the call operator by applying an argument list to an <code class="calibre23"><tt class="calibre23"><span class="calibre24">absInt</span></tt></code> object in a way that looks like a function call:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int i = -42;<br class="calibre6"/>absInt absObj;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">object that has a function-call operator</span></span></span><br class="calibre6"/>int ui = absObj(i); // <span><span class="calibre45"><span class="calibre16">passes</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">i</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">absObj.operator(</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Even though <code class="calibre23"><tt class="calibre23"><span class="calibre24">absObj</span></tt></code> is an object, not a function, we can &#8220;call&#8221; this object. Calling an object runs its overloaded call operator. In this case, that operator takes an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value and returns its absolute value.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The function-call operator must be a member function. A class may define multiple versions of the call operator, each of which must differ as to the number or types of their parameters.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre25">Objects of classes that define the call operator are referred to as <strong class="calibre5"><a id="filepos3661371" href="140-defined_terms.html#filepos3777376">function objects</a></strong>. Such objects &#8220;act like functions&#8221; because we can call them.</p><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Function-Object Classes with State</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">Like any other class, a function-object class can have additional members aside from <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator()</span></tt></code>. Function-object classes often contain data members that are used to customize the operations in the call operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As an example, we&#8217;ll define a class that prints a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> argument. By default, our class will write to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> and will print a space following each <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>. We&#8217;ll also let users of our class provide a different stream on which to write and provide a different separator. We can define this class as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class PrintString {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;PrintString(ostream &amp;o = cout, char c = ' '):<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os(o), sep(c) { }<br class="calibre6"/>&#160;&#160;&#160;&#160;void operator()(const string &amp;s) const { os &lt;&lt; s &lt;&lt; sep; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;ostream &amp;os;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">stream on which to write</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;char sep;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">character to print after each output</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3663503"/>Our class has a constructor that takes a reference to an output stream and a character to use as the separator. It uses <code class="calibre23"><tt class="calibre23"><span class="calibre24">cout</span></tt></code> and a space as default arguments (&#167; <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>) for these parameters. The body of the function-call operator uses these members when it prints the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">When we define <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrintString</span></tt></code> objects, we can use the defaults or supply our own values for the separator or output stream:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">PrintString printer;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">uses the defaults; prints to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span><br class="calibre6"/>printer(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">followed by a space on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cout</span></span></tt></span><br class="calibre6"/>PrintString errors(cerr, '\n');<br class="calibre6"/>errors(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">s</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">followed by a newline on</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">cerr</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Function objects are most often used as arguments to the generic algorithms. For example, we can use the library <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> algorithm (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">391</a>) and our <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrintString</span></tt></code> class to print the contents of a container:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The third argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> is a temporary object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrintString</span></tt></code> that we initialize from <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code> and a newline character. The call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code> will print each element in <code class="calibre23"><tt class="calibre23"><span class="calibre24">vs</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">cerr</span></tt></code> followed by a newline.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.8</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.33:</strong> How many operands may an overloaded function-call operator take?</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.34:</strong> Define a function-object class to perform an if-then-else operation: The call operator for this class should take three parameters. It should test its first parameter and if that test succeeds, it should return its second parameter; otherwise, it should return its third parameter.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.35:</strong> Write a class like <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrintString</span></tt></code> that reads a line of input from an <code class="calibre23"><tt class="calibre23"><span class="calibre24">istream</span></tt></code> and returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representing what was read. If the read fails, return the empty <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.36:</strong> Use the class from the previous exercise to read the standard input, storing each line as an element in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code>.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.37:</strong> Write a class that tests whether two values are equal. Use that object and the library algorithms to write a program to replace all instances of a given value in a sequence.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3668993" class="calibre37"><span class="calibre5">14.8.1. Lambdas Are Function Objects</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">In the previous section, we used a <code class="calibre23"><tt class="calibre23"><span class="calibre24">PrintString</span></tt></code> object as an argument in a call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">for_each</span></tt></code>. This usage is similar to the programs we wrote in &#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a> (p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) that used lambda expressions. When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class (&#167; <a href="100-10.3._customizing_operations.html#filepos2560162">10.3.3</a>, p. <a href="100-10.3._customizing_operations.html#filepos2560162">392</a>). The <a id="filepos3669700"/>classes generated from a lambda contain an overloaded function-call operator. For example, the lambda that we passed as the last argument to <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">sort</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">words</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">by size, but maintain alphabetical order for words of the same size</span></span></span><br class="calibre6"/>stable_sort(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[](const string &amp;a, const string &amp;b)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return a.size() &lt; b.size();});</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">acts like an unnamed object of a class that would look something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class ShorterString {<br class="calibre6"/>public:<br class="calibre6"/>&#160;&#160;&#160;&#160;bool operator()(const string &amp;s1, const string &amp;s2) const<br class="calibre6"/>&#160;&#160;&#160;&#160;{ return s1.size() &lt; s2.size(); }<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The generated class has a single member, which is a function-call operator that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s and compares their lengths. The parameter list and function body are the same as the lambda. As we saw in &#167; <a href="100-10.3._customizing_operations.html#filepos2560162">10.3.3</a> (p. <a href="100-10.3._customizing_operations.html#filepos2560162">395</a>), by default, lambdas may not change their captured variables. As a result, by default, the function-call operator in a class generated from a lambda is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> member function. If the lambda is declared as <code class="calibre23"><tt class="calibre23"><span class="calibre24">mutable</span></tt></code>, then the call operator is not <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We can rewrite the call to <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> to use this class instead of the lambda expression:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">stable_sort(words.begin(), words.end(), ShorterString());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The third argument is a newly constructed <code class="calibre23"><tt class="calibre23"><span class="calibre24">ShorterString</span></tt></code> object. The code in <code class="calibre23"><tt class="calibre23"><span class="calibre24">stable_sort</span></tt></code> will &#8220;call&#8221; this object each time it compares two <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s. When the object is called, it will execute the body of its call operator, returning <code class="calibre23"><tt class="calibre23"><span class="calibre24">true</span></tt></code> if the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>&#8217;s size is less than the second&#8217;s.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Classes Representing Lambdas with Captures</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">As we&#8217;ve seen, when a lambda captures a variable by reference, it is up to the program to ensure that the variable to which the reference refers exists when the lambda is executed (&#167; <a href="100-10.3._customizing_operations.html#filepos2560162">10.3.3</a>, p. <a href="100-10.3._customizing_operations.html#filepos2560162">393</a>). Therefore, the compiler is permitted to use the reference directly without storing that reference as a data member in the generated class.</p><div class="calibre15">&#160;</div>
<p class="calibre25">In contrast, variables that are captured by value are copied into the lambda (&#167; <a href="100-10.3._customizing_operations.html#filepos2560162">10.3.3</a>, p. <a href="100-10.3._customizing_operations.html#filepos2560162">392</a>). As a result, classes generated from lambdas that capture variables by value have data members corresponding to each such variable. These classes also have a constructor to initialize these data members from the value of the captured variables. As an example, in &#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a> (p. <a href="100-10.3._customizing_operations.html#filepos2530282">390</a>), the lambda that we used to find the first <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> whose length was greater than or equal to a given bound:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">get an iterator to the first element whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>auto wc = find_if(words.begin(), words.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[sz](const string &amp;a)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">would generate a class that looks something like</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3675757"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">class SizeComp {<br class="calibre6"/>&#160;&#160;&#160;&#160;SizeComp(size_t n): sz(n) { } // <span><span class="calibre45"><span class="calibre16">parameter for each captured variable</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">call operator with the same return type, parameters, and body as the lambda</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;bool operator()(const string &amp;s) const<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return s.size() &gt;= sz; }<br class="calibre6"/>private:<br class="calibre6"/>&#160;&#160;&#160;&#160;size_t sz; // <span><span class="calibre45"><span class="calibre16">a data member for each variable captured by value</span></span></span><br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Unlike our <code class="calibre23"><tt class="calibre23"><span class="calibre24">ShorterString</span></tt></code> class, this class has a data member and a constructor to initialize that member. This synthesized class does not have a default constructor; to use this class, we must pass an argument:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">get an iterator to the first element whose</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">size(</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">is</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&gt;= sz</span></span></tt></span><br class="calibre6"/>auto wc = find_if(words.begin(), words.end(), SizeComp(sz));</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">Classes generated from a lambda expression have a deleted default constructor, deleted assignment operators, and a default destructor. Whether the class has a defaulted or deleted copy/move constructor depends in the usual ways on the types of the captured data members (&#167; <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>, and &#167; <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">537</a>).</p><div class="calibre22">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.8.1</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.38:</strong> Write a class that tests whether the length of a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> matches a given bound. Use that object to write a program to report how many words in an input file are of sizes 1 through 10 inclusive.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.39:</strong> Revise the previous program to report the count of words that are sizes 1 through 9 and 10 or more.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.40:</strong> Rewrite the <code class="calibre23"><tt class="calibre23"><span class="calibre24">biggies</span></tt></code> function from &#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a> (p. <a href="100-10.3._customizing_operations.html#filepos2530282">391</a>) to use function-object classes in place of lambdas.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.41:</strong> Why do you suppose the new standard added lambdas? Explain when you would use a lambda and when you would write a class instead.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3679636" class="calibre37"><span class="calibre5">14.8.2. Library-Defined Function Objects</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">The standard library defines a set of classes that represent the arithmetic, relational, and logical operators. Each class defines a call operator that applies the named operation. For example, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">plus</span></tt></code> class has a function-call operator that applies <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> to a pair of operands; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">modulus</span></tt></code> class defines a call operator that applies the binary <code class="calibre23"><tt class="calibre23"><span class="calibre24">%</span></tt></code> operator; the <code class="calibre23"><tt class="calibre23"><span class="calibre24">equal_to</span></tt></code> class applies <code class="calibre23"><tt class="calibre23"><span class="calibre24">==;</span></tt></code> and so on.</p><div class="calibre15">&#160;</div>
<p class="calibre25">These classes are templates to which we supply a single type. That type specifies the parameter type for the call operator. For example, <code class="calibre23"><tt class="calibre23"><span class="calibre24">plus&lt;string&gt;</span></tt></code> applies the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> addition operator to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> objects; for <code class="calibre23"><tt class="calibre23"><span class="calibre24">plus&lt;int&gt;</span></tt></code> the operands are <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s; <code class="calibre23"><tt class="calibre23"><span class="calibre24">plus&lt;Sales_data&gt;</span></tt></code> applies <code class="calibre23"><tt class="calibre23"><span class="calibre24">+</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">Sales_data</span></tt></code>s; and so on:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos3681503"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">plus&lt;int&gt; intAdd;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function object that can add two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">values</span></span></span><br class="calibre6"/>negate&lt;int&gt; intNegate;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function object that can negate an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">value</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">intAdd::operator(int, int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">to add</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">10</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">20</span></span></tt></span><br class="calibre6"/>int sum = intAdd(10, 20);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum = 30</span></span></tt></span><br class="calibre6"/>sum = intNegate(intAdd(10, 20));&#160;&#160;// <span><span class="calibre45"><span class="calibre16">equivalent to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum = 30</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">uses</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">intNegate::operator(int</span></span></tt></span>) <span><span class="calibre45"><span class="calibre16">to generate</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">-10</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">as the second parameter</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">intAdd::operator(int, int)</span></span></tt></span><br class="calibre6"/>sum = intAdd(10, intNegate(10));&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">sum = 0</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">These types, listed in <a href="137-14.8._functioncall_operator.html#filepos3684209">Table 14.2</a>, are defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3684209"/>Table 14.2. Library Function Objects</span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00100.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Using a Library Function Object with the Algorithms</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">The function-object classes that represent operators are often used to override the default operator used by an algorithm. As we&#8217;ve seen, by default, the sorting algorithms use <code class="calibre23"><tt class="calibre23"><span class="calibre24">operator&lt;</span></tt></code>, which ordinarily sorts the sequence into ascending order. To sort into descending order, we can pass an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">greater</span></tt></code>. That class generates a call operator that invokes the greater-than operator of the underlying element type. For example, if <code class="calibre23"><tt class="calibre23"><span class="calibre24">svec</span></tt></code> is a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector&lt;string&gt;</span></tt></code>,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">passes a temporary function object that applies the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">operator to two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>sort(svec.begin(), svec.end(), greater&lt;string&gt;());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">sorts the <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> in descending order. The third argument is an unnamed object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">greater&lt;string&gt;</span></tt></code>. When <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> compares elements, rather than applying the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;</span></tt></code> operator for the element type, it will call the given <code class="calibre23"><tt class="calibre23"><span class="calibre24">greater</span></tt></code> function object. That object applies <code class="calibre23"><tt class="calibre23"><span class="calibre24">&gt;</span></tt></code> to the <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> elements.</p><div class="calibre15">&#160;</div>
<p class="calibre25">One important aspect of these library function objects is that the library guarantees that they will work for pointers. Recall that comparing two unrelated pointers is undefined (&#167; <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">120</a>). However, we might want to <code class="calibre23"><tt class="calibre23"><span class="calibre24">sort</span></tt></code> a <code class="calibre23"><tt class="calibre23"><span class="calibre24">vector</span></tt></code> of pointers based on their addresses in memory. Although it would be undefined for us to do so directly, we can do so through one of the library function objects:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">vector&lt;string *&gt; nameTable;&#160;&#160;// <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">vector</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">of pointers</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">error: the pointers in</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">nameTable</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">are unrelated, so</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">&lt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is undefined</span></span></span><br class="calibre6"/>sort(nameTable.begin(), nameTable.end(),<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;[](string *a, string *b) { return a &lt; b; });<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">ok: library guarantees that</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">less</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">on pointer types is well defined</span></span></span><br class="calibre6"/>sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3688875"/>It is also worth noting that the associative containers use <code class="calibre23"><tt class="calibre23"><span class="calibre24">less&lt;key_type&gt;</span></tt></code> to order their elements. As a result, we can define a <code class="calibre23"><tt class="calibre23"><span class="calibre24">set</span></tt></code> of pointers or use a pointer as the key in a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> without specifying <code class="calibre23"><tt class="calibre23"><span class="calibre24">less</span></tt></code> directly.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.8.2</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.42:</strong> Using library function objects and adaptors, define an expression to</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre25">(a) Count the number of values that are greater than 1024</p><div class="calibre22">&#160;</div>
<p class="calibre25">(b) Find the first string that is not equal to <code class="calibre23"><tt class="calibre23"><span class="calibre24">pooh</span></tt></code></p><div class="calibre22">&#160;</div>
<p class="calibre25">(c) Multiply all values by 2</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.43:</strong> Using library function objects, determine whether a given <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> value is divisible by any element in a container of <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 id="filepos3690557" class="calibre37"><span class="calibre5">14.8.3. Callable Objects and <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code></span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">C++ has several kinds of callable objects: functions and pointers to functions, lambdas (&#167; <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>), objects created by <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> (&#167; <a href="100-10.3._customizing_operations.html#filepos2586884">10.3.4</a>, p. <a href="100-10.3._customizing_operations.html#filepos2586884">397</a>), and classes that overload the function-call operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Like any other object, a callable object has a type. For example, each lambda has its own unique (unnamed) class type. Function and function-pointer types vary by their return type and argument types, and so on.</p><div class="calibre22">&#160;</div>
<p class="calibre25">However, two callable objects with different types may share the same <strong class="calibre5"><a id="filepos3691634" href="140-defined_terms.html#filepos3775218">call signature</a></strong>. The call signature specifies the type returned by a call to the object and the argument type(s) that must be passed in the call. A call signature corresponds to a function type. For example:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int(int, int)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">is a function type that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s and returns an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Different Types Can Have the Same Call Signature</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">Sometimes we want to treat several callable objects that share a call signature as if they had the same type. For example, consider the following different types of callable objects:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ordinary function</span></span></span><br class="calibre6"/>int add(int i, int j) { return i + j; }<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">lambda, which generates an unnamed function-object class</span></span></span><br class="calibre6"/>auto mod = [](int i, int j) { return i % j; };<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">function-object class</span></span></span><br class="calibre6"/>struct div {<br class="calibre6"/>&#160;&#160;&#160;&#160;int operator()(int denominator, int divisor) {<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return denominator / divisor;<br class="calibre6"/>&#160;&#160;&#160;&#160;}<br class="calibre6"/>};</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3693609"/>Each of these callables applies an arithmetic operation to its parameters. Even though each has a distinct type, they all share the same call signature:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int(int, int)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre25">We might want to use these callables to build a simple desk calculator. To do so, we&#8217;d want to define a <strong class="calibre5"><a id="filepos3694101" href="140-defined_terms.html#filepos3777681">function table</a></strong> to store &#8220;pointers&#8221; to these callables. When the program needs to execute a particular operation, it will look in the table to find which function to call.</p><div class="calibre22">&#160;</div>
<p class="calibre25">In C++, function tables are easy to implement using a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>. In this case, we&#8217;ll use a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> corresponding to an operator symbol as the key; the value will be the function that implements that operator. When we want to evaluate a given operator, we&#8217;ll index the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> with that operator and call the resulting element.</p><div class="calibre22">&#160;</div>
<p class="calibre25">If all our functions were freestanding functions, and assuming we were handling only binary operators for type <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>, we could define the <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> as</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">maps an operator to a pointer to a function taking two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s and returning an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>map&lt;string, int(*)(int,int)&gt; binops;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We could put a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">add</span></tt></code> into <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops</span></tt></code> as follows:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a pointer to function of the appropriate type</span></span></span><br class="calibre6"/>binops.insert({"+", add}); // <span><tt class="calibre23"><span class="calibre46"><span class="calibre16">{"+", add}</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">pair</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">&#167; 11.2.3 (p. 426</span></span></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">However, we can&#8217;t store <code class="calibre23"><tt class="calibre23"><span class="calibre24">mod</span></tt></code> or <code class="calibre23"><tt class="calibre23"><span class="calibre24">div</span></tt></code> in <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">binops.insert({"%", mod}); // <span><span class="calibre45"><span class="calibre16">error:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">mod</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not a pointer to function</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The problem is that <code class="calibre23"><tt class="calibre23"><span class="calibre24">mod</span></tt></code> is a lambda, and each lambda has its own class type. That type does not match the type of the values stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops</span></tt></code>.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">The Library <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code> Type</span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We can solve this problem using a new library type named <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code> that is defined in the <code class="calibre23"><tt class="calibre23"><span class="calibre24">functional</span></tt></code> header; <a href="137-14.8._functioncall_operator.html#filepos3699074">Table 14.3</a> (p. <a href="137-14.8._functioncall_operator.html#filepos3699074">579</a>) lists the operations defined by <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>.</p><div class="calibre15">&#160;</div>
<p class="calibre51"><span class="calibre5"><a id="filepos3699074"/>Table 14.3. Operations on <code class="calibre23"><tt class="calibre23"><span class="calibre24"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code></span></p><div class="calibre12">&#160;</div>
<div class="calibre52"><img alt="Image" src="images/00101.jpg" class="calibre9"/></div><div class="calibre22">&#160;</div>
<div class="calibre28"><a id="filepos3699379"/><img alt="Image" src="images/00008.jpg" class="calibre9"/></div>
<p class="calibre25"><code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> is a template. As with other templates we&#8217;ve used, we must specify additional information when we create a <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> type. In this case, that information is the call signature of the objects that this particular <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> type can represent. As with other templates, we specify the type inside angle brackets:</p><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">function&lt;int(int, int)&gt;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we&#8217;ve declared a <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> type that can represent callable objects that return an <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> result and have two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code> parameters. We can use that type to represent any of our desk calculator types:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">function&lt;int(int, int)&gt; f1 = add;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function pointer</span></span></span><br class="calibre6"/>function&lt;int(int, int)&gt; f2 = div();&#160;&#160;// <span><span class="calibre45"><span class="calibre16">object of a function-object class</span></span></span><br class="calibre6"/>function&lt;int(int, int)&gt; f3 = [](int&#160;&#160;i, int j) // <span><span class="calibre45"><span class="calibre16">lambda</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ return i * j; };<br class="calibre6"/>cout &lt;&lt; f1(4,2) &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">6</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; f2(4,2) &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">2</span></span></tt></span><br class="calibre6"/>cout &lt;&lt; f3(4,2) &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">prints</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">8</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a/>We can now redefine our <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> using this <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> type:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">table of callable objects corresponding to each binary operator</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">all the callables must take two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s and return an</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">an element can be a function pointer, function object, or lambda</span></span></span><br class="calibre6"/>map&lt;string, function&lt;int(int, int)&gt;&gt; binops;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">We can add each of our callable objects, be they function pointers, lambdas, or function objects, to this <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">map&lt;string, function&lt;int(int, int)&gt;&gt; binops = {<br class="calibre6"/>&#160;&#160;&#160;&#160;{"+", add},&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">function pointer</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{"-", std::minus&lt;int&gt;()},&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">library function object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{"/",&#160;&#160;div()},&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">user-defined function object</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{"*", [](int i, int j) { return i * j; }}, // <span><span class="calibre45"><span class="calibre16">unnamed lambda</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;{"%", mod} };&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">named lambda object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Our <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code> has five elements. Although the underlying callable objects all have different types from one another, we can store each of these distinct types in the common <code class="calibre23"><tt class="calibre23"><span class="calibre24">function&lt;int(int, int)&gt;</span></tt></code> type.</p><div class="calibre15">&#160;</div>
<p class="calibre25">As usual, when we index a <code class="calibre23"><tt class="calibre23"><span class="calibre24">map</span></tt></code>, we get a reference to the associated value. When we index <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops</span></tt></code>, we get a reference to an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>. The <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> type overloads the call operator. That call operator takes its own arguments and passes them along to its stored callable object:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">binops["+"](10, 5); // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add(10, 5)</span></span></tt></span><br class="calibre6"/>binops["-"](10, 5); // <span><span class="calibre45"><span class="calibre16">uses the call operator of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">minus&lt;int&gt;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>binops["/"](10, 5); // <span><span class="calibre45"><span class="calibre16">uses the call operator of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">div</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">object</span></span></span><br class="calibre6"/>binops["*"](10, 5); // <span><span class="calibre45"><span class="calibre16">calls the lambda function object</span></span></span><br class="calibre6"/>binops["%"](10, 5); // <span><span class="calibre45"><span class="calibre16">calls the lambda function object</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here we call each of the operations stored in <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops</span></tt></code>. In the first call, the element we get back holds a function pointer that points to our <code class="calibre23"><tt class="calibre23"><span class="calibre24">add</span></tt></code> function. Calling <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops["+"](10, 5)</span></tt></code> uses that pointer to call <code class="calibre23"><tt class="calibre23"><span class="calibre24">add</span></tt></code>, passing it the values <code class="calibre23"><tt class="calibre23"><span class="calibre24">10</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">5</span></tt></code>. In the next call, <code class="calibre23"><tt class="calibre23"><span class="calibre24">binops["-"]</span></tt></code>, returns a <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> that stores an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">std::minus&lt;int&gt;</span></tt></code>. We call that object&#8217;s call operator, and so on.</p><div class="calibre15">&#160;</div>
<h5 class="calibre39"><span class="calibre5">Overloaded Functions and <code class="calibre23"><tt class="calibre23"><span class="calibre49"><span><tt class="calibre23"><span class="calibre32"><span class="calibre5">function</span></span></tt></span></span></tt></code></span></h5><div class="calibre38">&#160;</div>
<p class="calibre14">We cannot (directly) store the name of an overloaded function in an object of type <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code>:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int add(int i, int j) { return i + j; }<br class="calibre6"/>Sales_data add(const Sales_data&amp;, const Sales_data&amp;);<br class="calibre6"/>map&lt;string, function&lt;int(int, int)&gt;&gt; binops;<br class="calibre6"/>binops.insert( {"+", add} ); // <span><span class="calibre45"><span class="calibre16">error: which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add</span></span></tt></span><span><span class="calibre45"><span class="calibre16">?</span></span></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">One way to resolve the ambiguity is to store a function pointer (&#167; <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>) instead of the name of the function:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">int (*fp)(int,int) = add; // <span><span class="calibre45"><span class="calibre16">pointer to the version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">that takes two</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">int</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span><br class="calibre6"/>binops.insert( {"+", fp} ); // <span><span class="calibre45"><span class="calibre16">ok:</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">fp</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points to the right version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add</span></span></tt></span></span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos3710616"/>Alternatively, we can use a lambda to disambiguate:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">ok: use a lambda to disambiguate which version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">add</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">we want to use</span></span></span><br class="calibre6"/>binops.insert( {"+", [](int a, int b) {return add(a, b);} } );</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">The call inside the lambda body passes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s. That call can match only the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">add</span></tt></code> that takes two <code class="calibre23"><tt class="calibre23"><span class="calibre24">int</span></tt></code>s, and so that is the function that is called when the lambda is executed.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">The <code class="calibre23"><tt class="calibre23"><span class="calibre24">function</span></tt></code> class in the new library is not related to classes named <code class="calibre23"><tt class="calibre23"><span class="calibre24">unary_function</span></tt></code> and <code class="calibre23"><tt class="calibre23"><span class="calibre24">binary_function</span></tt></code> that were part of earlier versions of the library. These classes have been deprecated by the more general <code class="calibre23"><tt class="calibre23"><span class="calibre24">bind</span></tt></code> function (&#167; <a href="100-10.3._customizing_operations.html#filepos2586884">10.3.4</a>, p. <a href="100-10.3._customizing_operations.html#filepos2586884">401</a>).</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 14.8.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 14.44:</strong> Write your own version of a simple desk calculator that can handle binary operations.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="136-14.7._member_access_operators.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="138-14.9._overloading_conversions_and_operators.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
