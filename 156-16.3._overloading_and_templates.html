<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>16.3. Overloading and Templates</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="155-16.2._template_argument_deduction.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="157-16.4._variadic_templates.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table><h3 id="filepos4436613" class="calibre29"><span class="bold">16.3. Overloading and Templates</span></h3><div class="calibre12">&#160;</div>
<div class="calibre28"><img alt="Image" src="images/00010.jpg" class="calibre9"/></div>
<p class="calibre14">Function templates can be overloaded by other templates or by ordinary, nontemplate functions. As usual, functions with the same name must differ either as to the number or the type(s) of their parameters.</p><div class="calibre15">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><a id="filepos4437068"/><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.2.7</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.47:</strong> Write your own version of the flip function and test it by calling functions that have lvalue and rvalue reference parameters.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<p class="calibre14">Function matching (&#167; <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) is affected by the presence of function templates in the following ways:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The candidate functions for a call include any function-template instantiation for which template argument deduction (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4324217">16.2</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4324217">678</a>) succeeds.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; The candidate function templates are always viable, because template argument deduction will have eliminated any templates that are not viable.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; As usual, the viable functions (template and nontemplate) are ranked by the conversions, if any, needed to make the call. Of course, the conversions used to call a function template are quite limited (&#167; <a href="155-16.2._template_argument_deduction.html#filepos4324892">16.2.1</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4324892">679</a>).</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; Also as usual, if exactly one function provides a better match than any of the others, that function is selected. However, if there are several functions that provide an equally good match, then:</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; If there is only one nontemplate function in the set of equally good matches, the nontemplate function is called.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; If there are no nontemplate functions in the set, but there are multiple function templates, and one of these templates is more specialized than any of the others, the more specialized function template is called.</p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre58">&#8211; Otherwise, the call is ambiguous.</p></blockquote><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00013.jpg" class="calibre9"/> Warning</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Correctly defining a set of overloaded function templates requires a good understanding of the relationship among types and of the restricted conversions applied to arguments in template functions.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Writing Overloaded Templates</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As an example, we&#8217;ll build a set of functions that might be useful during debugging. We&#8217;ll name our debugging functions <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code>, each of which will return a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> representation of a given object. We&#8217;ll start by writing the most general version of this function as a template that takes a reference to a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> object:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print any type we don't otherwise handle</span></span></span><br class="calibre6"/>template &lt;typename T&gt; string debug_rep(const T &amp;t)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;ostringstream ret; // <span><span class="calibre45"><span class="calibre16">see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 8.3 (p. 321)</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;ret &lt;&lt; t; // <span><span class="calibre45"><span class="calibre16">uses T's output operator to print a representation of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">t</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return ret.str(); // <span><span class="calibre45"><span class="calibre16">return a copy of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14"><a id="filepos4442199"/>This function can be used to generate a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> corresponding to an object of any type that has an output operator.</p><div class="calibre15">&#160;</div>
<p class="calibre25">Next, we&#8217;ll define a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> to print pointers:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print pointers as their pointer value, followed by the object to which the pointer points</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">NB: this function will not work properly with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">char*;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">see</span></span></span>
<span><span class="calibre45"><span class="calibre16">&#167; 16.3 (p. 698)</span></span></span><br class="calibre6"/>template &lt;typename T&gt; string debug_rep(T *p)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;ostringstream ret;<br class="calibre6"/>&#160;&#160;&#160;&#160;ret &lt;&lt; "pointer: " &lt;&lt; p;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">print the pointer's own value</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;if (p)<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret &lt;&lt; " " &lt;&lt; debug_rep(*p); // <span><span class="calibre45"><span class="calibre16">print the value to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">points</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;else<br class="calibre6"/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ret &lt;&lt; " null pointer";&#160;&#160;&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">or indicate that the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">p</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is null</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return ret.str(); // <span><span class="calibre45"><span class="calibre16">return a copy of the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to which</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">ret</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is bound</span></span></span><br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">This version generates a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code> that contains the pointer&#8217;s own value and calls <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> to print the object to which that pointer points. Note that this function can&#8217;t be used to print character pointers, because the IO library defines a version of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> for <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code> values. That version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">&lt;&lt;</span></tt></code> assumes the pointer denotes a null-terminated character array, and prints the contents of the array, not its address. We&#8217;ll see in &#167; <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">698</a>) how to handle character pointers.</p><div class="calibre15">&#160;</div>
<p class="calibre25">We might use these functions as follows:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s("hi");<br class="calibre6"/>cout &lt;&lt; debug_rep(s) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">For this call, only the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> is viable. The second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> requires a pointer parameter, and in this call we passed a nonpointer object. There is no way to instantiate a function template that expects a pointer type from a nonpointer argument, so argument deduction fails. Because there is only one viable function, that is the one that is called.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> with a pointer:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">both functions generate viable instantiations:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string* &amp;)</span></tt></code>, which is the instantiation of the first version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string*</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(string*)</span></tt></code>, which is the instantiation of the second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">The instantiation of the second version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> is an exact match for this call. The instantiation of the first version requires a conversion of the plain pointer to a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. Normal function matching says we should prefer the second template, and indeed that is the one that is run.</p><div class="calibre15">&#160;</div>
<h4 class="calibre37"><span class="calibre5"><a id="filepos4448901"/>Multiple Viable Templates</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">As another example, consider the following call:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">const string *sp = &amp;s;<br class="calibre6"/>cout &lt;&lt; debug_rep(sp) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here both templates are viable and both provide an exact match:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string* &amp;)</span></tt></code>, the instantiation of the first version of the template with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string*</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string*)</span></tt></code>, the instantiation of the second version of the template with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const string</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">In this case, normal function matching can&#8217;t distinguish between these two calls. We might expect this call to be ambiguous. However, due to the special rule for overloaded function templates, this call resolves to <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(T*)</span></tt></code>, which is the more specialized template.</p><div class="calibre15">&#160;</div>
<p class="calibre25">The reason for this rule is that without it, there would be no way to call the pointer version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> on a pointer to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code>. The problem is that the template <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const T&amp;)</span></tt></code> can be called on essentially any type, including pointer types. That template is more general than <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(T*)</span></tt></code>, which can be called only on pointer types. Without this rule, calls that passed pointers to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const</span></tt></code> would always be ambiguous.</p><div class="calibre22">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When there are several overloaded templates that provide an equally good match for a call, the most specialized version is preferred.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Nontemplate and Template Overloads</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">For our next example, we&#8217;ll define an ordinary nontemplate version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> to print <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s inside double quotes:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">print</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><span><span class="calibre45"><span class="calibre16">s</span></span></span>
<span><span class="calibre45"><span class="calibre16">inside double quotes</span></span></span><br class="calibre6"/>string debug_rep(const string &amp;s)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return '"' + s + '"';<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Now, when we call <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> on a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>,</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">string s("hi");<br class="calibre6"/>cout &lt;&lt; debug_rep(s) &lt;&lt; endl;</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">there are two equally good viable functions:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep&lt;string&gt;(const string&amp;)</span></tt></code>, the first template with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string&amp;)</span></tt></code>, the ordinary, nontemplate function</p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14"><a id="filepos4454462"/>In this case, both functions have the same parameter list, so obviously, each function provides an equally good match for this call. However, the nontemplate version is selected. For the same reasons that the most specialized of equally good function templates is preferred, a nontemplate function is preferred over equally good match(es) to a function template.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00012.jpg" class="calibre9"/> Note</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">When a nontemplate function provides an equally good match for a call as a function template, the nontemplate version is preferred.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Overloaded Templates and Conversions</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">There&#8217;s one case we haven&#8217;t covered so far: pointers to C-style character strings and string literals. Now that we have a version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, we might expect that a call that passes character strings would match that version. However, consider this call:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">cout &lt;&lt; debug_rep("hi world!") &lt;&lt; endl; // <span><span class="calibre45"><span class="calibre16">calls</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep(T*</span></span></tt></span>)</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Here all three of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> functions are viable:</p><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const T&amp;)</span></tt></code>, with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">char[10]</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(T*)</span></tt></code>, with <code class="calibre23"><tt class="calibre23"><span class="calibre24">T</span></tt></code> bound to <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<blockquote class="calibre26"><p class="calibre27">&#8226; <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string&amp;)</span></tt></code>, which requires a conversion from <code class="calibre23"><tt class="calibre23"><span class="calibre24">const char*</span></tt></code> to <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code></p></blockquote><div class="calibre15">&#160;</div>
<p class="calibre14">Both templates provide an exact match to the argument&#8212;the second template requires a (permissible) conversion from array to pointer, and that conversion is considered as an exact match for function-matching purposes (&#167; <a href="068-6.6._function_matching.html#filepos1689576">6.6.1</a>, p. <a href="068-6.6._function_matching.html#filepos1689576">245</a>). The nontemplate version is viable but requires a user-defined conversion. That function is less good than an exact match, leaving the two templates as the possible functions to call. As before, the <code class="calibre23"><tt class="calibre23"><span class="calibre24">T*</span></tt></code> version is more specialized and is the one that will be selected.</p><div class="calibre15">&#160;</div>
<p class="calibre25">If we want to handle character pointers as <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>s, we can define two more nontemplate overloads:</p><div class="calibre22">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">// <span><span class="calibre45"><span class="calibre16">convert the character pointers to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">and call the</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">version of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep</span></span></tt></span><br class="calibre6"/>string debug_rep(char *p)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return debug_rep(string(p));<br class="calibre6"/>}<br class="calibre6"/>string debug_rep(const char *p)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;return debug_rep(string(p));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<h4 class="calibre37"><span class="calibre5">Missing Declarations Can Cause the Program to Misbehave</span></h4><div class="calibre38">&#160;</div>
<p class="calibre14">It is worth noting that for the <code class="calibre23"><tt class="calibre23"><span class="calibre24">char*</span></tt></code> versions of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> to work correctly, a declaration for <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep(const string&amp;)</span></tt></code> must be in scope when these functions are defined. If not, the wrong version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> will be called:</p><div class="calibre15">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"><a id="filepos4460209"/></span></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; string debug_rep(const T &amp;t);<br class="calibre6"/>template &lt;typename T&gt; string debug_rep(T *p);<br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">the following declaration must be in scope</span></span></span><br class="calibre6"/>// <span><span class="calibre45"><span class="calibre16">for the definition of</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep(char*)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">to do the right thing</span></span></span><br class="calibre6"/>string debug_rep(const string &amp;);<br class="calibre6"/>string debug_rep(char *p)<br class="calibre6"/>{<br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">if the declaration for the version that takes a</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">const string&amp;</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">is not in scope</span></span></span><br class="calibre6"/>&#160;&#160;&#160;&#160;// <span><span class="calibre45"><span class="calibre16">the return will call</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">debug_rep(const T&amp;)</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">with</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">T</span></span></tt></span>
<span><span class="calibre45"><span class="calibre16">instantiated to</span></span></span>
<span><tt class="calibre23"><span class="calibre46"><span class="calibre16">string</span></span></tt></span><br class="calibre6"/>&#160;&#160;&#160;&#160;return debug_rep(string(p));<br class="calibre6"/>}</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<p class="calibre14">Ordinarily, if we use a function that we forgot to declare, our code won&#8217;t compile. Not so with functions that overload a template function. If the compiler can instantiate the call from the template, then the missing declaration won&#8217;t matter. In this example, if we forget to declare the version of <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">string</span></tt></code>, the compiler will <em class="calibre16">silently</em> instantiate the template version that takes a <code class="calibre23"><tt class="calibre23"><span class="calibre24">const T&amp;</span></tt></code>.</p><div class="calibre15">&#160;</div>
<div class="calibre33"><blockquote class="calibre26"><hr class="calibre34"/><p class="calibre14"><span class="calibre5"><a/><img alt="Image" src="images/00018.jpg" class="calibre9"/> Tip</span></p><div class="calibre15">&#160;</div>
<blockquote class="calibre13"><p class="calibre14">Declare every function in an overload set before you define any of the functions. That way you don&#8217;t have to worry whether the compiler will instantiate a call before it sees the function you intended to call.</p></blockquote><div class="calibre22">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<div class="calibre42"><blockquote class="calibre26"><hr class="calibre34"/><blockquote class="calibre13"><p class="calibre43"><span class="calibre5">Exercises Section 16.3</span></p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.48:</strong> Write your own versions of the <code class="calibre23"><tt class="calibre23"><span class="calibre24">debug_rep</span></tt></code> functions.</p></blockquote><div class="calibre10">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.49:</strong> Explain what happens in each of the following calls:</p></blockquote><div class="calibre10">&#160;</div>
<p class="calibre40"><span class="calibre41"><span class="calibre5"/></span></p><div class="calibre38">&#160;</div>
<blockquote class="calibre13"><p class="calibre31"><tt class="calibre23"><span class="calibre24">template &lt;typename T&gt; void f(T);<br class="calibre6"/>template &lt;typename T&gt; void f(const T*);<br class="calibre6"/>template &lt;typename T&gt; void g(T);<br class="calibre6"/>template &lt;typename T&gt; void g(T*);<br class="calibre6"/>int i = 42, *p = &amp;i;<br class="calibre6"/>const int ci = 0, *p2 = &amp;ci;<br class="calibre6"/>g(42);&#160;&#160;&#160;g(p);&#160;&#160;&#160;g(ci);&#160;&#160;&#160;g(p2);<br class="calibre6"/>f(42);&#160;&#160;&#160;f(p);&#160;&#160;&#160;f(ci);&#160;&#160;&#160;f(p2);</span></tt></p></blockquote><div class="calibre22">&#160;</div>
<blockquote class="calibre13"><p class="calibre44"><a/><strong class="calibre5">Exercise 16.50:</strong> Define the functions from the previous exercise so that they print an identifying message. Run the code from that exercise. If the calls behave differently from what you expected, make sure you understand why.</p></blockquote><div class="calibre10">&#160;</div>
<hr class="calibre34"/></blockquote></div><div class="calibre3">&#160;</div>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr><td><div STYLE="MARGIN-LEFT: 0.15in;"><a href="001-contents.html"><img src="images/teamlib.gif" width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a></div></td><td align="right"><div STYLE="MARGIN-LEFT: 0.15in;">
<a href="155-16.2._template_argument_deduction.html"><img src="images/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
<a href="157-16.4._variadic_templates.html"><img src="images/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a></div></td></tr></table></body></html>
